{
  "widget-schemas": {
    "sympy-sympy-calculus-euler-euler_equations": {
      "id": "sympy-sympy-calculus-euler-euler_equations",
      "name": "SymPy euler_equations",
      "description": "Find the Euler-Lagrange equations [1]_ for a given Lagrangian.",
      "category": "sympy",
      "module": "sympy.calculus.euler",
      "function": "euler_equations",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "L": {
            "type": "string",
            "description": "The Lagrangian that should be a function of the functions listed in the second argument and their derivatives. For example, in the case of two functions $f(x,y)$, $g(x,y)$ and two independent variables $x$, $y$ the Lagrangian has the form: \\frac{\\partial f(x,y)}{\\partial y}, \\frac{\\partial g(x,y)}{\\partial x}, \\frac{\\partial g(x,y)}{\\partial y},x,y\\right) In many cases it is not necessary to provide anything, except the Lagrangian, it will be auto-detected (and an error raised if this cannot be done).",
            "default": "x**2 + y**2"
          },
          "funcs": {
            "type": "array",
            "description": "The functions that the Lagrangian depends on. The Euler equations are differential equations for each of these functions.",
            "default": []
          },
          "vars": {
            "type": "string",
            "description": "The Symbols that are the independent variables of the functions.",
            "default": "()"
          }
        },
        "required": [
          "L"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-calculus-util-continuous_domain": {
      "id": "sympy-sympy-calculus-util-continuous_domain",
      "name": "SymPy continuous_domain",
      "description": "Returns the domain on which the function expression f is continuous. This function is limited by the ability to determine the various singularities and discontinuities of the given function. The result is either given as a union of intervals or constructed using other set operations.",
      "category": "sympy",
      "module": "sympy.calculus.util",
      "function": "continuous_domain",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "The concerned function.",
            "default": "x**2 + y**2"
          },
          "symbol": {
            "type": "string",
            "description": "The variable for which the intervals are to be determined.",
            "default": ""
          },
          "domain": {
            "type": "integer",
            "description": "The domain over which the continuity of the symbol has to be checked."
          }
        },
        "required": [
          "f",
          "symbol",
          "domain"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-calculus-util-function_range": {
      "id": "sympy-sympy-calculus-util-function_range",
      "name": "SymPy function_range",
      "description": "Finds the range of a function in a given domain. This method is limited by the ability to determine the singularities and determine limits.",
      "category": "sympy",
      "module": "sympy.calculus.util",
      "function": "function_range",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "The concerned function.",
            "default": "x**2 + y**2"
          },
          "symbol": {
            "type": "string",
            "description": "The variable for which the range of function is to be determined.",
            "default": ""
          },
          "domain": {
            "type": "integer",
            "description": "The domain under which the range of the function has to be found."
          }
        },
        "required": [
          "f",
          "symbol",
          "domain"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-calculus-util-is_convex": {
      "id": "sympy-sympy-calculus-util-is_convex",
      "name": "SymPy is_convex",
      "description": "Determines the  convexity of the function passed in the argument.",
      "category": "sympy",
      "module": "sympy.calculus.util",
      "function": "is_convex",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "The concerned function.",
            "default": "x**2 + y**2"
          },
          "syms": {
            "type": "string",
            "description": "The variables with respect to which the convexity is to be determined.",
            "default": ""
          },
          "domain": {
            "type": "integer",
            "description": "The domain over which the convexity of the function has to be checked. If unspecified, S.Reals will be the default domain."
          }
        },
        "required": [
          "f",
          "syms"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-calculus-util-lcim": {
      "id": "sympy-sympy-calculus-util-lcim",
      "name": "SymPy lcim",
      "description": "Returns the least common integral multiple of a list of numbers. The numbers can be rational or irrational or a mixture of both. `None` is returned for incommensurable numbers.",
      "category": "sympy",
      "module": "sympy.calculus.util",
      "function": "lcim",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "numbers": {
            "type": "array",
            "description": "Numbers (rational and/or irrational) for which lcim is to be found.",
            "default": [],
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "numbers"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-calculus-util-maximum": {
      "id": "sympy-sympy-calculus-util-maximum",
      "name": "SymPy maximum",
      "description": "Returns the maximum value of a function in the given domain.",
      "category": "sympy",
      "module": "sympy.calculus.util",
      "function": "maximum",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "The concerned function.",
            "default": "x**2 + y**2"
          },
          "symbol": {
            "type": "string",
            "description": "The variable for maximum value needs to be determined.",
            "default": ""
          },
          "domain": {
            "type": "integer",
            "description": "The domain over which the maximum have to be checked. If unspecified, then the global maximum is returned."
          }
        },
        "required": [
          "f",
          "symbol"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-calculus-util-minimum": {
      "id": "sympy-sympy-calculus-util-minimum",
      "name": "SymPy minimum",
      "description": "Returns the minimum value of a function in the given domain.",
      "category": "sympy",
      "module": "sympy.calculus.util",
      "function": "minimum",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "The concerned function.",
            "default": "x**2 + y**2"
          },
          "symbol": {
            "type": "string",
            "description": "The variable for minimum value needs to be determined.",
            "default": ""
          },
          "domain": {
            "type": "integer",
            "description": "The domain over which the minimum have to be checked. If unspecified, then the global minimum is returned."
          }
        },
        "required": [
          "f",
          "symbol"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-calculus-util-not_empty_in": {
      "id": "sympy-sympy-calculus-util-not_empty_in",
      "name": "SymPy not_empty_in",
      "description": "Finds the domain of the functions in ``finset_intersection`` in which the ``finite_set`` is not-empty.",
      "category": "sympy",
      "module": "sympy.calculus.util",
      "function": "not_empty_in",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "finset_intersection": {
            "type": "integer",
            "description": "The unevaluated intersection of FiniteSet containing real-valued functions with Union of Sets"
          },
          "syms": {
            "type": "string",
            "description": "Symbol for which domain is to be found The algorithms to find the non-emptiness of the given FiniteSet are not yet implemented. The input is not valid. It is a bug, please report it to the github issue tracker (https://github.com/sympy/sympy/issues).",
            "default": ""
          }
        },
        "required": [
          "finset_intersection",
          "syms"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-calculus-util-periodicity": {
      "id": "sympy-sympy-calculus-util-periodicity",
      "name": "SymPy periodicity",
      "description": "Tests the given function for periodicity in the given symbol.",
      "category": "sympy",
      "module": "sympy.calculus.util",
      "function": "periodicity",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "The concerned function.",
            "default": "x**2 + y**2"
          },
          "symbol": {
            "type": "string",
            "description": "The variable for which the period is to be determined.",
            "default": ""
          },
          "check": {
            "type": "boolean",
            "description": "The flag to verify whether the value being returned is a period or not.",
            "default": false
          }
        },
        "required": [
          "f",
          "symbol"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-calculus-util-stationary_points": {
      "id": "sympy-sympy-calculus-util-stationary_points",
      "name": "SymPy stationary_points",
      "description": "Returns the stationary points of a function (where derivative of the function is 0) in the given domain.",
      "category": "sympy",
      "module": "sympy.calculus.util",
      "function": "stationary_points",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "The concerned function.",
            "default": "x**2 + y**2"
          },
          "symbol": {
            "type": "string",
            "description": "The variable for which the stationary points are to be determined.",
            "default": ""
          },
          "domain": {
            "type": "integer",
            "description": "The domain over which the stationary points have to be checked. If unspecified, ``S.Reals`` will be the default domain."
          }
        },
        "required": [
          "f",
          "symbol"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-arity": {
      "id": "sympy-sympy-core-function-arity",
      "name": "SymPy arity",
      "description": "Return the arity of the function if it is known, else None. Explanation When default values are specified for some arguments, they are optional and the arity is reported as a tuple of possible values. Examples >>> from sympy import arity, log >>> arity(lambda x: x) 1 >>> arity(log) (1, 2) >>> arity(lambda *x: sum(x)) is None True",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "arity",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "cls": {
            "type": "string",
            "description": "Parameter cls",
            "default": ""
          }
        },
        "required": [
          "cls"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-count_ops": {
      "id": "sympy-sympy-core-function-count_ops",
      "name": "SymPy count_ops",
      "description": "Return a representation (integer or expression) of the operations in expr.",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "count_ops",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "If expr is an iterable, the sum of the op counts of the items will be returned.",
            "default": "x**2 + y**2"
          },
          "visual": {
            "type": "boolean",
            "description": "If ``False`` (default) then the sum of the coefficients of the visual expression will be returned. If ``True`` then the number of each type of operation is shown with the core class types (or their virtual equivalent) multiplied by the number of times they occur.",
            "default": false
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-diff": {
      "id": "sympy-sympy-core-function-diff",
      "name": "SymPy diff",
      "description": "Differentiate f with respect to symbols. Explanation This is just a wrapper to unify .diff() and the Derivative class; its interface is similar to that of integrate().  You can use the same shortcuts for multiple variables as with Derivative.  For example, diff(f(x), x, x, x) and diff(f(x), x, 3) both return the third derivative of f(x). You can pass evaluate=False to get an unevaluated Derivative class.  Note that if there are 0 symbols (such as diff(f(x), x, 0), then the result will be the function (the zeroth derivative), even if evaluate=False. Examples >>> from sympy import sin, cos, Function, diff >>> from sympy.abc import x, y >>> f = Function('f') >>> diff(sin(x), x) cos(x) >>> diff(f(x), x, x, x) Derivative(f(x), (x, 3)) >>> diff(f(x), x, 3) Derivative(f(x), (x, 3)) >>> diff(sin(x)*cos(y), x, 2, y, 2) sin(x)*cos(y) >>> type(diff(sin(x), x)) cos >>> type(diff(sin(x), x, evaluate=False)) <class 'sympy.core.function.Derivative'> >>> type(diff(sin(x), x, 0)) sin >>> type(diff(sin(x), x, 0, evaluate=False)) sin >>> diff(sin(x)) cos(x) >>> diff(sin(x*y)) Traceback (most recent call last): ... ValueError: specify differentiation variables to differentiate sin(x*y) Note that ``diff(sin(x))`` syntax is meant only for convenience in interactive sessions and should be avoided in library code. References .. [1] https://reference.wolfram.com/legacy/v5_2/Built-inFunctions/AlgebraicComputation/Calculus/D.html See Also Derivative idiff: computes the derivative implicitly",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "diff",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "Parameter f",
            "default": "x**2 + y**2"
          },
          "symbols": {
            "type": "string",
            "description": "Parameter symbols",
            "default": [
              "t"
            ],
            "items": {
              "type": "string"
            }
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "f",
          "symbols",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-expand": {
      "id": "sympy-sympy-core-function-expand",
      "name": "SymPy expand",
      "description": "Expand an expression using methods given as hints. Explanation Hints evaluated unless explicitly set to False are:  ``basic``, ``log``, ``multinomial``, ``mul``, ``power_base``, and ``power_exp`` The following hints are supported but not applied unless set to True:  ``complex``, ``func``, and ``trig``.  In addition, the following meta-hints are supported by some or all of the other hints:  ``frac``, ``numer``, ``denom``, ``modulus``, and ``force``.  ``deep`` is supported by all hints.  Additionally, subclasses of Expr may define their own hints or meta-hints. The ``basic`` hint is used for any special rewriting of an object that should be done automatically (along with the other hints like ``mul``) when expand is called. This is a catch-all hint to handle any sort of expansion that may not be described by the existing hint names. To use this hint an object should override the ``_eval_expand_basic`` method. Objects may also define their own expand methods, which are not run by default.  See the API section below. If ``deep`` is set to ``True`` (the default), things like arguments of functions are recursively expanded.  Use ``deep=False`` to only expand on the top level. If the ``force`` hint is used, assumptions about variables will be ignored in making the expansion. Hints These hints are run by default mul --- Distributes multiplication over addition: >>> from sympy import cos, exp, sin >>> from sympy.abc import x, y, z >>> (y*(x + z)).expand(mul=True) x*y + y*z multinomial ----------- Expand (x + y + ...)**n where n is a positive integer. >>> ((x + y + z)**2).expand(multinomial=True) x**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2 power_exp --------- Expand addition in exponents into multiplied bases. >>> exp(x + y).expand(power_exp=True) exp(x)*exp(y) >>> (2**(x + y)).expand(power_exp=True) 2**x*2**y power_base ---------- Split powers of multiplied bases. This only happens by default if assumptions allow, or if the ``force`` meta-hint is used: >>> ((x*y)**z).expand(power_base=True) (x*y)**z >>> ((x*y)**z).expand(power_base=True, force=True) x**z*y**z >>> ((2*y)**z).expand(power_base=True) 2**z*y**z Note that in some cases where this expansion always holds, SymPy performs it automatically: >>> (x*y)**2 x**2*y**2 log --- Pull out power of an argument as a coefficient and split logs products into sums of logs. Note that these only work if the arguments of the log function have the proper assumptions--the arguments must be positive and the exponents must be real--or else the ``force`` hint must be True: >>> from sympy import log, symbols >>> log(x**2*y).expand(log=True) log(x**2*y) >>> log(x**2*y).expand(log=True, force=True) 2*log(x) + log(y) >>> x, y = symbols('x,y', positive=True) >>> log(x**2*y).expand(log=True) 2*log(x) + log(y) basic ----- This hint is intended primarily as a way for custom subclasses to enable expansion by default. These hints are not run by default: complex ------- Split an expression into real and imaginary parts. >>> x, y = symbols('x,y') >>> (x + y).expand(complex=True) re(x) + re(y) + I*im(x) + I*im(y) >>> cos(x).expand(complex=True) -I*sin(re(x))*sinh(im(x)) + cos(re(x))*cosh(im(x)) Note that this is just a wrapper around ``as_real_imag()``.  Most objects that wish to redefine ``_eval_expand_complex()`` should consider redefining ``as_real_imag()`` instead. func ---- Expand other functions. >>> from sympy import gamma >>> gamma(x + 1).expand(func=True) x*gamma(x) trig ---- Do trigonometric expansions. >>> cos(x + y).expand(trig=True) -sin(x)*sin(y) + cos(x)*cos(y) >>> sin(2*x).expand(trig=True) 2*sin(x)*cos(x) Note that the forms of ``sin(n*x)`` and ``cos(n*x)`` in terms of ``sin(x)`` and ``cos(x)`` are not unique, due to the identity `\\sin^2(x) + \\cos^2(x) = 1`.  The current implementation uses the form obtained from Chebyshev polynomials, but this may change.  See `this MathWorld article <https://mathworld.wolfram.com/Multiple-AngleFormulas.html>`_ for more information. Notes - You can shut off unwanted methods:: >>> (exp(x + y)*(x + y)).expand() x*exp(x)*exp(y) + y*exp(x)*exp(y) >>> (exp(x + y)*(x + y)).expand(power_exp=False) x*exp(x + y) + y*exp(x + y) >>> (exp(x + y)*(x + y)).expand(mul=False) (x + y)*exp(x)*exp(y) - Use deep=False to only expand on the top level:: >>> exp(x + exp(x + y)).expand() exp(x)*exp(exp(x)*exp(y)) >>> exp(x + exp(x + y)).expand(deep=False) exp(x)*exp(exp(x + y)) - Hints are applied in an arbitrary, but consistent order (in the current implementation, they are applied in alphabetical order, except multinomial comes before mul, but this may change).  Because of this, some hints may prevent expansion by other hints if they are applied first. For example, ``mul`` may distribute multiplications and prevent ``log`` and ``power_base`` from expanding them. Also, if ``mul`` is applied before ``multinomial`, the expression might not be fully distributed. The solution is to use the various ``expand_hint`` helper functions or to use ``hint=False`` to this function to finely control which hints are applied. Here are some examples:: >>> from sympy import expand, expand_mul, expand_power_base >>> x, y, z = symbols('x,y,z', positive=True) >>> expand(log(x*(y + z))) log(x) + log(y + z) Here, we see that ``log`` was applied before ``mul``.  To get the mul expanded form, either of the following will work:: >>> expand_mul(log(x*(y + z))) log(x*y + x*z) >>> expand(log(x*(y + z)), log=False) log(x*y + x*z) A similar thing can happen with the ``power_base`` hint:: >>> expand((x*(y + z))**x) (x*y + x*z)**x To get the ``power_base`` expanded form, either of the following will work:: >>> expand((x*(y + z))**x, mul=False) x**x*(y + z)**x >>> expand_power_base((x*(y + z))**x) x**x*(y + z)**x >>> expand((x + y)*y/x) y + y**2/x The parts of a rational expression can be targeted:: >>> expand((x + y)*y/x/(x + 1), frac=True) (x*y + y**2)/(x**2 + x) >>> expand((x + y)*y/x/(x + 1), numer=True) (x*y + y**2)/(x*(x + 1)) >>> expand((x + y)*y/x/(x + 1), denom=True) y*(x + y)/(x**2 + x) - The ``modulus`` meta-hint can be used to reduce the coefficients of an expression post-expansion:: >>> expand((3*x + 1)**2) 9*x**2 + 6*x + 1 >>> expand((3*x + 1)**2, modulus=5) 4*x**2 + x + 1 - Either ``expand()`` the function or ``.expand()`` the method can be used.  Both are equivalent:: >>> expand((x + 1)**2) x**2 + 2*x + 1 >>> ((x + 1)**2).expand() x**2 + 2*x + 1 API Objects can define their own expand hints by defining ``_eval_expand_hint()``.  The function should take the form:: def _eval_expand_hint(self, **hints): # Only apply the method to the top-level expression ... See also the example below.  Objects should define ``_eval_expand_hint()`` methods only if ``hint`` applies to that specific object.  The generic ``_eval_expand_hint()`` method defined in Expr will handle the no-op case. Each hint should be responsible for expanding that hint only. Furthermore, the expansion should be applied to the top-level expression only.  ``expand()`` takes care of the recursion that happens when ``deep=True``. You should only call ``_eval_expand_hint()`` methods directly if you are 100% sure that the object has the method, as otherwise you are liable to get unexpected ``AttributeError``s.  Note, again, that you do not need to recursively apply the hint to args of your object: this is handled automatically by ``expand()``.  ``_eval_expand_hint()`` should generally not be used at all outside of an ``_eval_expand_hint()`` method. If you want to apply a specific expansion from within another method, use the public ``expand()`` function, method, or ``expand_hint()`` functions. In order for expand to work, objects must be rebuildable by their args, i.e., ``obj.func(*obj.args) == obj`` must hold. Expand methods are passed ``**hints`` so that expand hints may use 'metahints'--hints that control how different expand methods are applied. For example, the ``force=True`` hint described above that causes ``expand(log=True)`` to ignore assumptions is such a metahint.  The ``deep`` meta-hint is handled exclusively by ``expand()`` and is not passed to ``_eval_expand_hint()`` methods. Note that expansion hints should generally be methods that perform some kind of 'expansion'.  For hints that simply rewrite an expression, use the .rewrite() API. Examples >>> from sympy import Expr, sympify >>> class MyClass(Expr): ...     def __new__(cls, *args): ...         args = sympify(args) ...         return Expr.__new__(cls, *args) ... ...     def _eval_expand_double(self, *, force=False, **hints): ...         ''' ...         Doubles the args of MyClass. ... ...         If there more than four args, doubling is not performed, ...         unless force=True is also used (False by default). ...         ''' ...         if not force and len(self.args) > 4: ...             return self ...         return self.func(*(self.args + self.args)) ... >>> a = MyClass(1, 2, MyClass(3, 4)) >>> a MyClass(1, 2, MyClass(3, 4)) >>> a.expand(double=True) MyClass(1, 2, MyClass(3, 4, 3, 4), 1, 2, MyClass(3, 4, 3, 4)) >>> a.expand(double=True, deep=False) MyClass(1, 2, MyClass(3, 4), 1, 2, MyClass(3, 4)) >>> b = MyClass(1, 2, 3, 4, 5) >>> b.expand(double=True) MyClass(1, 2, 3, 4, 5) >>> b.expand(double=True, force=True) MyClass(1, 2, 3, 4, 5, 1, 2, 3, 4, 5) See Also expand_log, expand_mul, expand_multinomial, expand_complex, expand_trig, expand_power_base, expand_power_exp, expand_func, sympy.simplify.hyperexpand.hyperexpand",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "expand",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "e": {
            "type": "string",
            "description": "Parameter e",
            "default": ""
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          },
          "modulus": {
            "type": "string",
            "description": "Parameter modulus",
            "default": ""
          },
          "power_base": {
            "type": "string",
            "description": "Parameter power_base",
            "default": "True"
          },
          "power_exp": {
            "type": "string",
            "description": "Parameter power_exp",
            "default": "True"
          },
          "mul": {
            "type": "string",
            "description": "Parameter mul",
            "default": "True"
          },
          "log": {
            "type": "string",
            "description": "Parameter log",
            "default": "True"
          },
          "multinomial": {
            "type": "string",
            "description": "Parameter multinomial",
            "default": "True"
          },
          "basic": {
            "type": "string",
            "description": "Parameter basic",
            "default": "True"
          },
          "hints": {
            "type": "string",
            "description": "Parameter hints",
            "default": ""
          }
        },
        "required": [
          "e",
          "hints"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-expand_complex": {
      "id": "sympy-sympy-core-function-expand_complex",
      "name": "SymPy expand_complex",
      "description": "Wrapper around expand that only uses the complex hint.  See the expand docstring for more information. Examples >>> from sympy import expand_complex, exp, sqrt, I >>> from sympy.abc import z >>> expand_complex(exp(z)) I*exp(re(z))*sin(im(z)) + exp(re(z))*cos(im(z)) >>> expand_complex(sqrt(I)) sqrt(2)/2 + sqrt(2)*I/2 See Also sympy.core.expr.Expr.as_real_imag",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "expand_complex",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-expand_func": {
      "id": "sympy-sympy-core-function-expand_func",
      "name": "SymPy expand_func",
      "description": "Wrapper around expand that only uses the func hint.  See the expand docstring for more information. Examples >>> from sympy import expand_func, gamma >>> from sympy.abc import x >>> expand_func(gamma(x + 2)) x*(x + 1)*gamma(x)",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "expand_func",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-expand_log": {
      "id": "sympy-sympy-core-function-expand_log",
      "name": "SymPy expand_log",
      "description": "Wrapper around expand that only uses the log hint.  See the expand docstring for more information. Examples >>> from sympy import symbols, expand_log, exp, log >>> x, y = symbols('x,y', positive=True) >>> expand_log(exp(x+y)*(x+y)*log(x*y**2)) (x + y)*(log(x) + 2*log(y))*exp(x + y)",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "expand_log",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          },
          "force": {
            "type": "string",
            "description": "Parameter force",
            "default": "False"
          },
          "factor": {
            "type": "string",
            "description": "Parameter factor",
            "default": "False"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-expand_mul": {
      "id": "sympy-sympy-core-function-expand_mul",
      "name": "SymPy expand_mul",
      "description": "Wrapper around expand that only uses the mul hint.  See the expand docstring for more information. Examples >>> from sympy import symbols, expand_mul, exp, log >>> x, y = symbols('x,y', positive=True) >>> expand_mul(exp(x+y)*(x+y)*log(x*y**2)) x*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2)",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "expand_mul",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-expand_multinomial": {
      "id": "sympy-sympy-core-function-expand_multinomial",
      "name": "SymPy expand_multinomial",
      "description": "Wrapper around expand that only uses the multinomial hint.  See the expand docstring for more information. Examples >>> from sympy import symbols, expand_multinomial, exp >>> x, y = symbols('x y', positive=True) >>> expand_multinomial((x + exp(x + 1))**2) x**2 + 2*x*exp(x + 1) + exp(2*x + 2)",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "expand_multinomial",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-expand_power_base": {
      "id": "sympy-sympy-core-function-expand_power_base",
      "name": "SymPy expand_power_base",
      "description": "Wrapper around expand that only uses the power_base hint. A wrapper to expand(power_base=True) which separates a power with a base that is a Mul into a product of powers, without performing any other expansions, provided that assumptions about the power's base and exponent allow. deep=False (default is True) will only apply to the top-level expression. force=True (default is False) will cause the expansion to ignore assumptions about the base and exponent. When False, the expansion will only happen if the base is non-negative or the exponent is an integer. >>> from sympy.abc import x, y, z >>> from sympy import expand_power_base, sin, cos, exp, Symbol >>> (x*y)**2 x**2*y**2 >>> (2*x)**y (2*x)**y >>> expand_power_base(_) 2**y*x**y >>> expand_power_base((x*y)**z) (x*y)**z >>> expand_power_base((x*y)**z, force=True) x**z*y**z >>> expand_power_base(sin((x*y)**z), deep=False) sin((x*y)**z) >>> expand_power_base(sin((x*y)**z), force=True) sin(x**z*y**z) >>> expand_power_base((2*sin(x))**y + (2*cos(x))**y) 2**y*sin(x)**y + 2**y*cos(x)**y >>> expand_power_base((2*exp(y))**x) 2**x*exp(y)**x >>> expand_power_base((2*cos(x))**y) 2**y*cos(x)**y Notice that sums are left untouched. If this is not the desired behavior, apply full ``expand()`` to the expression: >>> expand_power_base(((x+y)*z)**2) z**2*(x + y)**2 >>> (((x+y)*z)**2).expand() x**2*z**2 + 2*x*y*z**2 + y**2*z**2 >>> expand_power_base((2*y)**(1+z)) 2**(z + 1)*y**(z + 1) >>> ((2*y)**(1+z)).expand() 2*2**z*y**(z + 1) The power that is unexpanded can be expanded safely when ``y != 0``, otherwise different values might be obtained for the expression: >>> prev = _ If we indicate that ``y`` is positive but then replace it with a value of 0 after expansion, the expression becomes 0: >>> p = Symbol('p', positive=True) >>> prev.subs(y, p).expand().subs(p, 0) 0 But if ``z = -1`` the expression would not be zero: >>> prev.subs(y, 0).subs(z, -1) 1 See Also expand",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "expand_power_base",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          },
          "force": {
            "type": "string",
            "description": "Parameter force",
            "default": "False"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-expand_power_exp": {
      "id": "sympy-sympy-core-function-expand_power_exp",
      "name": "SymPy expand_power_exp",
      "description": "Wrapper around expand that only uses the power_exp hint. See the expand docstring for more information. Examples >>> from sympy import expand_power_exp, Symbol >>> from sympy.abc import x, y >>> expand_power_exp(3**(y + 2)) 9*3**y >>> expand_power_exp(x**(y + 2)) x**(y + 2) If ``x = 0`` the value of the expression depends on the value of ``y``; if the expression were expanded the result would be 0. So expansion is only done if ``x != 0``: >>> expand_power_exp(Symbol('x', zero=False)**(y + 2)) x**2*x**y",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "expand_power_exp",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-expand_trig": {
      "id": "sympy-sympy-core-function-expand_trig",
      "name": "SymPy expand_trig",
      "description": "Wrapper around expand that only uses the trig hint.  See the expand docstring for more information. Examples >>> from sympy import expand_trig, sin >>> from sympy.abc import x, y >>> expand_trig(sin(x+y)*(x+y)) (x + y)*(sin(x)*cos(y) + sin(y)*cos(x))",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "expand_trig",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-core-function-nfloat": {
      "id": "sympy-sympy-core-function-nfloat",
      "name": "SymPy nfloat",
      "description": "Make all Rationals in expr Floats except those in exponents (unless the exponents flag is set to True) and those in undefined functions. When processing dictionaries, do not modify the keys unless ``dkeys=True``. Examples >>> from sympy import nfloat, cos, pi, sqrt >>> from sympy.abc import x, y >>> nfloat(x**4 + x/2 + cos(pi/3) + 1 + sqrt(y)) x**4 + 0.5*x + sqrt(y) + 1.5 >>> nfloat(x**4 + sqrt(y), exponent=True) x**4.0 + y**0.5 Container types are not modified: >>> type(nfloat((1, 2))) is tuple True",
      "category": "sympy",
      "module": "sympy.core.function",
      "function": "nfloat",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "n": {
            "type": "string",
            "description": "Parameter n",
            "default": "15"
          },
          "exponent": {
            "type": "string",
            "description": "Parameter exponent",
            "default": "False"
          },
          "dkeys": {
            "type": "string",
            "description": "Parameter dkeys",
            "default": "False"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-functions-elementary-exponential-match_real_imag": {
      "id": "sympy-sympy-functions-elementary-exponential-match_real_imag",
      "name": "SymPy match_real_imag",
      "description": "Try to match expr with $a + Ib$ for real $a$ and $b$. ``match_real_imag`` returns a tuple containing the real and imaginary parts of expr or ``(None, None)`` if direct matching is not possible. Contrary to :func:`~.re`, :func:`~.im``, and ``as_real_imag()``, this helper will not force things by returning expressions themselves containing ``re()`` or ``im()`` and it does not expand its argument either.",
      "category": "sympy",
      "module": "sympy.functions.elementary.exponential",
      "function": "match_real_imag",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-functions-elementary-miscellaneous-cbrt": {
      "id": "sympy-sympy-functions-elementary-miscellaneous-cbrt",
      "name": "SymPy cbrt",
      "description": "Returns the principal cube root.",
      "category": "sympy",
      "module": "sympy.functions.elementary.miscellaneous",
      "function": "cbrt",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "arg": {
            "type": "string",
            "description": "Parameter arg",
            "default": ""
          },
          "evaluate": {
            "type": "boolean",
            "description": "The parameter determines if the expression should be evaluated. If ``None``, its value is taken from ``global_parameters.evaluate``.",
            "default": false
          }
        },
        "required": [
          "arg"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-functions-elementary-miscellaneous-real_root": {
      "id": "sympy-sympy-functions-elementary-miscellaneous-real_root",
      "name": "SymPy real_root",
      "description": "Return the real *n*'th-root of *arg* if possible.",
      "category": "sympy",
      "module": "sympy.functions.elementary.miscellaneous",
      "function": "real_root",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "arg": {
            "type": "string",
            "description": "Parameter arg",
            "default": ""
          },
          "n": {
            "type": "integer",
            "description": "If *n* is ``None``, then all instances of $(-n)^{1/\\text{odd}}$ will be changed to $-n^{1/\\text{odd}}$. This will only create a real root of a principal root. The presence of other factors may cause the result to not be real."
          },
          "evaluate": {
            "type": "boolean",
            "description": "The parameter determines if the expression should be evaluated. If ``None``, its value is taken from ``global_parameters.evaluate``.",
            "default": false
          }
        },
        "required": [
          "arg"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-functions-elementary-miscellaneous-root": {
      "id": "sympy-sympy-functions-elementary-miscellaneous-root",
      "name": "SymPy root",
      "description": "Returns the *k*-th *n*-th root of ``arg``.",
      "category": "sympy",
      "module": "sympy.functions.elementary.miscellaneous",
      "function": "root",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "arg": {
            "type": "string",
            "description": "Parameter arg",
            "default": ""
          },
          "n": {
            "type": "string",
            "description": "Parameter n",
            "default": ""
          },
          "k": {
            "type": "integer",
            "description": "Should be an integer in $\\{0, 1, ..., n-1\\}$. Defaults to the principal root if $0$."
          },
          "evaluate": {
            "type": "boolean",
            "description": "The parameter determines if the expression should be evaluated. If ``None``, its value is taken from ``global_parameters.evaluate``.",
            "default": false
          }
        },
        "required": [
          "arg",
          "n"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-functions-elementary-miscellaneous-sqrt": {
      "id": "sympy-sympy-functions-elementary-miscellaneous-sqrt",
      "name": "SymPy sqrt",
      "description": "Returns the principal square root.",
      "category": "sympy",
      "module": "sympy.functions.elementary.miscellaneous",
      "function": "sqrt",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "arg": {
            "type": "string",
            "description": "Parameter arg",
            "default": ""
          },
          "evaluate": {
            "type": "boolean",
            "description": "The parameter determines if the expression should be evaluated. If ``None``, its value is taken from ``global_parameters.evaluate``.",
            "default": false
          }
        },
        "required": [
          "arg"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-functions-special-gamma_functions-intlike": {
      "id": "sympy-sympy-functions-special-gamma_functions-intlike",
      "name": "SymPy intlike",
      "description": "SymPy intlike function",
      "category": "sympy",
      "module": "sympy.functions.special.gamma_functions",
      "function": "intlike",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "n": {
            "type": "string",
            "description": "Parameter n",
            "default": ""
          }
        },
        "required": [
          "n"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-functions-special-bessel-assume_integer_order": {
      "id": "sympy-sympy-functions-special-bessel-assume_integer_order",
      "name": "SymPy assume_integer_order",
      "description": "SymPy assume_integer_order function",
      "category": "sympy",
      "module": "sympy.functions.special.bessel",
      "function": "assume_integer_order",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "fn": {
            "type": "string",
            "description": "Parameter fn",
            "default": ""
          }
        },
        "required": [
          "fn"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-functions-special-bessel-jn_zeros": {
      "id": "sympy-sympy-functions-special-bessel-jn_zeros",
      "name": "SymPy jn_zeros",
      "description": "Zeros of the spherical Bessel function of the first kind. Explanation This returns an array of zeros of $jn$ up to the $k$-th zero. * method = \"sympy\": uses `mpmath.besseljzero <https://mpmath.org/doc/current/functions/bessel.html#mpmath.besseljzero>`_ * method = \"scipy\": uses the `SciPy's sph_jn <https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jn_zeros.html>`_ and `newton <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html>`_ to find all roots, which is faster than computing the zeros using a general numerical solver, but it requires SciPy and only works with low precision floating point numbers. (The function used with method=\"sympy\" is a recent addition to mpmath; before that a general solver was used.) Examples >>> from sympy import jn_zeros >>> jn_zeros(2, 4, dps=5) [5.7635, 9.095, 12.323, 15.515] See Also jn, yn, besselj, besselk, bessely",
      "category": "sympy",
      "module": "sympy.functions.special.bessel",
      "function": "jn_zeros",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "n": {
            "type": "string",
            "description": "Parameter n",
            "default": ""
          },
          "k": {
            "type": "string",
            "description": "Parameter k",
            "default": ""
          },
          "method": {
            "type": "string",
            "description": "Parameter method",
            "default": "sympy"
          },
          "dps": {
            "type": "string",
            "description": "Parameter dps",
            "default": "15"
          }
        },
        "required": [
          "n",
          "k"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-besselsimp": {
      "id": "sympy-sympy-simplify-simplify-besselsimp",
      "name": "SymPy besselsimp",
      "description": "Simplify bessel-type functions. Explanation This routine tries to simplify bessel-type functions. Currently it only works on the Bessel J and I functions, however. It works by looking at all such functions in turn, and eliminating factors of \"I\" and \"-1\" (actually their polar equivalents) in front of the argument. Then, functions of half-integer order are rewritten using trigonometric functions and functions of integer order (> 1) are rewritten using functions of low order.  Finally, if the expression was changed, compute factorization of the result with factor(). >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S >>> from sympy.abc import z, nu >>> besselsimp(besselj(nu, z*polar_lift(-1))) exp(I*pi*nu)*besselj(nu, z) >>> besselsimp(besseli(nu, z*polar_lift(-I))) exp(-I*pi*nu/2)*besselj(nu, z) >>> besselsimp(besseli(S(-1)/2, z)) sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z)) >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z)) 3*z*besseli(0, z)/2",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "besselsimp",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-clear_coefficients": {
      "id": "sympy-sympy-simplify-simplify-clear_coefficients",
      "name": "SymPy clear_coefficients",
      "description": "Return `p, r` where `p` is the expression obtained when Rational additive and multiplicative coefficients of `expr` have been stripped away in a naive fashion (i.e. without simplification). The operations needed to remove the coefficients will be applied to `rhs` and returned as `r`. Examples >>> from sympy.simplify.simplify import clear_coefficients >>> from sympy.abc import x, y >>> from sympy import Dummy >>> expr = 4*y*(6*x + 3) >>> clear_coefficients(expr - 2) (y*(2*x + 1), 1/6) When solving 2 or more expressions like `expr = a`, `expr = b`, etc..., it is advantageous to provide a Dummy symbol for `rhs` and  simply replace it with `a`, `b`, etc... in `r`. >>> rhs = Dummy('rhs') >>> clear_coefficients(expr, rhs) (y*(2*x + 1), _rhs/12) >>> _[1].subs(rhs, 2) 1/6",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "clear_coefficients",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "rhs": {
            "type": "string",
            "description": "Parameter rhs",
            "default": "0"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-dotprodsimp": {
      "id": "sympy-sympy-simplify-simplify-dotprodsimp",
      "name": "SymPy dotprodsimp",
      "description": "Simplification for a sum of products targeted at the kind of blowup that occurs during summation of products. Intended to reduce expression blowup during matrix multiplication or other similar operations. Only works with algebraic expressions and does not recurse into non.",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "dotprodsimp",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "withsimp": {
            "type": "boolean",
            "description": "Specifies whether a flag should be returned along with the expression to indicate roughly whether simplification was successful. It is used in ``MatrixArithmetic._eval_pow_by_recursion`` to avoid attempting to simplify an expression repetitively which does not simplify.",
            "default": false
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-factor_sum": {
      "id": "sympy-sympy-simplify-simplify-factor_sum",
      "name": "SymPy factor_sum",
      "description": "Return Sum with constant factors extracted. If ``limits`` is specified then ``self`` is the summand; the other keywords are passed to ``factor_terms``. Examples >>> from sympy import Sum >>> from sympy.abc import x, y >>> from sympy.simplify.simplify import factor_sum >>> s = Sum(x*y, (x, 1, 3)) >>> factor_sum(s) y*Sum(x, (x, 1, 3)) >>> factor_sum(s.function, s.limits) y*Sum(x, (x, 1, 3))",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "factor_sum",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "self": {
            "type": "string",
            "description": "Parameter self",
            "default": ""
          },
          "limits": {
            "type": "string",
            "description": "Parameter limits",
            "default": ""
          },
          "radical": {
            "type": "string",
            "description": "Parameter radical",
            "default": "False"
          },
          "clear": {
            "type": "string",
            "description": "Parameter clear",
            "default": "False"
          },
          "fraction": {
            "type": "string",
            "description": "Parameter fraction",
            "default": "False"
          },
          "sign": {
            "type": "string",
            "description": "Parameter sign",
            "default": "True"
          }
        },
        "required": [
          "self"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-hypersimilar": {
      "id": "sympy-sympy-simplify-simplify-hypersimilar",
      "name": "SymPy hypersimilar",
      "description": "Returns True if ``f`` and ``g`` are hyper-similar. Explanation Similarity in hypergeometric sense means that a quotient of f(k) and g(k) is a rational function in ``k``. This procedure is useful in solving recurrence relations. For more information see hypersimp().",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "hypersimilar",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "Parameter f",
            "default": "x**2 + y**2"
          },
          "g": {
            "type": "string",
            "description": "Parameter g",
            "default": ""
          },
          "k": {
            "type": "string",
            "description": "Parameter k",
            "default": ""
          }
        },
        "required": [
          "f",
          "g",
          "k"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-hypersimp": {
      "id": "sympy-sympy-simplify-simplify-hypersimp",
      "name": "SymPy hypersimp",
      "description": "Given combinatorial term f(k) simplify its consecutive term ratio i.e. f(k+1)/f(k).  The input term can be composed of functions and integer sequences which have equivalent representation in terms of gamma special function. Explanation The algorithm performs three basic steps: 1. Rewrite all functions in terms of gamma, if possible. 2. Rewrite all occurrences of gamma in terms of products of gamma and rising factorial with integer,  absolute constant exponent. 3. Perform simplification of nested fractions, powers and if the resulting expression is a quotient of polynomials, reduce their total degree. If f(k) is hypergeometric then as result we arrive with a quotient of polynomials of minimal degree. Otherwise None is returned. For more information on the implemented algorithm refer to: 1. W. Koepf, Algorithms for m-fold Hypergeometric Summation, Journal of Symbolic Computation (1995) 20, 399-417",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "hypersimp",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "description": "Parameter f",
            "default": "x**2 + y**2"
          },
          "k": {
            "type": "string",
            "description": "Parameter k",
            "default": ""
          }
        },
        "required": [
          "f",
          "k"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-inversecombine": {
      "id": "sympy-sympy-simplify-simplify-inversecombine",
      "name": "SymPy inversecombine",
      "description": "Simplify the composition of a function and its inverse. Explanation No attention is paid to whether the inverse is a left inverse or a right inverse; thus, the result will in general not be equivalent to the original expression. Examples >>> from sympy.simplify.simplify import inversecombine >>> from sympy import asin, sin, log, exp >>> from sympy.abc import x >>> inversecombine(asin(sin(x))) x >>> inversecombine(2*log(exp(3*x))) 6*x",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "inversecombine",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-kroneckersimp": {
      "id": "sympy-sympy-simplify-simplify-kroneckersimp",
      "name": "SymPy kroneckersimp",
      "description": "Simplify expressions with KroneckerDelta. The only simplification currently attempted is to identify multiplicative cancellation: Examples >>> from sympy import KroneckerDelta, kroneckersimp >>> from sympy.abc import i >>> kroneckersimp(1 + KroneckerDelta(0, i) * KroneckerDelta(1, i)) 1",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "kroneckersimp",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-logcombine": {
      "id": "sympy-sympy-simplify-simplify-logcombine",
      "name": "SymPy logcombine",
      "description": "Takes logarithms and combines them using the following rules: - log(x) + log(y) == log(x*y) if both are positive - a*log(x) == log(x**a) if x is positive and a is real If ``force`` is ``True`` then the assumptions above will be assumed to hold if there is no assumption already in place on a quantity. For example, if ``a`` is imaginary or the argument negative, force will not perform a combination but if ``a`` is a symbol with no assumptions the change will take place. Examples >>> from sympy import Symbol, symbols, log, logcombine, I >>> from sympy.abc import a, x, y, z >>> logcombine(a*log(x) + log(y) - log(z)) a*log(x) + log(y) - log(z) >>> logcombine(a*log(x) + log(y) - log(z), force=True) log(x**a*y/z) >>> x,y,z = symbols('x,y,z', positive=True) >>> a = Symbol('a', real=True) >>> logcombine(a*log(x) + log(y) - log(z)) log(x**a*y/z) The transformation is limited to factors and/or terms that contain logs, so the result depends on the initial state of expansion: >>> eq = (2 + 3*I)*log(x) >>> logcombine(eq, force=True) == eq True >>> logcombine(eq.expand(), force=True) log(x**2) + I*log(x**3) See Also posify: replace all symbols with symbols having positive assumptions sympy.core.function.expand_log: expand the logarithms of products and powers; the opposite of logcombine",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "logcombine",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "force": {
            "type": "string",
            "description": "Parameter force",
            "default": "False"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-nc_simplify": {
      "id": "sympy-sympy-simplify-simplify-nc_simplify",
      "name": "SymPy nc_simplify",
      "description": "Simplify a non-commutative expression composed of multiplication and raising to a power by grouping repeated subterms into one power. Priority is given to simplifications that give the fewest number of arguments in the end (for example, in a*b*a*b*c*a*b*c simplifying to (a*b)**2*c*a*b*c gives 5 arguments while a*b*(a*b*c)**2 has 3). If ``expr`` is a sum of such terms, the sum of the simplified terms is returned. Keyword argument ``deep`` controls whether or not subexpressions nested deeper inside the main expression are simplified. See examples below. Setting `deep` to `False` can save time on nested expressions that do not need simplifying on all levels. Examples >>> from sympy import symbols >>> from sympy.simplify.simplify import nc_simplify >>> a, b, c = symbols(\"a b c\", commutative=False) >>> nc_simplify(a*b*a*b*c*a*b*c) a*b*(a*b*c)**2 >>> expr = a**2*b*a**4*b*a**4 >>> nc_simplify(expr) a**2*(b*a**4)**2 >>> nc_simplify(a*b*a*b*c**2*(a*b)**2*c**2) ((a*b)**2*c**2)**2 >>> nc_simplify(a*b*a*b + 2*a*c*a**2*c*a**2*c*a) (a*b)**2 + 2*(a*c*a)**3 >>> nc_simplify(b**-1*a**-1*(a*b)**2) a*b >>> nc_simplify(a**-1*b**-1*c*a) (b*a)**(-1)*c*a >>> expr = (a*b*a*b)**2*a*c*a*c >>> nc_simplify(expr) (a*b)**4*(a*c)**2 >>> nc_simplify(expr, deep=False) (a*b*a*b)**2*(a*c)**2",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "nc_simplify",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "deep": {
            "type": "string",
            "description": "Parameter deep",
            "default": "True"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-nsimplify": {
      "id": "sympy-sympy-simplify-simplify-nsimplify",
      "name": "SymPy nsimplify",
      "description": "Find a simple representation for a number or, if there are free symbols or if ``rational=True``, then replace Floats with their Rational equivalents. If no change is made and rational is not False then Floats will at least be converted to Rationals. Explanation For numerical expressions, a simple formula that numerically matches the given numerical expression is sought (and the input should be possible to evalf to a precision of at least 30 digits). Optionally, a list of (rationally independent) constants to include in the formula may be given. A lower tolerance may be set to find less exact matches. If no tolerance is given then the least precise value will set the tolerance (e.g. Floats default to 15 digits of precision, so would be tolerance=10**-15). With ``full=True``, a more extensive search is performed (this is useful to find simpler numbers when the tolerance is set low). When converting to rational, if rational_conversion='base10' (the default), then convert floats to rationals using their base-10 (string) representation. When rational_conversion='exact' it uses the exact, base-2 representation. Examples >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, pi >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio]) -2 + 2*GoldenRatio >>> nsimplify((1/(exp(3*pi*I/5)+1))) 1/2 - I*sqrt(sqrt(5)/10 + 1/4) >>> nsimplify(I**I, [pi]) exp(-pi/2) >>> nsimplify(pi, tolerance=0.01) 22/7 >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact') 6004799503160655/18014398509481984 >>> nsimplify(0.333333333333333, rational=True) 1/3 See Also sympy.core.function.nfloat",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "nsimplify",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "constants": {
            "type": "string",
            "description": "Parameter constants",
            "default": "()"
          },
          "tolerance": {
            "type": "string",
            "description": "Parameter tolerance",
            "default": ""
          },
          "full": {
            "type": "string",
            "description": "Parameter full",
            "default": "False"
          },
          "rational": {
            "type": "string",
            "description": "Parameter rational",
            "default": ""
          },
          "rational_conversion": {
            "type": "string",
            "description": "Parameter rational_conversion",
            "default": "base10"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-nthroot": {
      "id": "sympy-sympy-simplify-simplify-nthroot",
      "name": "SymPy nthroot",
      "description": "Compute a real nth-root of a sum of surds.",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "nthroot",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "n": {
            "type": "integer",
            "description": "Parameter n"
          },
          "max_len": {
            "type": "number",
            "description": "Parameter max_len"
          },
          "prec": {
            "type": "string",
            "description": "Parameter prec",
            "default": "15"
          }
        },
        "required": [
          "expr",
          "n"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-posify": {
      "id": "sympy-sympy-simplify-simplify-posify",
      "name": "SymPy posify",
      "description": "Return ``eq`` (with generic symbols made positive) and a dictionary containing the mapping between the old and new symbols. Explanation Any symbol that has positive=None will be replaced with a positive dummy symbol having the same name. This replacement will allow more symbolic processing of expressions, especially those involving powers and logarithms. A dictionary that can be sent to subs to restore ``eq`` to its original symbols is also returned. >>> from sympy import posify, Symbol, log, solve >>> from sympy.abc import x >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True)) (_x + n + p, {_x: x}) >>> eq = 1/x >>> log(eq).expand() log(1/x) >>> log(posify(eq)[0]).expand() -log(_x) >>> p, rep = posify(eq) >>> log(p).expand().subs(rep) -log(x) It is possible to apply the same transformations to an iterable of expressions: >>> eq = x**2 - 4 >>> solve(eq, x) [-2, 2] >>> eq_x, reps = posify([eq, x]); eq_x [_x**2 - 4, _x] >>> solve(*eq_x) [2]",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "posify",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "eq": {
            "type": "string",
            "description": "Parameter eq",
            "default": ""
          }
        },
        "required": [
          "eq"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-product_mul": {
      "id": "sympy-sympy-simplify-simplify-product_mul",
      "name": "SymPy product_mul",
      "description": "Helper function for Product simplification",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "product_mul",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "self": {
            "type": "string",
            "description": "Parameter self",
            "default": ""
          },
          "other": {
            "type": "string",
            "description": "Parameter other",
            "default": ""
          },
          "method": {
            "type": "string",
            "description": "Parameter method",
            "default": "0"
          }
        },
        "required": [
          "self",
          "other"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-product_simplify": {
      "id": "sympy-sympy-simplify-simplify-product_simplify",
      "name": "SymPy product_simplify",
      "description": "Main function for Product simplification",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "product_simplify",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "s": {
            "type": "string",
            "description": "Parameter s",
            "default": ""
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "s",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-separatevars": {
      "id": "sympy-sympy-simplify-simplify-separatevars",
      "name": "SymPy separatevars",
      "description": "Separates variables in an expression, if possible.  By default, it separates with respect to all symbols in an expression and collects constant coefficients that are independent of symbols. Explanation If ``dict=True`` then the separated terms will be returned in a dictionary keyed to their corresponding symbols. By default, all symbols in the expression will appear as keys; if symbols are provided, then all those symbols will be used as keys, and any terms in the expression containing other symbols or non-symbols will be returned keyed to the string 'coeff'. (Passing None for symbols will return the expression in a dictionary keyed to 'coeff'.) If ``force=True``, then bases of powers will be separated regardless of assumptions on the symbols involved. Notes The order of the factors is determined by Mul, so that the separated expressions may not necessarily be grouped together. Although factoring is necessary to separate variables in some expressions, it is not necessary in all cases, so one should not count on the returned factors being factored. Examples >>> from sympy.abc import x, y, z, alpha >>> from sympy import separatevars, sin >>> separatevars((x*y)**y) (x*y)**y >>> separatevars((x*y)**y, force=True) x**y*y**y >>> e = 2*x**2*z*sin(y)+2*z*x**2 >>> separatevars(e) 2*x**2*z*(sin(y) + 1) >>> separatevars(e, symbols=(x, y), dict=True) {'coeff': 2*z, x: x**2, y: sin(y) + 1} >>> separatevars(e, [x, y, alpha], dict=True) {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1} If the expression is not really separable, or is only partially separable, separatevars will do the best it can to separate it by using factoring. >>> separatevars(x + x*y - 3*x**2) -x*(3*x - y - 1) If the expression is not separable then expr is returned unchanged or (if dict=True) then None is returned. >>> eq = 2*x + y*sin(x) >>> separatevars(eq) == eq True >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) is None True",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "separatevars",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "symbols": {
            "type": "string",
            "description": "Parameter symbols",
            "default": "[]"
          },
          "dict": {
            "type": "string",
            "description": "Parameter dict",
            "default": "False"
          },
          "force": {
            "type": "string",
            "description": "Parameter force",
            "default": "False"
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-signsimp": {
      "id": "sympy-sympy-simplify-simplify-signsimp",
      "name": "SymPy signsimp",
      "description": "Make all Add sub-expressions canonical wrt sign. Explanation If an Add subexpression, ``a``, can have a sign extracted, as determined by could_extract_minus_sign, it is replaced with Mul(-1, a, evaluate=False). This allows signs to be extracted from powers and products. Examples >>> from sympy import signsimp, exp, symbols >>> from sympy.abc import x, y >>> i = symbols('i', odd=True) >>> n = -1 + 1/x >>> n/x/(-n)**2 - 1/n/x (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x)) >>> signsimp(_) 0 >>> x*n + x*-n x*(-1 + 1/x) + x*(1 - 1/x) >>> signsimp(_) 0 Since powers automatically handle leading signs >>> (-2)**i -2**i signsimp can be used to put the base of a power with an integer exponent into canonical form: >>> n**i (-1 + 1/x)**i By default, signsimp does not leave behind any hollow simplification: if making an Add canonical wrt sign didn't change the expression, the original Add is restored. If this is not desired then the keyword ``evaluate`` can be set to False: >>> e = exp(y - x) >>> signsimp(e) == e True >>> signsimp(e, evaluate=False) exp(-(x - y))",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "signsimp",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "evaluate": {
            "type": "string",
            "description": "Parameter evaluate",
            "default": ""
          }
        },
        "required": [
          "expr"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-simplify": {
      "id": "sympy-sympy-simplify-simplify-simplify",
      "name": "SymPy simplify",
      "description": "Simplifies the given expression. Explanation Simplification is not a well defined term and the exact strategies this function tries can change in the future versions of SymPy. If your algorithm relies on \"simplification\" (whatever it is), try to determine what you need exactly  -  is it powsimp()?, radsimp()?, together()?, logcombine()?, or something else? And use this particular function directly, because those are well defined and thus your algorithm will be robust. Nonetheless, especially for interactive use, or when you do not know anything about the structure of the expression, simplify() tries to apply intelligent heuristics to make the input expression \"simpler\".  For example: >>> from sympy import simplify, cos, sin >>> from sympy.abc import x, y >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2) >>> a (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2) >>> simplify(a) x + 1 Note that we could have obtained the same result by using specific simplification functions: >>> from sympy import trigsimp, cancel >>> trigsimp(a) (x**2 + x)/x >>> cancel(_) x + 1 In some cases, applying :func:`simplify` may actually result in some more complicated expression. The default ``ratio=1.7`` prevents more extreme cases: if (result length)/(input length) > ratio, then input is returned unmodified.  The ``measure`` parameter lets you specify the function used to determine how complex an expression is.  The function should take a single argument as an expression and return a number such that if expression ``a`` is more complex than expression ``b``, then ``measure(a) > measure(b)``.  The default measure function is :func:`~.count_ops`, which returns the total number of operations in the expression. For example, if ``ratio=1``, ``simplify`` output cannot be longer than input. :: >>> from sympy import sqrt, simplify, count_ops, oo >>> root = 1/(sqrt(2)+3) Since ``simplify(root)`` would result in a slightly longer expression, root is returned unchanged instead:: >>> simplify(root, ratio=1) == root True If ``ratio=oo``, simplify will be applied anyway:: >>> count_ops(simplify(root, ratio=oo)) > count_ops(root) True Note that the shortest expression is not necessary the simplest, so setting ``ratio`` to 1 may not be a good idea. Heuristically, the default value ``ratio=1.7`` seems like a reasonable choice. You can easily define your own measure function based on what you feel should represent the \"size\" or \"complexity\" of the input expression.  Note that some choices, such as ``lambda expr: len(str(expr))`` may appear to be good metrics, but have other problems (in this case, the measure function may slow down simplify too much for very large expressions).  If you do not know what a good metric would be, the default, ``count_ops``, is a good one. For example: >>> from sympy import symbols, log >>> a, b = symbols('a b', positive=True) >>> g = log(a) + log(b) + log(a)*log(1/b) >>> h = simplify(g) >>> h log(a*b**(1 - log(a))) >>> count_ops(g) 8 >>> count_ops(h) 5 So you can see that ``h`` is simpler than ``g`` using the count_ops metric. However, we may not like how ``simplify`` (in this case, using ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way to reduce this would be to give more weight to powers as operations in ``count_ops``.  We can do this by using the ``visual=True`` option: >>> print(count_ops(g, visual=True)) 2*ADD + DIV + 4*LOG + MUL >>> print(count_ops(h, visual=True)) 2*LOG + MUL + POW + SUB >>> from sympy import Symbol, S >>> def my_measure(expr): ...     POW = Symbol('POW') ...     # Discourage powers by giving POW a weight of 10 ...     count = count_ops(expr, visual=True).subs(POW, 10) ...     # Every other operation gets a weight of 1 (the default) ...     count = count.replace(Symbol, type(S.One)) ...     return count >>> my_measure(g) 8 >>> my_measure(h) 14 >>> 15./8 > 1.7 # 1.7 is the default ratio True >>> simplify(g, measure=my_measure) -log(a)*log(b) + log(a) + log(b) Note that because ``simplify()`` internally tries many different simplification strategies and then compares them using the measure function, we get a completely different result that is still different from the input expression by doing this. If ``rational=True``, Floats will be recast as Rationals before simplification. If ``rational=None``, Floats will be recast as Rationals but the result will be recast as Floats. If rational=False(default) then nothing will be done to the Floats. If ``inverse=True``, it will be assumed that a composition of inverse functions, such as sin and asin, can be cancelled in any order. For example, ``asin(sin(x))`` will yield ``x`` without checking whether x belongs to the set where this relation is true. The default is False. Note that ``simplify()`` automatically calls ``doit()`` on the final expression. You can avoid this behavior by passing ``doit=False`` as an argument. Also, it should be noted that simplifying a boolean expression is not well defined. If the expression prefers automatic evaluation (such as :obj:`~.Eq()` or :obj:`~.Or()`), simplification will return ``True`` or ``False`` if truth value can be determined. If the expression is not evaluated by default (such as :obj:`~.Predicate()`), simplification will not reduce it and you should use :func:`~.refine` or :func:`~.ask` function. This inconsistency will be resolved in future version. See Also sympy.assumptions.refine.refine : Simplification using assumptions. sympy.assumptions.ask.ask : Query for boolean expressions using assumptions.",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "simplify",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "expr": {
            "type": "string",
            "description": "Parameter expr",
            "default": "x**2 + y**2"
          },
          "ratio": {
            "type": "string",
            "description": "Parameter ratio",
            "default": "1.7"
          },
          "measure": {
            "type": "string",
            "description": "Parameter measure",
            "default": "<function count_ops at 0x7fb8d1d88fe0>"
          },
          "rational": {
            "type": "string",
            "description": "Parameter rational",
            "default": "False"
          },
          "inverse": {
            "type": "string",
            "description": "Parameter inverse",
            "default": "False"
          },
          "doit": {
            "type": "string",
            "description": "Parameter doit",
            "default": "True"
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "expr",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-sum_add": {
      "id": "sympy-sympy-simplify-simplify-sum_add",
      "name": "SymPy sum_add",
      "description": "Helper function for Sum simplification",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "sum_add",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "self": {
            "type": "string",
            "description": "Parameter self",
            "default": ""
          },
          "other": {
            "type": "string",
            "description": "Parameter other",
            "default": ""
          },
          "method": {
            "type": "string",
            "description": "Parameter method",
            "default": "0"
          }
        },
        "required": [
          "self",
          "other"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-sum_combine": {
      "id": "sympy-sympy-simplify-simplify-sum_combine",
      "name": "SymPy sum_combine",
      "description": "Helper function for Sum simplification Attempts to simplify a list of sums, by combining limits / sum function's returns the simplified sum",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "sum_combine",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "s_t": {
            "type": "string",
            "description": "Parameter s_t",
            "default": ""
          }
        },
        "required": [
          "s_t"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-simplify-simplify-sum_simplify": {
      "id": "sympy-sympy-simplify-simplify-sum_simplify",
      "name": "SymPy sum_simplify",
      "description": "Main function for Sum simplification",
      "category": "sympy",
      "module": "sympy.simplify.simplify",
      "function": "sum_simplify",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "s": {
            "type": "string",
            "description": "Parameter s",
            "default": ""
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "s",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-matrices-common-a2idx": {
      "id": "sympy-sympy-matrices-common-a2idx",
      "name": "SymPy a2idx",
      "description": "Return integer after making positive and validating against n.",
      "category": "sympy",
      "module": "sympy.matrices.common",
      "function": "a2idx",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "j": {
            "type": "string",
            "description": "Parameter j",
            "default": ""
          },
          "n": {
            "type": "string",
            "description": "Parameter n",
            "default": ""
          }
        },
        "required": [
          "j"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-matrices-common-classof": {
      "id": "sympy-sympy-matrices-common-classof",
      "name": "SymPy classof",
      "description": "Get the type of the result when combining matrices of different types. Currently the strategy is that immutability is contagious. Examples >>> from sympy import Matrix, ImmutableMatrix >>> from sympy.matrices.matrixbase import classof >>> M = Matrix([[1, 2], [3, 4]]) # a Mutable Matrix >>> IM = ImmutableMatrix([[1, 2], [3, 4]]) >>> classof(M, IM) <class 'sympy.matrices.immutable.ImmutableDenseMatrix'>",
      "category": "sympy",
      "module": "sympy.matrices.common",
      "function": "classof",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "A": {
            "type": "string",
            "description": "Parameter A",
            "default": ""
          },
          "B": {
            "type": "string",
            "description": "Parameter B",
            "default": ""
          }
        },
        "required": [
          "A",
          "B"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-geometry-polygon-deg": {
      "id": "sympy-sympy-geometry-polygon-deg",
      "name": "SymPy deg",
      "description": "Return the degree value for the given radians (pi = 180 degrees).",
      "category": "sympy",
      "module": "sympy.geometry.polygon",
      "function": "deg",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "r": {
            "type": "string",
            "description": "Parameter r",
            "default": ""
          }
        },
        "required": [
          "r"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-geometry-polygon-rad": {
      "id": "sympy-sympy-geometry-polygon-rad",
      "name": "SymPy rad",
      "description": "Return the radian value for the given degrees (pi = 180 degrees).",
      "category": "sympy",
      "module": "sympy.geometry.polygon",
      "function": "rad",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "d": {
            "type": "string",
            "description": "Parameter d",
            "default": ""
          }
        },
        "required": [
          "d"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-plotting-plot-check_arguments": {
      "id": "sympy-sympy-plotting-plot-check_arguments",
      "name": "SymPy check_arguments",
      "description": "Checks the arguments and converts into tuples of the form (exprs, ranges). Examples .. plot:: :context: reset :format: doctest :include-source: True >>> from sympy import cos, sin, symbols >>> from sympy.plotting.plot import check_arguments >>> x = symbols('x') >>> check_arguments([cos(x), sin(x)], 2, 1) [(cos(x), sin(x), (x, -10, 10))] >>> check_arguments([x, x**2], 1, 1) [(x, (x, -10, 10)), (x**2, (x, -10, 10))]",
      "category": "sympy",
      "module": "sympy.plotting.plot",
      "function": "check_arguments",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "args": {
            "type": "string",
            "description": "Parameter args",
            "default": ""
          },
          "expr_len": {
            "type": "string",
            "description": "Parameter expr_len",
            "default": ""
          },
          "nb_of_free_symbols": {
            "type": "string",
            "description": "Parameter nb_of_free_symbols",
            "default": ""
          }
        },
        "required": [
          "args",
          "expr_len",
          "nb_of_free_symbols"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-plotting-plot-plot": {
      "id": "sympy-sympy-plotting-plot-plot",
      "name": "SymPy plot",
      "description": "Plots a function of a single variable as a curve.",
      "category": "sympy",
      "module": "sympy.plotting.plot",
      "function": "plot",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "args": {
            "type": "string",
            "description": "The first argument is the expression representing the function of single variable to be plotted. The last argument is a 3-tuple denoting the range of the free variable. e.g. ``(x, 0, 5)`` Typical usage examples are in the following: - Plotting a single expression with a single range. ``plot(expr, range, **kwargs)`` - Plotting a single expression with the default range (-10, 10). ``plot(expr, **kwargs)`` - Plotting multiple expressions with a single range. ``plot(expr1, expr2, ..., range, **kwargs)`` - Plotting multiple expressions with multiple ranges. ``plot((expr1, range1), (expr2, range2), ..., **kwargs)`` It is best practice to specify range explicitly because default range may change in the future if a more advanced default range detection algorithm is implemented.",
            "default": ""
          },
          "show": {
            "type": "boolean",
            "description": "The default value is set to ``True``. Set show to ``False`` and the function will not display the plot. The returned instance of the ``Plot`` class can then be used to save or display the plot by calling the ``save()`` and ``show()`` methods respectively.",
            "default": true
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "args",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-plotting-plot-plot3d": {
      "id": "sympy-sympy-plotting-plot-plot3d",
      "name": "SymPy plot3d",
      "description": "Plots a 3D surface plot. Usage Single plot ``plot3d(expr, range_x, range_y, **kwargs)`` If the ranges are not specified, then a default range of (-10, 10) is used. Multiple plot with the same range. ``plot3d(expr1, expr2, range_x, range_y, **kwargs)`` If the ranges are not specified, then a default range of (-10, 10) is used. Multiple plots with different ranges. ``plot3d((expr1, range_x, range_y), (expr2, range_x, range_y), ..., **kwargs)`` Ranges have to be specified for every expression. Default range may change in the future if a more advanced default range detection algorithm is implemented. Arguments expr : Expression representing the function along x. range_x : (:class:`~.Symbol`, float, float) A 3-tuple denoting the range of the x variable, e.g. (x, 0, 5). range_y : (:class:`~.Symbol`, float, float) A 3-tuple denoting the range of the y variable, e.g. (y, 0, 5). Keyword Arguments Arguments for ``SurfaceOver2DRangeSeries`` class: n1 : int The x range is sampled uniformly at ``n1`` of points. This keyword argument replaces ``nb_of_points_x``, which should be considered deprecated. n2 : int The y range is sampled uniformly at ``n2`` of points. This keyword argument replaces ``nb_of_points_y``, which should be considered deprecated. Aesthetics: surface_color : Function which returns a float Specifies the color for the surface of the plot. See :class:`~.Plot` for more details. If there are multiple plots, then the same series arguments are applied to all the plots. If you want to set these options separately, you can index the returned ``Plot`` object and set it. Arguments for ``Plot`` class: title : str Title of the plot. size : (float, float), optional A tuple in the form (width, height) in inches to specify the size of the overall figure. The default value is set to ``None``, meaning the size will be set by the default backend. Examples .. plot:: :context: reset :format: doctest :include-source: True >>> from sympy import symbols >>> from sympy.plotting import plot3d >>> x, y = symbols('x y') Single plot .. plot:: :context: close-figs :format: doctest :include-source: True >>> plot3d(x*y, (x, -5, 5), (y, -5, 5)) Plot object containing: [0]: cartesian surface: x*y for x over (-5.0, 5.0) and y over (-5.0, 5.0) Multiple plots with same range .. plot:: :context: close-figs :format: doctest :include-source: True >>> plot3d(x*y, -x*y, (x, -5, 5), (y, -5, 5)) Plot object containing: [0]: cartesian surface: x*y for x over (-5.0, 5.0) and y over (-5.0, 5.0) [1]: cartesian surface: -x*y for x over (-5.0, 5.0) and y over (-5.0, 5.0) Multiple plots with different ranges. .. plot:: :context: close-figs :format: doctest :include-source: True >>> plot3d((x**2 + y**2, (x, -5, 5), (y, -5, 5)), ...     (x*y, (x, -3, 3), (y, -3, 3))) Plot object containing: [0]: cartesian surface: x**2 + y**2 for x over (-5.0, 5.0) and y over (-5.0, 5.0) [1]: cartesian surface: x*y for x over (-3.0, 3.0) and y over (-3.0, 3.0) See Also Plot, SurfaceOver2DRangeSeries",
      "category": "sympy",
      "module": "sympy.plotting.plot",
      "function": "plot3d",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "args": {
            "type": "string",
            "description": "Parameter args",
            "default": ""
          },
          "show": {
            "type": "string",
            "description": "Parameter show",
            "default": "True"
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "args",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-plotting-plot-plot3d_parametric_line": {
      "id": "sympy-sympy-plotting-plot-plot3d_parametric_line",
      "name": "SymPy plot3d_parametric_line",
      "description": "Plots a 3D parametric line plot. Usage Single plot: ``plot3d_parametric_line(expr_x, expr_y, expr_z, range, **kwargs)`` If the range is not specified, then a default range of (-10, 10) is used. Multiple plots. ``plot3d_parametric_line((expr_x, expr_y, expr_z, range), ..., **kwargs)`` Ranges have to be specified for every expression. Default range may change in the future if a more advanced default range detection algorithm is implemented. Arguments expr_x : Expression representing the function along x. expr_y : Expression representing the function along y. expr_z : Expression representing the function along z. range : (:class:`~.Symbol`, float, float) A 3-tuple denoting the range of the parameter variable, e.g., (u, 0, 5). Keyword Arguments Arguments for ``Parametric3DLineSeries`` class. n : int The range is uniformly sampled at ``n`` number of points. This keyword argument replaces ``nb_of_points``, which should be considered deprecated. Aesthetics: line_color : string, or float, or function, optional Specifies the color for the plot. See ``Plot`` to see how to set color for the plots. Note that by setting ``line_color``, it would be applied simultaneously to all the series. label : str The label to the plot. It will be used when called with ``legend=True`` to denote the function with the given label in the plot. If there are multiple plots, then the same series arguments are applied to all the plots. If you want to set these options separately, you can index the returned ``Plot`` object and set it. Arguments for ``Plot`` class. title : str Title of the plot. size : (float, float), optional A tuple in the form (width, height) in inches to specify the size of the overall figure. The default value is set to ``None``, meaning the size will be set by the default backend. Examples .. plot:: :context: reset :format: doctest :include-source: True >>> from sympy import symbols, cos, sin >>> from sympy.plotting import plot3d_parametric_line >>> u = symbols('u') Single plot. .. plot:: :context: close-figs :format: doctest :include-source: True >>> plot3d_parametric_line(cos(u), sin(u), u, (u, -5, 5)) Plot object containing: [0]: 3D parametric cartesian line: (cos(u), sin(u), u) for u over (-5.0, 5.0) Multiple plots. .. plot:: :context: close-figs :format: doctest :include-source: True >>> plot3d_parametric_line((cos(u), sin(u), u, (u, -5, 5)), ...     (sin(u), u**2, u, (u, -5, 5))) Plot object containing: [0]: 3D parametric cartesian line: (cos(u), sin(u), u) for u over (-5.0, 5.0) [1]: 3D parametric cartesian line: (sin(u), u**2, u) for u over (-5.0, 5.0) See Also Plot, Parametric3DLineSeries",
      "category": "sympy",
      "module": "sympy.plotting.plot",
      "function": "plot3d_parametric_line",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "args": {
            "type": "string",
            "description": "Parameter args",
            "default": ""
          },
          "show": {
            "type": "string",
            "description": "Parameter show",
            "default": "True"
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "args",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-plotting-plot-plot3d_parametric_surface": {
      "id": "sympy-sympy-plotting-plot-plot3d_parametric_surface",
      "name": "SymPy plot3d_parametric_surface",
      "description": "Plots a 3D parametric surface plot. Explanation Single plot. ``plot3d_parametric_surface(expr_x, expr_y, expr_z, range_u, range_v, **kwargs)`` If the ranges is not specified, then a default range of (-10, 10) is used. Multiple plots. ``plot3d_parametric_surface((expr_x, expr_y, expr_z, range_u, range_v), ..., **kwargs)`` Ranges have to be specified for every expression. Default range may change in the future if a more advanced default range detection algorithm is implemented. Arguments expr_x : Expression representing the function along ``x``. expr_y : Expression representing the function along ``y``. expr_z : Expression representing the function along ``z``. range_u : (:class:`~.Symbol`, float, float) A 3-tuple denoting the range of the u variable, e.g. (u, 0, 5). range_v : (:class:`~.Symbol`, float, float) A 3-tuple denoting the range of the v variable, e.g. (v, 0, 5). Keyword Arguments Arguments for ``ParametricSurfaceSeries`` class: n1 : int The ``u`` range is sampled uniformly at ``n1`` of points. This keyword argument replaces ``nb_of_points_u``, which should be considered deprecated. n2 : int The ``v`` range is sampled uniformly at ``n2`` of points. This keyword argument replaces ``nb_of_points_v``, which should be considered deprecated. Aesthetics: surface_color : Function which returns a float Specifies the color for the surface of the plot. See :class:`~Plot` for more details. If there are multiple plots, then the same series arguments are applied for all the plots. If you want to set these options separately, you can index the returned ``Plot`` object and set it. Arguments for ``Plot`` class: title : str Title of the plot. size : (float, float), optional A tuple in the form (width, height) in inches to specify the size of the overall figure. The default value is set to ``None``, meaning the size will be set by the default backend. Examples .. plot:: :context: reset :format: doctest :include-source: True >>> from sympy import symbols, cos, sin >>> from sympy.plotting import plot3d_parametric_surface >>> u, v = symbols('u v') Single plot. .. plot:: :context: close-figs :format: doctest :include-source: True >>> plot3d_parametric_surface(cos(u + v), sin(u - v), u - v, ...     (u, -5, 5), (v, -5, 5)) Plot object containing: [0]: parametric cartesian surface: (cos(u + v), sin(u - v), u - v) for u over (-5.0, 5.0) and v over (-5.0, 5.0) See Also Plot, ParametricSurfaceSeries",
      "category": "sympy",
      "module": "sympy.plotting.plot",
      "function": "plot3d_parametric_surface",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "args": {
            "type": "string",
            "description": "Parameter args",
            "default": ""
          },
          "show": {
            "type": "string",
            "description": "Parameter show",
            "default": "True"
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "args",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-plotting-plot-plot_contour": {
      "id": "sympy-sympy-plotting-plot-plot_contour",
      "name": "SymPy plot_contour",
      "description": "Draws contour plot of a function Usage Single plot ``plot_contour(expr, range_x, range_y, **kwargs)`` If the ranges are not specified, then a default range of (-10, 10) is used. Multiple plot with the same range. ``plot_contour(expr1, expr2, range_x, range_y, **kwargs)`` If the ranges are not specified, then a default range of (-10, 10) is used. Multiple plots with different ranges. ``plot_contour((expr1, range_x, range_y), (expr2, range_x, range_y), ..., **kwargs)`` Ranges have to be specified for every expression. Default range may change in the future if a more advanced default range detection algorithm is implemented. Arguments expr : Expression representing the function along x. range_x : (:class:`Symbol`, float, float) A 3-tuple denoting the range of the x variable, e.g. (x, 0, 5). range_y : (:class:`Symbol`, float, float) A 3-tuple denoting the range of the y variable, e.g. (y, 0, 5). Keyword Arguments Arguments for ``ContourSeries`` class: n1 : int The x range is sampled uniformly at ``n1`` of points. This keyword argument replaces ``nb_of_points_x``, which should be considered deprecated. n2 : int The y range is sampled uniformly at ``n2`` of points. This keyword argument replaces ``nb_of_points_y``, which should be considered deprecated. Aesthetics: surface_color : Function which returns a float Specifies the color for the surface of the plot. See :class:`sympy.plotting.Plot` for more details. If there are multiple plots, then the same series arguments are applied to all the plots. If you want to set these options separately, you can index the returned ``Plot`` object and set it. Arguments for ``Plot`` class: title : str Title of the plot. size : (float, float), optional A tuple in the form (width, height) in inches to specify the size of the overall figure. The default value is set to ``None``, meaning the size will be set by the default backend. See Also Plot, ContourSeries",
      "category": "sympy",
      "module": "sympy.plotting.plot",
      "function": "plot_contour",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "args": {
            "type": "string",
            "description": "Parameter args",
            "default": ""
          },
          "show": {
            "type": "string",
            "description": "Parameter show",
            "default": "True"
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "args",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-plotting-plot-plot_factory": {
      "id": "sympy-sympy-plotting-plot-plot_factory",
      "name": "SymPy plot_factory",
      "description": "SymPy plot_factory function",
      "category": "sympy",
      "module": "sympy.plotting.plot",
      "function": "plot_factory",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "args": {
            "type": "string",
            "description": "Parameter args",
            "default": ""
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "args",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    },
    "sympy-sympy-plotting-plot-plot_parametric": {
      "id": "sympy-sympy-plotting-plot-plot_parametric",
      "name": "SymPy plot_parametric",
      "description": "Plots a 2D parametric curve.",
      "category": "sympy",
      "module": "sympy.plotting.plot",
      "function": "plot_parametric",
      "icon": "\ud83e\uddee",
      "input_schema": {
        "type": "object",
        "properties": {
          "args": {
            "type": "string",
            "description": "Parameter args",
            "default": ""
          },
          "show": {
            "type": "string",
            "description": "Parameter show",
            "default": "True"
          },
          "kwargs": {
            "type": "string",
            "description": "Parameter kwargs",
            "default": ""
          }
        },
        "required": [
          "args",
          "kwargs"
        ],
        "additionalProperties": false
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "description": "Result of the computation"
          },
          "latex": {
            "type": "string",
            "description": "LaTeX representation of the result"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata about the computation"
          }
        },
        "required": [
          "result"
        ]
      }
    }
  }
}