{
  "sympy.core": {
    "classes": {
      "Add": {
        "full_name": "sympy.core.Add",
        "bases": [
          "Expr",
          "AssocOp"
        ],
        "doc": "Expression representing addition operation for algebraic group.\n\n.. deprecated:: 1.7\n\n   Using arguments that aren't subclasses of :class:`~.Expr` in core\n   operators (:class:`~.Mul`, :class:`~.Add`, and :class:`~.Pow`) is\n   deprecated. See :ref:`non-expr-args-deprecated` for details.\n\nEvery argument of ``Add()`` must be ``Expr``. Infix operator ``+``\non most scalar objects in SymPy calls this class.\n\nAnother use of ``Add()`` is to represent the structure of abstract\naddition so that its arguments can be substituted to return different\nclass. Refer to examples section for this.\n\n``Add()`` evaluates the argument unless ``evaluate=False`` is passed.\nThe evaluation logic includes:\n\n1. Flattening\n    ``Add(x, Add(y, z))`` -> ``Add(x, y, z)``\n\n2. Identity removing\n    ``Add(x, 0, y)`` -> ``Add(x, y)``\n\n3. Coefficient collecting by ``.as_coeff_Mul()``\n    ``Add(x, 2*x)`` -> ``Mul(3, x)``\n\n4. Term sorting\n    ``Add(y, x, 2)`` -> ``Add(2, x, y)``\n\nIf no argument is passed, identity element 0 is returned. If single\nelement is passed, that element is returned.\n\nNote that ``Add(*args)`` is more efficient than ``sum(args)`` because\nit flattens the arguments. ``sum(a, b, c, ...)`` recursively adds the\narguments as ``a + (b + (c + ...))``, which has quadratic complexity.\nOn the other hand, ``Add(a, b, c, d)`` does not assume nested\nstructure, making the complexity linear.\n\nSince addition is group operation, every argument should have the\nsame :obj:`sympy.core.kind.Kind()`.\n\nExamples\n========\n\n>>> from sympy import Add, I\n>>> from sympy.abc import x, y\n>>> Add(x, 1)\nx + 1\n>>> Add(x, x)\n2*x\n>>> 2*x**2 + 3*x + I*y + 2*y + 2*x/5 + 1.0*y + 1\n2*x**2 + 17*x/5 + 3.0*y + I*y + 1\n\nIf ``evaluate=False`` is passed, result is not evaluated.\n\n>>> Add(1, 2, evaluate=False)\n1 + 2\n>>> Add(x, x, evaluate=False)\nx + x\n\n``Add()`` also represents the general structure of addition operation.\n\n>>> from sympy import MatrixSymbol\n>>> A,B = MatrixSymbol('A', 2,2), MatrixSymbol('B', 2,2)\n>>> expr = Add(x,y).subs({x:A, y:B})\n>>> expr\nA + B\n>>> type(expr)\n<class 'sympy.matrices.expressions.matadd.MatAdd'>\n\nNote that the printers do not display in args order.\n\n>>> Add(x, 1)\nx + 1\n>>> Add(x, 1).args\n(1, x)\n\nSee Also\n========\n\nMatAdd",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False, deps=None) -> 'tuple[Number, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "deps": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              }
            },
            "return_annotation": "tuple[Number, Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Returns a tuple (coeff, args) where self is treated as an Add and coeff\nis the Number term and args is a tuple of all other terms.\n\nExamples\n========\n\n>>> from sympy.abc import x\n>>> (7 + 3*x).as_coeff_add()\n(7, (3*x,))\n>>> (7*x).as_coeff_add()\n(0, (7*x,))",
            "signature": "(self, *deps)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "AlgebraicNumber": {
        "full_name": "sympy.core.AlgebraicNumber",
        "bases": [
          "Expr"
        ],
        "doc": "Class for representing algebraic numbers in SymPy.\n\nSymbolically, an instance of this class represents an element\n$\\alpha \\in \\mathbb{Q}(\\theta) \\hookrightarrow \\mathbb{C}$. That is, the\nalgebraic number $\\alpha$ is represented as an element of a particular\nnumber field $\\mathbb{Q}(\\theta)$, with a particular embedding of this\nfield into the complex numbers.\n\nFormally, the primitive element $\\theta$ is given by two data points: (1)\nits minimal polynomial (which defines $\\mathbb{Q}(\\theta)$), and (2) a\nparticular complex number that is a root of this polynomial (which defines\nthe embedding $\\mathbb{Q}(\\theta) \\hookrightarrow \\mathbb{C}$). Finally,\nthe algebraic number $\\alpha$ which we represent is then given by the\ncoefficients of a polynomial in $\\theta$.",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Atom": {
        "full_name": "sympy.core.Atom",
        "bases": [
          "Basic"
        ],
        "doc": "A parent class for atomic things. An atom is an expression with no subexpressions.\n\nExamples\n========\n\nSymbol, Number, Rational, Integer, ...\nBut not: Add, Mul, Pow, ...",
        "methods": {
          "as_content_primitive": {
            "doc": "A stub to allow Basic args (like Tuple) to be skipped when computing\nthe content and primitive components of an expression.\n\nSee Also\n========\n\nsympy.core.expr.Expr.as_content_primitive",
            "signature": "(self, radical=False, clear=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "radical": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "clear": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_dummy": {
            "doc": "Return the expression with any objects having structurally\nbound symbols replaced with unique, canonical symbols within\nthe object in which they appear and having only the default\nassumption for commutativity being True. When applied to a\nsymbol a new symbol having only the same commutativity will be\nreturned.\n\nExamples\n========\n\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r\n\nNotes\n=====\n\nAny object that has structurally bound variables should have\na property, ``bound_symbols`` that returns those symbols\nappearing in the object.",
            "signature": "(self) -> \"'Self'\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "'Self'"
          },
          "atoms": {
            "doc": "Returns the atoms that form the current object.\n\nBy default, only objects that are truly atomic and cannot\nbe divided into smaller pieces are returned: symbols, numbers,\nand number symbols like I and pi. It is possible to request\natoms of any type, however, as demonstrated below.\n\nExamples\n========\n\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y}\n\nIf one or more types are given, the results will contain only\nthose types of atoms.\n\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi}\n\nNote that I (imaginary unit) and zoo (complex infinity) are special\ntypes of number symbols and are not part of the NumberSymbol class.\n\nThe type can be given implicitly, too:\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y}\n\nBe careful to check your assumptions when using the implicit option\nsince ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\nof SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\nintegers in an expression:\n\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2}\n\nFinally, arguments to atoms() can select more than atomic atoms: any\nSymPy type (loaded in core/__init__.py) can be listed as an argument\nand those types of \"atoms\" as found in scanning the arguments of the\nexpression recursively:\n\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)}",
            "signature": "(self, *types: 'Tbasic | type[Tbasic]') -> 'set[Basic] | set[Tbasic]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "types": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": "Tbasic | type[Tbasic]"
              }
            },
            "return_annotation": "set[Basic] | set[Tbasic]"
          },
          "class_key": {
            "doc": "Nice order of classes.",
            "signature": "()",
            "parameters": {},
            "return_annotation": null
          },
          "compare": {
            "doc": "Return -1, 0, 1 if the object is less than, equal,\nor greater than other in a canonical sense.\nNon-Basic are always greater than Basic.\nIf both names of the classes being compared appear\nin the `ordering_of_classes` then the ordering will\ndepend on the appearance of the names there.\nIf either does not appear in that list, then the\ncomparison is based on the class name.\nIf the names are the same then a comparison is made\non the length of the hashable content.\nItems of the equal-lengthed contents are then\nsuccessively compared using the same rules. If there\nis never a difference then 0 is returned.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1",
            "signature": "(self, other)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "other": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "copy": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "could_extract_minus_sign": {
            "doc": "",
            "signature": "(self) -> 'bool'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "bool"
          },
          "count": {
            "doc": "Count the number of matching subexpressions.",
            "signature": "(self, query)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "query": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "count_ops": {
            "doc": "Wrapper for count_ops that returns the operation count.",
            "signature": "(self, visual=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "visual": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "doit": {
            "doc": "Evaluate objects that are not evaluated by default like limits,\nintegrals, sums and products. All objects of this kind will be\nevaluated recursively, unless some species were excluded via 'hints'\nor unless the 'deep' hint was set to 'False'.\n\n>>> from sympy import Integral\n>>> from sympy.abc import x\n\n>>> 2*Integral(x, x)\n2*Integral(x, x)\n\n>>> (2*Integral(x, x)).doit()\nx**2\n\n>>> (2*Integral(x, x)).doit(deep=False)\n2*Integral(x, x)",
            "signature": "(self, **hints)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "hints": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "AtomicExpr": {
        "full_name": "sympy.core.AtomicExpr",
        "bases": [
          "Atom",
          "Expr"
        ],
        "doc": "A parent class for object which are both atoms and Exprs.\n\nFor example: Symbol, Number, Rational, Integer, ...\nBut not: Add, Mul, Pow, ...",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Basic": {
        "full_name": "sympy.core.Basic",
        "bases": [
          "Printable"
        ],
        "doc": "Base class for all SymPy objects.\n\nNotes and conventions\n=====================\n\n1) Always use ``.args``, when accessing parameters of some instance:\n\n>>> from sympy import cot\n>>> from sympy.abc import x, y\n\n>>> cot(x).args\n(x,)\n\n>>> cot(x).args[0]\nx\n\n>>> (x*y).args\n(x, y)\n\n>>> (x*y).args[1]\ny\n\n\n2) Never use internal methods or variables (the ones prefixed with ``_``):\n\n>>> cot(x)._args    # do not use this, use cot(x).args instead\n(x,)\n\n\n3)  By \"SymPy object\" we mean something that can be returned by\n    ``sympify``.  But not all objects one encounters using SymPy are\n    subclasses of Basic.  For example, mutable objects are not:\n\n    >>> from sympy import Basic, Matrix, sympify\n    >>> A = Matrix([[1, 2], [3, 4]]).as_mutable()\n    >>> isinstance(A, Basic)\n    False\n\n    >>> B = sympify(A)\n    >>> isinstance(B, Basic)\n    True",
        "methods": {
          "as_content_primitive": {
            "doc": "A stub to allow Basic args (like Tuple) to be skipped when computing\nthe content and primitive components of an expression.\n\nSee Also\n========\n\nsympy.core.expr.Expr.as_content_primitive",
            "signature": "(self, radical=False, clear=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "radical": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "clear": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_dummy": {
            "doc": "Return the expression with any objects having structurally\nbound symbols replaced with unique, canonical symbols within\nthe object in which they appear and having only the default\nassumption for commutativity being True. When applied to a\nsymbol a new symbol having only the same commutativity will be\nreturned.\n\nExamples\n========\n\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r\n\nNotes\n=====\n\nAny object that has structurally bound variables should have\na property, ``bound_symbols`` that returns those symbols\nappearing in the object.",
            "signature": "(self) -> \"'Self'\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "'Self'"
          },
          "atoms": {
            "doc": "Returns the atoms that form the current object.\n\nBy default, only objects that are truly atomic and cannot\nbe divided into smaller pieces are returned: symbols, numbers,\nand number symbols like I and pi. It is possible to request\natoms of any type, however, as demonstrated below.\n\nExamples\n========\n\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y}\n\nIf one or more types are given, the results will contain only\nthose types of atoms.\n\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi}\n\nNote that I (imaginary unit) and zoo (complex infinity) are special\ntypes of number symbols and are not part of the NumberSymbol class.\n\nThe type can be given implicitly, too:\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y}\n\nBe careful to check your assumptions when using the implicit option\nsince ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\nof SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\nintegers in an expression:\n\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2}\n\nFinally, arguments to atoms() can select more than atomic atoms: any\nSymPy type (loaded in core/__init__.py) can be listed as an argument\nand those types of \"atoms\" as found in scanning the arguments of the\nexpression recursively:\n\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)}",
            "signature": "(self, *types: 'Tbasic | type[Tbasic]') -> 'set[Basic] | set[Tbasic]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "types": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": "Tbasic | type[Tbasic]"
              }
            },
            "return_annotation": "set[Basic] | set[Tbasic]"
          },
          "class_key": {
            "doc": "Nice order of classes.",
            "signature": "() -> 'tuple[int, int, str]'",
            "parameters": {},
            "return_annotation": "tuple[int, int, str]"
          },
          "compare": {
            "doc": "Return -1, 0, 1 if the object is less than, equal,\nor greater than other in a canonical sense.\nNon-Basic are always greater than Basic.\nIf both names of the classes being compared appear\nin the `ordering_of_classes` then the ordering will\ndepend on the appearance of the names there.\nIf either does not appear in that list, then the\ncomparison is based on the class name.\nIf the names are the same then a comparison is made\non the length of the hashable content.\nItems of the equal-lengthed contents are then\nsuccessively compared using the same rules. If there\nis never a difference then 0 is returned.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1",
            "signature": "(self, other)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "other": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "copy": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "could_extract_minus_sign": {
            "doc": "",
            "signature": "(self) -> 'bool'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "bool"
          },
          "count": {
            "doc": "Count the number of matching subexpressions.",
            "signature": "(self, query)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "query": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "count_ops": {
            "doc": "Wrapper for count_ops that returns the operation count.",
            "signature": "(self, visual=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "visual": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "doit": {
            "doc": "Evaluate objects that are not evaluated by default like limits,\nintegrals, sums and products. All objects of this kind will be\nevaluated recursively, unless some species were excluded via 'hints'\nor unless the 'deep' hint was set to 'False'.\n\n>>> from sympy import Integral\n>>> from sympy.abc import x\n\n>>> 2*Integral(x, x)\n2*Integral(x, x)\n\n>>> (2*Integral(x, x)).doit()\nx**2\n\n>>> (2*Integral(x, x)).doit(deep=False)\n2*Integral(x, x)",
            "signature": "(self, **hints)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "hints": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "Derivative": {
        "full_name": "sympy.core.Derivative",
        "bases": [
          "Expr"
        ],
        "doc": "Carries out differentiation of the given expression with respect to symbols.\n\nExamples\n========\n\n>>> from sympy import Derivative, Function, symbols, Subs\n>>> from sympy.abc import x, y\n>>> f, g = symbols('f g', cls=Function)\n\n>>> Derivative(x**2, x, evaluate=True)\n2*x\n\nDenesting of derivatives retains the ordering of variables:\n\n    >>> Derivative(Derivative(f(x, y), y), x)\n    Derivative(f(x, y), y, x)\n\nContiguously identical symbols are merged into a tuple giving\nthe symbol and the count:\n\n    >>> Derivative(f(x), x, x, y, x)\n    Derivative(f(x), (x, 2), y, x)\n\nIf the derivative cannot be performed, and evaluate is True, the\norder of the variables of differentiation will be made canonical:\n\n    >>> Derivative(f(x, y), y, x, evaluate=True)\n    Derivative(f(x, y), x, y)\n\nDerivatives with respect to undefined functions can be calculated:\n\n    >>> Derivative(f(x)**2, f(x), evaluate=True)\n    2*f(x)\n\nSuch derivatives will show up when the chain rule is used to\nevaluate a derivative:\n\n    >>> f(g(x)).diff(x)\n    Derivative(f(g(x)), g(x))*Derivative(g(x), x)\n\nSubstitution is used to represent derivatives of functions with\narguments that are not symbols or functions:\n\n    >>> f(2*x + 3).diff(x) == 2*Subs(f(y).diff(y), y, 2*x + 3)\n    True\n\nNotes\n=====\n\nSimplification of high-order derivatives:\n\nBecause there can be a significant amount of simplification that can be\ndone when multiple differentiations are performed, results will be\nautomatically simplified in a fairly conservative fashion unless the\nkeyword ``simplify`` is set to False.\n\n    >>> from sympy import sqrt, diff, Function, symbols\n    >>> from sympy.abc import x, y, z\n    >>> f, g = symbols('f,g', cls=Function)\n\n    >>> e = sqrt((x + 1)**2 + x)\n    >>> diff(e, (x, 5), simplify=False).count_ops()\n    136\n    >>> diff(e, (x, 5)).count_ops()\n    30\n\nOrdering of variables:\n\nIf evaluate is set to True and the expression cannot be evaluated, the\nlist of differentiation symbols will be sorted, that is, the expression is\nassumed to have continuous derivatives up to the order asked.\n\nDerivative wrt non-Symbols:\n\nFor the most part, one may not differentiate wrt non-symbols.\nFor example, we do not allow differentiation wrt `x*y` because\nthere are multiple ways of structurally defining where x*y appears\nin an expression: a very strict definition would make\n(x*y*z).diff(x*y) == 0. Derivatives wrt defined functions (like\ncos(x)) are not allowed, either:\n\n    >>> (x*y*z).diff(x*y)\n    Traceback (most recent call last):\n    ...\n    ValueError: Can't calculate derivative wrt x*y.\n\nTo make it easier to work with variational calculus, however,\nderivatives wrt AppliedUndef and Derivatives are allowed.\nFor example, in the Euler-Lagrange method one may write\nF(t, u, v) where u = f(t) and v = f'(t). These variables can be\nwritten explicitly as functions of time::\n\n    >>> from sympy.abc import t\n    >>> F = Function('F')\n    >>> U = f(t)\n    >>> V = U.diff(t)\n\nThe derivative wrt f(t) can be obtained directly:\n\n    >>> direct = F(t, U, V).diff(U)\n\nWhen differentiation wrt a non-Symbol is attempted, the non-Symbol\nis temporarily converted to a Symbol while the differentiation\nis performed and the same answer is obtained:\n\n    >>> indirect = F(t, U, V).subs(U, x).diff(x).subs(x, U)\n    >>> assert direct == indirect\n\nThe implication of this non-symbol replacement is that all\nfunctions are treated as independent of other functions and the\nsymbols are independent of the functions that contain them::\n\n    >>> x.diff(f(x))\n    0\n    >>> g(x).diff(f(x))\n    0\n\nIt also means that derivatives are assumed to depend only\non the variables of differentiation, not on anything contained\nwithin the expression being differentiated::\n\n    >>> F = f(x)\n    >>> Fx = F.diff(x)\n    >>> Fx.diff(F)  # derivative depends on x, not F\n    0\n    >>> Fxx = Fx.diff(x)\n    >>> Fxx.diff(Fx)  # derivative depends on x, not Fx\n    0\n\nThe last example can be made explicit by showing the replacement\nof Fx in Fxx with y:\n\n    >>> Fxx.subs(Fx, y)\n    Derivative(y, x)\n\n    Since that in itself will evaluate to zero, differentiating\n    wrt Fx will also be zero:\n\n    >>> _.doit()\n    0\n\nReplacing undefined functions with concrete expressions\n\nOne must be careful to replace undefined functions with expressions\nthat contain variables consistent with the function definition and\nthe variables of differentiation or else insconsistent result will\nbe obtained. Consider the following example:\n\n>>> eq = f(x)*g(y)\n>>> eq.subs(f(x), x*y).diff(x, y).doit()\ny*Derivative(g(y), y) + g(y)\n>>> eq.diff(x, y).subs(f(x), x*y).doit()\ny*Derivative(g(y), y)\n\nThe results differ because `f(x)` was replaced with an expression\nthat involved both variables of differentiation. In the abstract\ncase, differentiation of `f(x)` by `y` is 0; in the concrete case,\nthe presence of `y` made that derivative nonvanishing and produced\nthe extra `g(y)` term.\n\nDefining differentiation for an object\n\nAn object must define ._eval_derivative(symbol) method that returns\nthe differentiation result. This function only needs to consider the\nnon-trivial case where expr contains symbol and it should call the diff()\nmethod internally (not _eval_derivative); Derivative should be the only\none to call _eval_derivative.\n\nAny class can allow derivatives to be taken with respect to\nitself (while indicating its scalar nature). See the\ndocstring of Expr._diff_wrt.\n\nSee Also\n========\n_sort_variable_count",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Dict": {
        "full_name": "sympy.core.Dict",
        "bases": [
          "Basic"
        ],
        "doc": "Wrapper around the builtin dict object.\n\nExplanation\n===========\n\nThe Dict is a subclass of Basic, so that it works well in the\nSymPy framework.  Because it is immutable, it may be included\nin sets, but its values must all be given at instantiation and\ncannot be changed afterwards.  Otherwise it behaves identically\nto the Python dict.\n\nExamples\n========\n\n>>> from sympy import Dict, Symbol\n\n>>> D = Dict({1: 'one', 2: 'two'})\n>>> for key in D:\n...    if key == 1:\n...        print('%s %s' % (key, D[key]))\n1 one\n\nThe args are sympified so the 1 and 2 are Integers and the values\nare Symbols. Queries automatically sympify args so the following work:\n\n>>> 1 in D\nTrue\n>>> D.has(Symbol('one')) # searches keys and values\nTrue\n>>> 'one' in D # not in the keys\nFalse\n>>> D[1]\none",
        "methods": {
          "as_content_primitive": {
            "doc": "A stub to allow Basic args (like Tuple) to be skipped when computing\nthe content and primitive components of an expression.\n\nSee Also\n========\n\nsympy.core.expr.Expr.as_content_primitive",
            "signature": "(self, radical=False, clear=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "radical": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "clear": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_dummy": {
            "doc": "Return the expression with any objects having structurally\nbound symbols replaced with unique, canonical symbols within\nthe object in which they appear and having only the default\nassumption for commutativity being True. When applied to a\nsymbol a new symbol having only the same commutativity will be\nreturned.\n\nExamples\n========\n\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r\n\nNotes\n=====\n\nAny object that has structurally bound variables should have\na property, ``bound_symbols`` that returns those symbols\nappearing in the object.",
            "signature": "(self) -> \"'Self'\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "'Self'"
          },
          "atoms": {
            "doc": "Returns the atoms that form the current object.\n\nBy default, only objects that are truly atomic and cannot\nbe divided into smaller pieces are returned: symbols, numbers,\nand number symbols like I and pi. It is possible to request\natoms of any type, however, as demonstrated below.\n\nExamples\n========\n\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y}\n\nIf one or more types are given, the results will contain only\nthose types of atoms.\n\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi}\n\nNote that I (imaginary unit) and zoo (complex infinity) are special\ntypes of number symbols and are not part of the NumberSymbol class.\n\nThe type can be given implicitly, too:\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y}\n\nBe careful to check your assumptions when using the implicit option\nsince ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\nof SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\nintegers in an expression:\n\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2}\n\nFinally, arguments to atoms() can select more than atomic atoms: any\nSymPy type (loaded in core/__init__.py) can be listed as an argument\nand those types of \"atoms\" as found in scanning the arguments of the\nexpression recursively:\n\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)}",
            "signature": "(self, *types: 'Tbasic | type[Tbasic]') -> 'set[Basic] | set[Tbasic]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "types": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": "Tbasic | type[Tbasic]"
              }
            },
            "return_annotation": "set[Basic] | set[Tbasic]"
          },
          "class_key": {
            "doc": "Nice order of classes.",
            "signature": "() -> 'tuple[int, int, str]'",
            "parameters": {},
            "return_annotation": "tuple[int, int, str]"
          },
          "compare": {
            "doc": "Return -1, 0, 1 if the object is less than, equal,\nor greater than other in a canonical sense.\nNon-Basic are always greater than Basic.\nIf both names of the classes being compared appear\nin the `ordering_of_classes` then the ordering will\ndepend on the appearance of the names there.\nIf either does not appear in that list, then the\ncomparison is based on the class name.\nIf the names are the same then a comparison is made\non the length of the hashable content.\nItems of the equal-lengthed contents are then\nsuccessively compared using the same rules. If there\nis never a difference then 0 is returned.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1",
            "signature": "(self, other)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "other": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "copy": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "could_extract_minus_sign": {
            "doc": "",
            "signature": "(self) -> 'bool'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "bool"
          },
          "count": {
            "doc": "Count the number of matching subexpressions.",
            "signature": "(self, query)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "query": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "count_ops": {
            "doc": "Wrapper for count_ops that returns the operation count.",
            "signature": "(self, visual=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "visual": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "doit": {
            "doc": "Evaluate objects that are not evaluated by default like limits,\nintegrals, sums and products. All objects of this kind will be\nevaluated recursively, unless some species were excluded via 'hints'\nor unless the 'deep' hint was set to 'False'.\n\n>>> from sympy import Integral\n>>> from sympy.abc import x\n\n>>> 2*Integral(x, x)\n2*Integral(x, x)\n\n>>> (2*Integral(x, x)).doit()\nx**2\n\n>>> (2*Integral(x, x)).doit(deep=False)\n2*Integral(x, x)",
            "signature": "(self, **hints)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "hints": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "Dummy": {
        "full_name": "sympy.core.Dummy",
        "bases": [
          "Symbol"
        ],
        "doc": "Dummy symbols are each unique, even if they have the same name:\n\nExamples\n========\n\n>>> from sympy import Dummy\n>>> Dummy(\"x\") == Dummy(\"x\")\nFalse\n\nIf a name is not supplied then a string value of an internal count will be\nused. This is useful when a temporary variable is needed and the name\nof the variable used in the expression is not important.\n\n>>> Dummy() #doctest: +SKIP\n_Dummy_10",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Eq": {
        "full_name": "sympy.core.Eq",
        "bases": [
          "Relational"
        ],
        "doc": "An equal relation between two objects.\n\nExplanation\n===========\n\nRepresents that two objects are equal.  If they can be easily shown\nto be definitively equal (or unequal), this will reduce to True (or\nFalse).  Otherwise, the relation is maintained as an unevaluated\nEquality object.  Use the ``simplify`` function on this object for\nmore nontrivial evaluation of the equality relation.\n\nAs usual, the keyword argument ``evaluate=False`` can be used to\nprevent any evaluation.\n\nExamples\n========\n\n>>> from sympy import Eq, simplify, exp, cos\n>>> from sympy.abc import x, y\n>>> Eq(y, x + x**2)\nEq(y, x**2 + x)\n>>> Eq(2, 5)\nFalse\n>>> Eq(2, 5, evaluate=False)\nEq(2, 5)\n>>> _.doit()\nFalse\n>>> Eq(exp(x), exp(x).rewrite(cos))\nEq(exp(x), sinh(x) + cosh(x))\n>>> simplify(_)\nTrue\n\nSee Also\n========\n\nsympy.logic.boolalg.Equivalent : for representing equality between two\n    boolean expressions\n\nNotes\n=====\n\nPython treats 1 and True (and 0 and False) as being equal; SymPy\ndoes not. And integer will always compare as unequal to a Boolean:\n\n>>> Eq(True, 1), True == 1\n(False, True)\n\nThis class is not the same as the == operator.  The == operator tests\nfor exact structural equality between two expressions; this class\ncompares expressions mathematically.\n\nIf either object defines an ``_eval_Eq`` method, it can be used in place of\nthe default algorithm.  If ``lhs._eval_Eq(rhs)`` or ``rhs._eval_Eq(lhs)``\nreturns anything other than None, that return value will be substituted for\nthe Equality.  If None is returned by ``_eval_Eq``, an Equality object will\nbe created as usual.\n\nSince this object is already an expression, it does not respond to\nthe method ``as_expr`` if one tries to create `x - y` from ``Eq(x, y)``.\nIf ``eq = Eq(x, y)`` then write `eq.lhs - eq.rhs` to get ``x - y``.\n\n.. deprecated:: 1.5\n\n   ``Eq(expr)`` with a single argument is a shorthand for ``Eq(expr, 0)``,\n   but this behavior is deprecated and will be removed in a future version\n   of SymPy.",
        "methods": {
          "as_content_primitive": {
            "doc": "A stub to allow Basic args (like Tuple) to be skipped when computing\nthe content and primitive components of an expression.\n\nSee Also\n========\n\nsympy.core.expr.Expr.as_content_primitive",
            "signature": "(self, radical=False, clear=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "radical": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "clear": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_dummy": {
            "doc": "Return the expression with any objects having structurally\nbound symbols replaced with unique, canonical symbols within\nthe object in which they appear and having only the default\nassumption for commutativity being True. When applied to a\nsymbol a new symbol having only the same commutativity will be\nreturned.\n\nExamples\n========\n\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r\n\nNotes\n=====\n\nAny object that has structurally bound variables should have\na property, ``bound_symbols`` that returns those symbols\nappearing in the object.",
            "signature": "(self) -> \"'Self'\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "'Self'"
          },
          "as_poly": {
            "doc": "Returns lhs-rhs as a Poly\n\nExamples\n========\n\n>>> from sympy import Eq\n>>> from sympy.abc import x\n>>> Eq(x**2, 1).as_poly(x)\nPoly(x**2 - 1, x, domain='ZZ')",
            "signature": "(self, *gens, **kwargs)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "gens": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_set": {
            "doc": "Rewrites Boolean expression in terms of real sets.\n\nExamples\n========\n\n>>> from sympy import Symbol, Eq, Or, And\n>>> x = Symbol('x', real=True)\n>>> Eq(x, 0).as_set()\n{0}\n>>> (x > 0).as_set()\nInterval.open(0, oo)\n>>> And(-2 < x, x < 2).as_set()\nInterval.open(-2, 2)\n>>> Or(x < -2, 2 < x).as_set()\nUnion(Interval.open(-oo, -2), Interval.open(2, oo))",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "atoms": {
            "doc": "Returns the atoms that form the current object.\n\nBy default, only objects that are truly atomic and cannot\nbe divided into smaller pieces are returned: symbols, numbers,\nand number symbols like I and pi. It is possible to request\natoms of any type, however, as demonstrated below.\n\nExamples\n========\n\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y}\n\nIf one or more types are given, the results will contain only\nthose types of atoms.\n\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi}\n\nNote that I (imaginary unit) and zoo (complex infinity) are special\ntypes of number symbols and are not part of the NumberSymbol class.\n\nThe type can be given implicitly, too:\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y}\n\nBe careful to check your assumptions when using the implicit option\nsince ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\nof SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\nintegers in an expression:\n\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2}\n\nFinally, arguments to atoms() can select more than atomic atoms: any\nSymPy type (loaded in core/__init__.py) can be listed as an argument\nand those types of \"atoms\" as found in scanning the arguments of the\nexpression recursively:\n\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)}",
            "signature": "(self, *types: 'Tbasic | type[Tbasic]') -> 'set[Basic] | set[Tbasic]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "types": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": "Tbasic | type[Tbasic]"
              }
            },
            "return_annotation": "set[Basic] | set[Tbasic]"
          },
          "class_key": {
            "doc": "Nice order of classes.",
            "signature": "() -> 'tuple[int, int, str]'",
            "parameters": {},
            "return_annotation": "tuple[int, int, str]"
          },
          "compare": {
            "doc": "Return -1, 0, 1 if the object is less than, equal,\nor greater than other in a canonical sense.\nNon-Basic are always greater than Basic.\nIf both names of the classes being compared appear\nin the `ordering_of_classes` then the ordering will\ndepend on the appearance of the names there.\nIf either does not appear in that list, then the\ncomparison is based on the class name.\nIf the names are the same then a comparison is made\non the length of the hashable content.\nItems of the equal-lengthed contents are then\nsuccessively compared using the same rules. If there\nis never a difference then 0 is returned.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1",
            "signature": "(self, other)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "other": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "copy": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "could_extract_minus_sign": {
            "doc": "",
            "signature": "(self) -> 'bool'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "bool"
          },
          "count": {
            "doc": "Count the number of matching subexpressions.",
            "signature": "(self, query)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "query": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "Equality": {
        "full_name": "sympy.core.Equality",
        "bases": [
          "Relational"
        ],
        "doc": "An equal relation between two objects.\n\nExplanation\n===========\n\nRepresents that two objects are equal.  If they can be easily shown\nto be definitively equal (or unequal), this will reduce to True (or\nFalse).  Otherwise, the relation is maintained as an unevaluated\nEquality object.  Use the ``simplify`` function on this object for\nmore nontrivial evaluation of the equality relation.\n\nAs usual, the keyword argument ``evaluate=False`` can be used to\nprevent any evaluation.\n\nExamples\n========\n\n>>> from sympy import Eq, simplify, exp, cos\n>>> from sympy.abc import x, y\n>>> Eq(y, x + x**2)\nEq(y, x**2 + x)\n>>> Eq(2, 5)\nFalse\n>>> Eq(2, 5, evaluate=False)\nEq(2, 5)\n>>> _.doit()\nFalse\n>>> Eq(exp(x), exp(x).rewrite(cos))\nEq(exp(x), sinh(x) + cosh(x))\n>>> simplify(_)\nTrue\n\nSee Also\n========\n\nsympy.logic.boolalg.Equivalent : for representing equality between two\n    boolean expressions\n\nNotes\n=====\n\nPython treats 1 and True (and 0 and False) as being equal; SymPy\ndoes not. And integer will always compare as unequal to a Boolean:\n\n>>> Eq(True, 1), True == 1\n(False, True)\n\nThis class is not the same as the == operator.  The == operator tests\nfor exact structural equality between two expressions; this class\ncompares expressions mathematically.\n\nIf either object defines an ``_eval_Eq`` method, it can be used in place of\nthe default algorithm.  If ``lhs._eval_Eq(rhs)`` or ``rhs._eval_Eq(lhs)``\nreturns anything other than None, that return value will be substituted for\nthe Equality.  If None is returned by ``_eval_Eq``, an Equality object will\nbe created as usual.\n\nSince this object is already an expression, it does not respond to\nthe method ``as_expr`` if one tries to create `x - y` from ``Eq(x, y)``.\nIf ``eq = Eq(x, y)`` then write `eq.lhs - eq.rhs` to get ``x - y``.\n\n.. deprecated:: 1.5\n\n   ``Eq(expr)`` with a single argument is a shorthand for ``Eq(expr, 0)``,\n   but this behavior is deprecated and will be removed in a future version\n   of SymPy.",
        "methods": {
          "as_content_primitive": {
            "doc": "A stub to allow Basic args (like Tuple) to be skipped when computing\nthe content and primitive components of an expression.\n\nSee Also\n========\n\nsympy.core.expr.Expr.as_content_primitive",
            "signature": "(self, radical=False, clear=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "radical": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "clear": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_dummy": {
            "doc": "Return the expression with any objects having structurally\nbound symbols replaced with unique, canonical symbols within\nthe object in which they appear and having only the default\nassumption for commutativity being True. When applied to a\nsymbol a new symbol having only the same commutativity will be\nreturned.\n\nExamples\n========\n\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r\n\nNotes\n=====\n\nAny object that has structurally bound variables should have\na property, ``bound_symbols`` that returns those symbols\nappearing in the object.",
            "signature": "(self) -> \"'Self'\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "'Self'"
          },
          "as_poly": {
            "doc": "Returns lhs-rhs as a Poly\n\nExamples\n========\n\n>>> from sympy import Eq\n>>> from sympy.abc import x\n>>> Eq(x**2, 1).as_poly(x)\nPoly(x**2 - 1, x, domain='ZZ')",
            "signature": "(self, *gens, **kwargs)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "gens": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_set": {
            "doc": "Rewrites Boolean expression in terms of real sets.\n\nExamples\n========\n\n>>> from sympy import Symbol, Eq, Or, And\n>>> x = Symbol('x', real=True)\n>>> Eq(x, 0).as_set()\n{0}\n>>> (x > 0).as_set()\nInterval.open(0, oo)\n>>> And(-2 < x, x < 2).as_set()\nInterval.open(-2, 2)\n>>> Or(x < -2, 2 < x).as_set()\nUnion(Interval.open(-oo, -2), Interval.open(2, oo))",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "atoms": {
            "doc": "Returns the atoms that form the current object.\n\nBy default, only objects that are truly atomic and cannot\nbe divided into smaller pieces are returned: symbols, numbers,\nand number symbols like I and pi. It is possible to request\natoms of any type, however, as demonstrated below.\n\nExamples\n========\n\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y}\n\nIf one or more types are given, the results will contain only\nthose types of atoms.\n\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi}\n\nNote that I (imaginary unit) and zoo (complex infinity) are special\ntypes of number symbols and are not part of the NumberSymbol class.\n\nThe type can be given implicitly, too:\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y}\n\nBe careful to check your assumptions when using the implicit option\nsince ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\nof SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\nintegers in an expression:\n\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2}\n\nFinally, arguments to atoms() can select more than atomic atoms: any\nSymPy type (loaded in core/__init__.py) can be listed as an argument\nand those types of \"atoms\" as found in scanning the arguments of the\nexpression recursively:\n\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)}",
            "signature": "(self, *types: 'Tbasic | type[Tbasic]') -> 'set[Basic] | set[Tbasic]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "types": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": "Tbasic | type[Tbasic]"
              }
            },
            "return_annotation": "set[Basic] | set[Tbasic]"
          },
          "class_key": {
            "doc": "Nice order of classes.",
            "signature": "() -> 'tuple[int, int, str]'",
            "parameters": {},
            "return_annotation": "tuple[int, int, str]"
          },
          "compare": {
            "doc": "Return -1, 0, 1 if the object is less than, equal,\nor greater than other in a canonical sense.\nNon-Basic are always greater than Basic.\nIf both names of the classes being compared appear\nin the `ordering_of_classes` then the ordering will\ndepend on the appearance of the names there.\nIf either does not appear in that list, then the\ncomparison is based on the class name.\nIf the names are the same then a comparison is made\non the length of the hashable content.\nItems of the equal-lengthed contents are then\nsuccessively compared using the same rules. If there\nis never a difference then 0 is returned.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1",
            "signature": "(self, other)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "other": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "copy": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "could_extract_minus_sign": {
            "doc": "",
            "signature": "(self) -> 'bool'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "bool"
          },
          "count": {
            "doc": "Count the number of matching subexpressions.",
            "signature": "(self, query)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "query": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "Expr": {
        "full_name": "sympy.core.Expr",
        "bases": [
          "Basic",
          "EvalfMixin"
        ],
        "doc": "Base class for algebraic expressions.\n\nExplanation\n===========\n\nEverything that requires arithmetic operations to be defined\nshould subclass this class, instead of Basic (which should be\nused only for argument storage and expression manipulation, i.e.\npattern matching, substitutions, etc).\n\nIf you want to override the comparisons of expressions:\nShould use _eval_is_ge for inequality, or _eval_is_eq, with multiple dispatch.\n_eval_is_ge return true if x >= y, false if x < y, and None if the two types\nare not comparable or the comparison is indeterminate\n\nSee Also\n========\n\nsympy.core.basic.Basic",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Float": {
        "full_name": "sympy.core.Float",
        "bases": [
          "Number"
        ],
        "doc": "Represent a floating-point number of arbitrary precision.\n\nExamples\n========\n\n>>> from sympy import Float\n>>> Float(3.5)\n3.50000000000000\n>>> Float(3)\n3.00000000000000\n\nCreating Floats from strings (and Python ``int`` and ``long``\ntypes) will give a minimum precision of 15 digits, but the\nprecision will automatically increase to capture all digits\nentered.\n\n>>> Float(1)\n1.00000000000000\n>>> Float(10**20)\n100000000000000000000.\n>>> Float('1e20')\n100000000000000000000.\n\nHowever, *floating-point* numbers (Python ``float`` types) retain\nonly 15 digits of precision:\n\n>>> Float(1e20)\n1.00000000000000e+20\n>>> Float(1.23456789123456789)\n1.23456789123457\n\nIt may be preferable to enter high-precision decimal numbers\nas strings:\n\n>>> Float('1.23456789123456789')\n1.23456789123456789\n\nThe desired number of digits can also be specified:\n\n>>> Float('1e-3', 3)\n0.00100\n>>> Float(100, 4)\n100.0\n\nFloat can automatically count significant figures if a null string\nis sent for the precision; spaces or underscores are also allowed. (Auto-\ncounting is only allowed for strings, ints and longs).\n\n>>> Float('123 456 789.123_456', '')\n123456789.123456\n>>> Float('12e-3', '')\n0.012\n>>> Float(3, '')\n3.\n\nIf a number is written in scientific notation, only the digits before the\nexponent are considered significant if a decimal appears, otherwise the\n\"e\" signifies only how to move the decimal:\n\n>>> Float('60.e2', '')  # 2 digits significant\n6.0e+3\n>>> Float('60e2', '')  # 4 digits significant\n6000.\n>>> Float('600e-2', '')  # 3 digits significant\n6.00\n\nNotes\n=====\n\nFloats are inexact by their nature unless their value is a binary-exact\nvalue.\n\n>>> approx, exact = Float(.1, 1), Float(.125, 1)\n\nFor calculation purposes, evalf needs to be able to change the precision\nbut this will not increase the accuracy of the inexact value. The\nfollowing is the most accurate 5-digit approximation of a value of 0.1\nthat had only 1 digit of precision:\n\n>>> approx.evalf(5)\n0.099609\n\nBy contrast, 0.125 is exact in binary (as it is in base 10) and so it\ncan be passed to Float or evalf to obtain an arbitrary precision with\nmatching accuracy:\n\n>>> Float(exact, 5)\n0.12500\n>>> exact.evalf(20)\n0.12500000000000000000\n\nTrying to make a high-precision Float from a float is not disallowed,\nbut one must keep in mind that the *underlying float* (not the apparent\ndecimal value) is being obtained with high precision. For example, 0.3\ndoes not have a finite binary representation. The closest rational is\nthe fraction 5404319552844595/2**54. So if you try to obtain a Float of\n0.3 to 20 digits of precision you will not see the same thing as 0.3\nfollowed by 19 zeros:\n\n>>> Float(0.3, 20)\n0.29999999999999998890\n\nIf you want a 20-digit value of the decimal 0.3 (not the floating point\napproximation of 0.3) you should send the 0.3 as a string. The underlying\nrepresentation is still binary but a higher precision than Python's float\nis used:\n\n>>> Float('0.3', 20)\n0.30000000000000000000\n\nAlthough you can increase the precision of an existing Float using Float\nit will not increase the accuracy -- the underlying value is not changed:\n\n>>> def show(f): # binary rep of Float\n...     from sympy import Mul, Pow\n...     s, m, e, b = f._mpf_\n...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)\n...     print('%s at prec=%s' % (v, f._prec))\n...\n>>> t = Float('0.3', 3)\n>>> show(t)\n4915/2**14 at prec=13\n>>> show(Float(t, 20)) # higher prec, not higher accuracy\n4915/2**14 at prec=70\n>>> show(Float(t, 2)) # lower prec\n307/2**10 at prec=10\n\nThe same thing happens when evalf is used on a Float:\n\n>>> show(t.evalf(20))\n4915/2**14 at prec=70\n>>> show(t.evalf(2))\n307/2**10 at prec=10\n\nFinally, Floats can be instantiated with an mpf tuple (n, c, p) to\nproduce the number (-1)**n*c*2**p:\n\n>>> n, c, p = 1, 5, 0\n>>> (-1)**n*c*2**p\n-5\n>>> Float((1, 5, 0))\n-5.00000000000000\n\nAn actual mpf tuple also contains the number of bits in c as the last\nelement of the tuple:\n\n>>> _._mpf_\n(1, 5, 0, 3)\n\nThis is not needed for instantiation and is not the same thing as the\nprecision. The mpf tuple and the precision are two separate quantities\nthat Float tracks.\n\nIn SymPy, a Float is a number that can be computed with arbitrary\nprecision. Although floating point 'inf' and 'nan' are not such\nnumbers, Float can create these numbers:\n\n>>> Float('-inf')\n-oo\n>>> _.is_Float\nFalse\n\nZero in Float only has a single value. Values are not separate for\npositive and negative zeroes.",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, rational=True, **kwargs)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "KEYWORD_ONLY",
                "default": "True",
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Function": {
        "full_name": "sympy.core.Function",
        "bases": [
          "Application",
          "Expr"
        ],
        "doc": "Base class for applied mathematical functions.\n\nIt also serves as a constructor for undefined function classes.\n\nSee the :ref:`custom-functions` guide for details on how to subclass\n``Function`` and what methods can be defined.\n\nExamples\n========\n\n**Undefined Functions**\n\nTo create an undefined function, pass a string of the function name to\n``Function``.\n\n>>> from sympy import Function, Symbol\n>>> x = Symbol('x')\n>>> f = Function('f')\n>>> g = Function('g')(x)\n>>> f\nf\n>>> f(x)\nf(x)\n>>> g\ng(x)\n>>> f(x).diff(x)\nDerivative(f(x), x)\n>>> g.diff(x)\nDerivative(g(x), x)\n\nAssumptions can be passed to ``Function`` the same as with a\n:class:`~.Symbol`. Alternatively, you can use a ``Symbol`` with\nassumptions for the function name and the function will inherit the name\nand assumptions associated with the ``Symbol``:\n\n>>> f_real = Function('f', real=True)\n>>> f_real(x).is_real\nTrue\n>>> f_real_inherit = Function(Symbol('f', real=True))\n>>> f_real_inherit(x).is_real\nTrue\n\nNote that assumptions on a function are unrelated to the assumptions on\nthe variables it is called on. If you want to add a relationship, subclass\n``Function`` and define custom assumptions handler methods. See the\n:ref:`custom-functions-assumptions` section of the :ref:`custom-functions`\nguide for more details.\n\n**Custom Function Subclasses**\n\nThe :ref:`custom-functions` guide has several\n:ref:`custom-functions-complete-examples` of how to subclass ``Function``\nto create a custom function.",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "FunctionClass": {
        "full_name": "sympy.core.FunctionClass",
        "bases": [
          "type"
        ],
        "doc": "Base class for function classes. FunctionClass is a subclass of type.\n\nUse Function('<function name>' [ , signature ]) to create\nundefined function classes.",
        "methods": {},
        "properties": {}
      },
      "Ge": {
        "full_name": "sympy.core.Ge",
        "bases": [
          "_Greater"
        ],
        "doc": "Class representations of inequalities.\n\nExplanation\n===========\n\nThe ``*Than`` classes represent inequal relationships, where the left-hand\nside is generally bigger or smaller than the right-hand side.  For example,\nthe GreaterThan class represents an inequal relationship where the\nleft-hand side is at least as big as the right side, if not bigger.  In\nmathematical notation:\n\nlhs $\\ge$ rhs\n\nIn total, there are four ``*Than`` classes, to represent the four\ninequalities:\n\n+-----------------+--------+\n|Class Name       | Symbol |\n+=================+========+\n|GreaterThan      | ``>=`` |\n+-----------------+--------+\n|LessThan         | ``<=`` |\n+-----------------+--------+\n|StrictGreaterThan| ``>``  |\n+-----------------+--------+\n|StrictLessThan   | ``<``  |\n+-----------------+--------+\n\nAll classes take two arguments, lhs and rhs.\n\n+----------------------------+-----------------+\n|Signature Example           | Math Equivalent |\n+============================+=================+\n|GreaterThan(lhs, rhs)       |   lhs $\\ge$ rhs |\n+----------------------------+-----------------+\n|LessThan(lhs, rhs)          |   lhs $\\le$ rhs |\n+----------------------------+-----------------+\n|StrictGreaterThan(lhs, rhs) |   lhs $>$ rhs   |\n+----------------------------+-----------------+\n|StrictLessThan(lhs, rhs)    |   lhs $<$ rhs   |\n+----------------------------+-----------------+\n\nIn addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality\nobjects also have the .lts and .gts properties, which represent the \"less\nthan side\" and \"greater than side\" of the operator.  Use of .lts and .gts\nin an algorithm rather than .lhs and .rhs as an assumption of inequality\ndirection will make more explicit the intent of a certain section of code,\nand will make it similarly more robust to client code changes:\n\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational\n\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x'\n\nExamples\n========\n\nOne generally does not instantiate these classes directly, but uses various\nconvenience methods:\n\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2\n\nAnother option is to use the Python inequality operators (``>=``, ``>``,\n``<=``, ``<``) directly.  Their main advantage over the ``Ge``, ``Gt``,\n``Le``, and ``Lt`` counterparts, is that one can write a more\n\"mathematical looking\" statement rather than littering the math with\noddball function calls.  However there are certain (minor) caveats of\nwhich to be aware (search for 'gotcha', below).\n\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue\n\nHowever, it is also perfectly valid to instantiate a ``*Than`` class less\nsuccinctly and less conveniently:\n\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1\n\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1\n\nNotes\n=====\n\nThere are a couple of \"gotchas\" to be aware of when using Python's\noperators.\n\nThe first is that what your write is not always what you get:\n\n    >>> 1 < x\n    x > 1\n\n    Due to the order that Python parses a statement, it may\n    not immediately find two objects comparable.  When ``1 < x``\n    is evaluated, Python recognizes that the number 1 is a native\n    number and that x is *not*.  Because a native Python number does\n    not know how to compare itself with a SymPy object\n    Python will try the reflective operation, ``x > 1`` and that is the\n    form that gets evaluated, hence returned.\n\n    If the order of the statement is important (for visual output to\n    the console, perhaps), one can work around this annoyance in a\n    couple ways:\n\n    (1) \"sympify\" the literal before comparison\n\n    >>> S(1) < x\n    1 < x\n\n    (2) use one of the wrappers or less succinct methods described\n    above\n\n    >>> Lt(1, x)\n    1 < x\n    >>> Relational(1, x, \"<\")\n    1 < x\n\nThe second gotcha involves writing equality tests between relationals\nwhen one or both sides of the test involve a literal relational:\n\n    >>> e = x < 1; e\n    x < 1\n    >>> e == e  # neither side is a literal\n    True\n    >>> e == x < 1  # expecting True, too\n    False\n    >>> e != x < 1  # expecting False\n    x < 1\n    >>> x < 1 != x < 1  # expecting False or the same thing as before\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n    The solution for this case is to wrap literal relationals in\n    parentheses:\n\n    >>> e == (x < 1)\n    True\n    >>> e != (x < 1)\n    False\n    >>> (x < 1) != (x < 1)\n    False\n\nThe third gotcha involves chained inequalities not involving\n``==`` or ``!=``. Occasionally, one may be tempted to write:\n\n    >>> e = x < y < z\n    Traceback (most recent call last):\n    ...\n    TypeError: symbolic boolean expression has no truth value.\n\n    Due to an implementation detail or decision of Python [1]_,\n    there is no way for SymPy to create a chained inequality with\n    that syntax so one must use And:\n\n    >>> e = And(x < y, y < z)\n    >>> type( e )\n    And\n    >>> e\n    (x < y) & (y < z)\n\n    Although this can also be done with the '&' operator, it cannot\n    be done with the 'and' operarator:\n\n    >>> (x < y) & (y < z)\n    (x < y) & (y < z)\n    >>> (x < y) and (y < z)\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n.. [1] This implementation detail is that Python provides no reliable\n   method to determine that a chained inequality is being built.\n   Chained comparison operators are evaluated pairwise, using \"and\"\n   logic (see\n   https://docs.python.org/3/reference/expressions.html#not-in). This\n   is done in an efficient way, so that each object being compared\n   is only evaluated once and the comparison can short-circuit. For\n   example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2\n   > 3)``. The ``and`` operator coerces each side into a bool,\n   returning the object itself when it short-circuits. The bool of\n   the --Than operators will raise TypeError on purpose, because\n   SymPy cannot determine the mathematical ordering of symbolic\n   expressions. Thus, if we were to compute ``x > y > z``, with\n   ``x``, ``y``, and ``z`` being Symbols, Python converts the\n   statement (roughly) into these steps:\n\n    (1) x > y > z\n    (2) (x > y) and (y > z)\n    (3) (GreaterThanObject) and (y > z)\n    (4) (GreaterThanObject.__bool__()) and (y > z)\n    (5) TypeError\n\n   Because of the ``and`` added at step 2, the statement gets turned into a\n   weak ternary statement, and the first object's ``__bool__`` method will\n   raise TypeError.  Thus, creating a chained inequality is not possible.\n\n       In Python, there is no way to override the ``and`` operator, or to\n       control how it short circuits, so it is impossible to make something\n       like ``x > y > z`` work.  There was a PEP to change this,\n       :pep:`335`, but it was officially closed in March, 2012.",
        "methods": {
          "as_content_primitive": {
            "doc": "A stub to allow Basic args (like Tuple) to be skipped when computing\nthe content and primitive components of an expression.\n\nSee Also\n========\n\nsympy.core.expr.Expr.as_content_primitive",
            "signature": "(self, radical=False, clear=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "radical": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "clear": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_dummy": {
            "doc": "Return the expression with any objects having structurally\nbound symbols replaced with unique, canonical symbols within\nthe object in which they appear and having only the default\nassumption for commutativity being True. When applied to a\nsymbol a new symbol having only the same commutativity will be\nreturned.\n\nExamples\n========\n\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r\n\nNotes\n=====\n\nAny object that has structurally bound variables should have\na property, ``bound_symbols`` that returns those symbols\nappearing in the object.",
            "signature": "(self) -> \"'Self'\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "'Self'"
          },
          "as_set": {
            "doc": "Rewrites Boolean expression in terms of real sets.\n\nExamples\n========\n\n>>> from sympy import Symbol, Eq, Or, And\n>>> x = Symbol('x', real=True)\n>>> Eq(x, 0).as_set()\n{0}\n>>> (x > 0).as_set()\nInterval.open(0, oo)\n>>> And(-2 < x, x < 2).as_set()\nInterval.open(-2, 2)\n>>> Or(x < -2, 2 < x).as_set()\nUnion(Interval.open(-oo, -2), Interval.open(2, oo))",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "atoms": {
            "doc": "Returns the atoms that form the current object.\n\nBy default, only objects that are truly atomic and cannot\nbe divided into smaller pieces are returned: symbols, numbers,\nand number symbols like I and pi. It is possible to request\natoms of any type, however, as demonstrated below.\n\nExamples\n========\n\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y}\n\nIf one or more types are given, the results will contain only\nthose types of atoms.\n\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi}\n\nNote that I (imaginary unit) and zoo (complex infinity) are special\ntypes of number symbols and are not part of the NumberSymbol class.\n\nThe type can be given implicitly, too:\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y}\n\nBe careful to check your assumptions when using the implicit option\nsince ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\nof SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\nintegers in an expression:\n\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2}\n\nFinally, arguments to atoms() can select more than atomic atoms: any\nSymPy type (loaded in core/__init__.py) can be listed as an argument\nand those types of \"atoms\" as found in scanning the arguments of the\nexpression recursively:\n\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)}",
            "signature": "(self, *types: 'Tbasic | type[Tbasic]') -> 'set[Basic] | set[Tbasic]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "types": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": "Tbasic | type[Tbasic]"
              }
            },
            "return_annotation": "set[Basic] | set[Tbasic]"
          },
          "class_key": {
            "doc": "Nice order of classes.",
            "signature": "() -> 'tuple[int, int, str]'",
            "parameters": {},
            "return_annotation": "tuple[int, int, str]"
          },
          "compare": {
            "doc": "Return -1, 0, 1 if the object is less than, equal,\nor greater than other in a canonical sense.\nNon-Basic are always greater than Basic.\nIf both names of the classes being compared appear\nin the `ordering_of_classes` then the ordering will\ndepend on the appearance of the names there.\nIf either does not appear in that list, then the\ncomparison is based on the class name.\nIf the names are the same then a comparison is made\non the length of the hashable content.\nItems of the equal-lengthed contents are then\nsuccessively compared using the same rules. If there\nis never a difference then 0 is returned.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1",
            "signature": "(self, other)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "other": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "copy": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "could_extract_minus_sign": {
            "doc": "",
            "signature": "(self) -> 'bool'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "bool"
          },
          "count": {
            "doc": "Count the number of matching subexpressions.",
            "signature": "(self, query)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "query": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "count_ops": {
            "doc": "Wrapper for count_ops that returns the operation count.",
            "signature": "(self, visual=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "visual": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "GreaterThan": {
        "full_name": "sympy.core.GreaterThan",
        "bases": [
          "_Greater"
        ],
        "doc": "Class representations of inequalities.\n\nExplanation\n===========\n\nThe ``*Than`` classes represent inequal relationships, where the left-hand\nside is generally bigger or smaller than the right-hand side.  For example,\nthe GreaterThan class represents an inequal relationship where the\nleft-hand side is at least as big as the right side, if not bigger.  In\nmathematical notation:\n\nlhs $\\ge$ rhs\n\nIn total, there are four ``*Than`` classes, to represent the four\ninequalities:\n\n+-----------------+--------+\n|Class Name       | Symbol |\n+=================+========+\n|GreaterThan      | ``>=`` |\n+-----------------+--------+\n|LessThan         | ``<=`` |\n+-----------------+--------+\n|StrictGreaterThan| ``>``  |\n+-----------------+--------+\n|StrictLessThan   | ``<``  |\n+-----------------+--------+\n\nAll classes take two arguments, lhs and rhs.\n\n+----------------------------+-----------------+\n|Signature Example           | Math Equivalent |\n+============================+=================+\n|GreaterThan(lhs, rhs)       |   lhs $\\ge$ rhs |\n+----------------------------+-----------------+\n|LessThan(lhs, rhs)          |   lhs $\\le$ rhs |\n+----------------------------+-----------------+\n|StrictGreaterThan(lhs, rhs) |   lhs $>$ rhs   |\n+----------------------------+-----------------+\n|StrictLessThan(lhs, rhs)    |   lhs $<$ rhs   |\n+----------------------------+-----------------+\n\nIn addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality\nobjects also have the .lts and .gts properties, which represent the \"less\nthan side\" and \"greater than side\" of the operator.  Use of .lts and .gts\nin an algorithm rather than .lhs and .rhs as an assumption of inequality\ndirection will make more explicit the intent of a certain section of code,\nand will make it similarly more robust to client code changes:\n\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational\n\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x'\n\nExamples\n========\n\nOne generally does not instantiate these classes directly, but uses various\nconvenience methods:\n\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2\n\nAnother option is to use the Python inequality operators (``>=``, ``>``,\n``<=``, ``<``) directly.  Their main advantage over the ``Ge``, ``Gt``,\n``Le``, and ``Lt`` counterparts, is that one can write a more\n\"mathematical looking\" statement rather than littering the math with\noddball function calls.  However there are certain (minor) caveats of\nwhich to be aware (search for 'gotcha', below).\n\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue\n\nHowever, it is also perfectly valid to instantiate a ``*Than`` class less\nsuccinctly and less conveniently:\n\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1\n\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1\n\nNotes\n=====\n\nThere are a couple of \"gotchas\" to be aware of when using Python's\noperators.\n\nThe first is that what your write is not always what you get:\n\n    >>> 1 < x\n    x > 1\n\n    Due to the order that Python parses a statement, it may\n    not immediately find two objects comparable.  When ``1 < x``\n    is evaluated, Python recognizes that the number 1 is a native\n    number and that x is *not*.  Because a native Python number does\n    not know how to compare itself with a SymPy object\n    Python will try the reflective operation, ``x > 1`` and that is the\n    form that gets evaluated, hence returned.\n\n    If the order of the statement is important (for visual output to\n    the console, perhaps), one can work around this annoyance in a\n    couple ways:\n\n    (1) \"sympify\" the literal before comparison\n\n    >>> S(1) < x\n    1 < x\n\n    (2) use one of the wrappers or less succinct methods described\n    above\n\n    >>> Lt(1, x)\n    1 < x\n    >>> Relational(1, x, \"<\")\n    1 < x\n\nThe second gotcha involves writing equality tests between relationals\nwhen one or both sides of the test involve a literal relational:\n\n    >>> e = x < 1; e\n    x < 1\n    >>> e == e  # neither side is a literal\n    True\n    >>> e == x < 1  # expecting True, too\n    False\n    >>> e != x < 1  # expecting False\n    x < 1\n    >>> x < 1 != x < 1  # expecting False or the same thing as before\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n    The solution for this case is to wrap literal relationals in\n    parentheses:\n\n    >>> e == (x < 1)\n    True\n    >>> e != (x < 1)\n    False\n    >>> (x < 1) != (x < 1)\n    False\n\nThe third gotcha involves chained inequalities not involving\n``==`` or ``!=``. Occasionally, one may be tempted to write:\n\n    >>> e = x < y < z\n    Traceback (most recent call last):\n    ...\n    TypeError: symbolic boolean expression has no truth value.\n\n    Due to an implementation detail or decision of Python [1]_,\n    there is no way for SymPy to create a chained inequality with\n    that syntax so one must use And:\n\n    >>> e = And(x < y, y < z)\n    >>> type( e )\n    And\n    >>> e\n    (x < y) & (y < z)\n\n    Although this can also be done with the '&' operator, it cannot\n    be done with the 'and' operarator:\n\n    >>> (x < y) & (y < z)\n    (x < y) & (y < z)\n    >>> (x < y) and (y < z)\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n.. [1] This implementation detail is that Python provides no reliable\n   method to determine that a chained inequality is being built.\n   Chained comparison operators are evaluated pairwise, using \"and\"\n   logic (see\n   https://docs.python.org/3/reference/expressions.html#not-in). This\n   is done in an efficient way, so that each object being compared\n   is only evaluated once and the comparison can short-circuit. For\n   example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2\n   > 3)``. The ``and`` operator coerces each side into a bool,\n   returning the object itself when it short-circuits. The bool of\n   the --Than operators will raise TypeError on purpose, because\n   SymPy cannot determine the mathematical ordering of symbolic\n   expressions. Thus, if we were to compute ``x > y > z``, with\n   ``x``, ``y``, and ``z`` being Symbols, Python converts the\n   statement (roughly) into these steps:\n\n    (1) x > y > z\n    (2) (x > y) and (y > z)\n    (3) (GreaterThanObject) and (y > z)\n    (4) (GreaterThanObject.__bool__()) and (y > z)\n    (5) TypeError\n\n   Because of the ``and`` added at step 2, the statement gets turned into a\n   weak ternary statement, and the first object's ``__bool__`` method will\n   raise TypeError.  Thus, creating a chained inequality is not possible.\n\n       In Python, there is no way to override the ``and`` operator, or to\n       control how it short circuits, so it is impossible to make something\n       like ``x > y > z`` work.  There was a PEP to change this,\n       :pep:`335`, but it was officially closed in March, 2012.",
        "methods": {
          "as_content_primitive": {
            "doc": "A stub to allow Basic args (like Tuple) to be skipped when computing\nthe content and primitive components of an expression.\n\nSee Also\n========\n\nsympy.core.expr.Expr.as_content_primitive",
            "signature": "(self, radical=False, clear=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "radical": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "clear": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_dummy": {
            "doc": "Return the expression with any objects having structurally\nbound symbols replaced with unique, canonical symbols within\nthe object in which they appear and having only the default\nassumption for commutativity being True. When applied to a\nsymbol a new symbol having only the same commutativity will be\nreturned.\n\nExamples\n========\n\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r\n\nNotes\n=====\n\nAny object that has structurally bound variables should have\na property, ``bound_symbols`` that returns those symbols\nappearing in the object.",
            "signature": "(self) -> \"'Self'\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "'Self'"
          },
          "as_set": {
            "doc": "Rewrites Boolean expression in terms of real sets.\n\nExamples\n========\n\n>>> from sympy import Symbol, Eq, Or, And\n>>> x = Symbol('x', real=True)\n>>> Eq(x, 0).as_set()\n{0}\n>>> (x > 0).as_set()\nInterval.open(0, oo)\n>>> And(-2 < x, x < 2).as_set()\nInterval.open(-2, 2)\n>>> Or(x < -2, 2 < x).as_set()\nUnion(Interval.open(-oo, -2), Interval.open(2, oo))",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "atoms": {
            "doc": "Returns the atoms that form the current object.\n\nBy default, only objects that are truly atomic and cannot\nbe divided into smaller pieces are returned: symbols, numbers,\nand number symbols like I and pi. It is possible to request\natoms of any type, however, as demonstrated below.\n\nExamples\n========\n\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y}\n\nIf one or more types are given, the results will contain only\nthose types of atoms.\n\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi}\n\nNote that I (imaginary unit) and zoo (complex infinity) are special\ntypes of number symbols and are not part of the NumberSymbol class.\n\nThe type can be given implicitly, too:\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y}\n\nBe careful to check your assumptions when using the implicit option\nsince ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\nof SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\nintegers in an expression:\n\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2}\n\nFinally, arguments to atoms() can select more than atomic atoms: any\nSymPy type (loaded in core/__init__.py) can be listed as an argument\nand those types of \"atoms\" as found in scanning the arguments of the\nexpression recursively:\n\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)}",
            "signature": "(self, *types: 'Tbasic | type[Tbasic]') -> 'set[Basic] | set[Tbasic]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "types": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": "Tbasic | type[Tbasic]"
              }
            },
            "return_annotation": "set[Basic] | set[Tbasic]"
          },
          "class_key": {
            "doc": "Nice order of classes.",
            "signature": "() -> 'tuple[int, int, str]'",
            "parameters": {},
            "return_annotation": "tuple[int, int, str]"
          },
          "compare": {
            "doc": "Return -1, 0, 1 if the object is less than, equal,\nor greater than other in a canonical sense.\nNon-Basic are always greater than Basic.\nIf both names of the classes being compared appear\nin the `ordering_of_classes` then the ordering will\ndepend on the appearance of the names there.\nIf either does not appear in that list, then the\ncomparison is based on the class name.\nIf the names are the same then a comparison is made\non the length of the hashable content.\nItems of the equal-lengthed contents are then\nsuccessively compared using the same rules. If there\nis never a difference then 0 is returned.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1",
            "signature": "(self, other)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "other": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "copy": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "could_extract_minus_sign": {
            "doc": "",
            "signature": "(self) -> 'bool'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "bool"
          },
          "count": {
            "doc": "Count the number of matching subexpressions.",
            "signature": "(self, query)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "query": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "count_ops": {
            "doc": "Wrapper for count_ops that returns the operation count.",
            "signature": "(self, visual=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "visual": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "Gt": {
        "full_name": "sympy.core.Gt",
        "bases": [
          "_Greater"
        ],
        "doc": "Class representations of inequalities.\n\nExplanation\n===========\n\nThe ``*Than`` classes represent inequal relationships, where the left-hand\nside is generally bigger or smaller than the right-hand side.  For example,\nthe GreaterThan class represents an inequal relationship where the\nleft-hand side is at least as big as the right side, if not bigger.  In\nmathematical notation:\n\nlhs $\\ge$ rhs\n\nIn total, there are four ``*Than`` classes, to represent the four\ninequalities:\n\n+-----------------+--------+\n|Class Name       | Symbol |\n+=================+========+\n|GreaterThan      | ``>=`` |\n+-----------------+--------+\n|LessThan         | ``<=`` |\n+-----------------+--------+\n|StrictGreaterThan| ``>``  |\n+-----------------+--------+\n|StrictLessThan   | ``<``  |\n+-----------------+--------+\n\nAll classes take two arguments, lhs and rhs.\n\n+----------------------------+-----------------+\n|Signature Example           | Math Equivalent |\n+============================+=================+\n|GreaterThan(lhs, rhs)       |   lhs $\\ge$ rhs |\n+----------------------------+-----------------+\n|LessThan(lhs, rhs)          |   lhs $\\le$ rhs |\n+----------------------------+-----------------+\n|StrictGreaterThan(lhs, rhs) |   lhs $>$ rhs   |\n+----------------------------+-----------------+\n|StrictLessThan(lhs, rhs)    |   lhs $<$ rhs   |\n+----------------------------+-----------------+\n\nIn addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality\nobjects also have the .lts and .gts properties, which represent the \"less\nthan side\" and \"greater than side\" of the operator.  Use of .lts and .gts\nin an algorithm rather than .lhs and .rhs as an assumption of inequality\ndirection will make more explicit the intent of a certain section of code,\nand will make it similarly more robust to client code changes:\n\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational\n\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x'\n\nExamples\n========\n\nOne generally does not instantiate these classes directly, but uses various\nconvenience methods:\n\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2\n\nAnother option is to use the Python inequality operators (``>=``, ``>``,\n``<=``, ``<``) directly.  Their main advantage over the ``Ge``, ``Gt``,\n``Le``, and ``Lt`` counterparts, is that one can write a more\n\"mathematical looking\" statement rather than littering the math with\noddball function calls.  However there are certain (minor) caveats of\nwhich to be aware (search for 'gotcha', below).\n\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue\n\nHowever, it is also perfectly valid to instantiate a ``*Than`` class less\nsuccinctly and less conveniently:\n\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1\n\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1\n\nNotes\n=====\n\nThere are a couple of \"gotchas\" to be aware of when using Python's\noperators.\n\nThe first is that what your write is not always what you get:\n\n    >>> 1 < x\n    x > 1\n\n    Due to the order that Python parses a statement, it may\n    not immediately find two objects comparable.  When ``1 < x``\n    is evaluated, Python recognizes that the number 1 is a native\n    number and that x is *not*.  Because a native Python number does\n    not know how to compare itself with a SymPy object\n    Python will try the reflective operation, ``x > 1`` and that is the\n    form that gets evaluated, hence returned.\n\n    If the order of the statement is important (for visual output to\n    the console, perhaps), one can work around this annoyance in a\n    couple ways:\n\n    (1) \"sympify\" the literal before comparison\n\n    >>> S(1) < x\n    1 < x\n\n    (2) use one of the wrappers or less succinct methods described\n    above\n\n    >>> Lt(1, x)\n    1 < x\n    >>> Relational(1, x, \"<\")\n    1 < x\n\nThe second gotcha involves writing equality tests between relationals\nwhen one or both sides of the test involve a literal relational:\n\n    >>> e = x < 1; e\n    x < 1\n    >>> e == e  # neither side is a literal\n    True\n    >>> e == x < 1  # expecting True, too\n    False\n    >>> e != x < 1  # expecting False\n    x < 1\n    >>> x < 1 != x < 1  # expecting False or the same thing as before\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n    The solution for this case is to wrap literal relationals in\n    parentheses:\n\n    >>> e == (x < 1)\n    True\n    >>> e != (x < 1)\n    False\n    >>> (x < 1) != (x < 1)\n    False\n\nThe third gotcha involves chained inequalities not involving\n``==`` or ``!=``. Occasionally, one may be tempted to write:\n\n    >>> e = x < y < z\n    Traceback (most recent call last):\n    ...\n    TypeError: symbolic boolean expression has no truth value.\n\n    Due to an implementation detail or decision of Python [1]_,\n    there is no way for SymPy to create a chained inequality with\n    that syntax so one must use And:\n\n    >>> e = And(x < y, y < z)\n    >>> type( e )\n    And\n    >>> e\n    (x < y) & (y < z)\n\n    Although this can also be done with the '&' operator, it cannot\n    be done with the 'and' operarator:\n\n    >>> (x < y) & (y < z)\n    (x < y) & (y < z)\n    >>> (x < y) and (y < z)\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n.. [1] This implementation detail is that Python provides no reliable\n   method to determine that a chained inequality is being built.\n   Chained comparison operators are evaluated pairwise, using \"and\"\n   logic (see\n   https://docs.python.org/3/reference/expressions.html#not-in). This\n   is done in an efficient way, so that each object being compared\n   is only evaluated once and the comparison can short-circuit. For\n   example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2\n   > 3)``. The ``and`` operator coerces each side into a bool,\n   returning the object itself when it short-circuits. The bool of\n   the --Than operators will raise TypeError on purpose, because\n   SymPy cannot determine the mathematical ordering of symbolic\n   expressions. Thus, if we were to compute ``x > y > z``, with\n   ``x``, ``y``, and ``z`` being Symbols, Python converts the\n   statement (roughly) into these steps:\n\n    (1) x > y > z\n    (2) (x > y) and (y > z)\n    (3) (GreaterThanObject) and (y > z)\n    (4) (GreaterThanObject.__bool__()) and (y > z)\n    (5) TypeError\n\n   Because of the ``and`` added at step 2, the statement gets turned into a\n   weak ternary statement, and the first object's ``__bool__`` method will\n   raise TypeError.  Thus, creating a chained inequality is not possible.\n\n       In Python, there is no way to override the ``and`` operator, or to\n       control how it short circuits, so it is impossible to make something\n       like ``x > y > z`` work.  There was a PEP to change this,\n       :pep:`335`, but it was officially closed in March, 2012.",
        "methods": {
          "as_content_primitive": {
            "doc": "A stub to allow Basic args (like Tuple) to be skipped when computing\nthe content and primitive components of an expression.\n\nSee Also\n========\n\nsympy.core.expr.Expr.as_content_primitive",
            "signature": "(self, radical=False, clear=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "radical": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "clear": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_dummy": {
            "doc": "Return the expression with any objects having structurally\nbound symbols replaced with unique, canonical symbols within\nthe object in which they appear and having only the default\nassumption for commutativity being True. When applied to a\nsymbol a new symbol having only the same commutativity will be\nreturned.\n\nExamples\n========\n\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r\n\nNotes\n=====\n\nAny object that has structurally bound variables should have\na property, ``bound_symbols`` that returns those symbols\nappearing in the object.",
            "signature": "(self) -> \"'Self'\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "'Self'"
          },
          "as_set": {
            "doc": "Rewrites Boolean expression in terms of real sets.\n\nExamples\n========\n\n>>> from sympy import Symbol, Eq, Or, And\n>>> x = Symbol('x', real=True)\n>>> Eq(x, 0).as_set()\n{0}\n>>> (x > 0).as_set()\nInterval.open(0, oo)\n>>> And(-2 < x, x < 2).as_set()\nInterval.open(-2, 2)\n>>> Or(x < -2, 2 < x).as_set()\nUnion(Interval.open(-oo, -2), Interval.open(2, oo))",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "atoms": {
            "doc": "Returns the atoms that form the current object.\n\nBy default, only objects that are truly atomic and cannot\nbe divided into smaller pieces are returned: symbols, numbers,\nand number symbols like I and pi. It is possible to request\natoms of any type, however, as demonstrated below.\n\nExamples\n========\n\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y}\n\nIf one or more types are given, the results will contain only\nthose types of atoms.\n\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi}\n\nNote that I (imaginary unit) and zoo (complex infinity) are special\ntypes of number symbols and are not part of the NumberSymbol class.\n\nThe type can be given implicitly, too:\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y}\n\nBe careful to check your assumptions when using the implicit option\nsince ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\nof SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\nintegers in an expression:\n\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2}\n\nFinally, arguments to atoms() can select more than atomic atoms: any\nSymPy type (loaded in core/__init__.py) can be listed as an argument\nand those types of \"atoms\" as found in scanning the arguments of the\nexpression recursively:\n\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)}",
            "signature": "(self, *types: 'Tbasic | type[Tbasic]') -> 'set[Basic] | set[Tbasic]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "types": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": "Tbasic | type[Tbasic]"
              }
            },
            "return_annotation": "set[Basic] | set[Tbasic]"
          },
          "class_key": {
            "doc": "Nice order of classes.",
            "signature": "() -> 'tuple[int, int, str]'",
            "parameters": {},
            "return_annotation": "tuple[int, int, str]"
          },
          "compare": {
            "doc": "Return -1, 0, 1 if the object is less than, equal,\nor greater than other in a canonical sense.\nNon-Basic are always greater than Basic.\nIf both names of the classes being compared appear\nin the `ordering_of_classes` then the ordering will\ndepend on the appearance of the names there.\nIf either does not appear in that list, then the\ncomparison is based on the class name.\nIf the names are the same then a comparison is made\non the length of the hashable content.\nItems of the equal-lengthed contents are then\nsuccessively compared using the same rules. If there\nis never a difference then 0 is returned.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1",
            "signature": "(self, other)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "other": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "copy": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "could_extract_minus_sign": {
            "doc": "",
            "signature": "(self) -> 'bool'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "bool"
          },
          "count": {
            "doc": "Count the number of matching subexpressions.",
            "signature": "(self, query)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "query": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "count_ops": {
            "doc": "Wrapper for count_ops that returns the operation count.",
            "signature": "(self, visual=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "visual": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "Integer": {
        "full_name": "sympy.core.Integer",
        "bases": [
          "Rational"
        ],
        "doc": "Represents integer numbers of any size.\n\nExamples\n========\n\n>>> from sympy import Integer\n>>> Integer(3)\n3\n\nIf a float or a rational is passed to Integer, the fractional part\nwill be discarded; the effect is of rounding toward zero.\n\n>>> Integer(3.8)\n3\n>>> Integer(-3.8)\n-3\n\nA string is acceptable input if it can be parsed as an integer:\n\n>>> Integer(\"9\" * 20)\n99999999999999999999\n\nIt is rarely needed to explicitly instantiate an Integer, because\nPython integers are automatically converted to Integer when they\nare used in SymPy expressions.",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, rational=True, **kwargs)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "KEYWORD_ONLY",
                "default": "True",
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Lambda": {
        "full_name": "sympy.core.Lambda",
        "bases": [
          "Expr"
        ],
        "doc": "Lambda(x, expr) represents a lambda function similar to Python's\n'lambda x: expr'. A function of several variables is written as\nLambda((x, y, ...), expr).\n\nExamples\n========\n\nA simple example:\n\n>>> from sympy import Lambda\n>>> from sympy.abc import x\n>>> f = Lambda(x, x**2)\n>>> f(4)\n16\n\nFor multivariate functions, use:\n\n>>> from sympy.abc import y, z, t\n>>> f2 = Lambda((x, y, z, t), x + y**z + t**z)\n>>> f2(1, 2, 3, 4)\n73\n\nIt is also possible to unpack tuple arguments:\n\n>>> f = Lambda(((x, y), z), x + y + z)\n>>> f((1, 2), 3)\n6\n\nA handy shortcut for lots of arguments:\n\n>>> p = x, y, z\n>>> f = Lambda(p, x + y*z)\n>>> f(*p)\nx + y*z",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Le": {
        "full_name": "sympy.core.Le",
        "bases": [
          "_Less"
        ],
        "doc": "Class representations of inequalities.\n\nExplanation\n===========\n\nThe ``*Than`` classes represent inequal relationships, where the left-hand\nside is generally bigger or smaller than the right-hand side.  For example,\nthe GreaterThan class represents an inequal relationship where the\nleft-hand side is at least as big as the right side, if not bigger.  In\nmathematical notation:\n\nlhs $\\ge$ rhs\n\nIn total, there are four ``*Than`` classes, to represent the four\ninequalities:\n\n+-----------------+--------+\n|Class Name       | Symbol |\n+=================+========+\n|GreaterThan      | ``>=`` |\n+-----------------+--------+\n|LessThan         | ``<=`` |\n+-----------------+--------+\n|StrictGreaterThan| ``>``  |\n+-----------------+--------+\n|StrictLessThan   | ``<``  |\n+-----------------+--------+\n\nAll classes take two arguments, lhs and rhs.\n\n+----------------------------+-----------------+\n|Signature Example           | Math Equivalent |\n+============================+=================+\n|GreaterThan(lhs, rhs)       |   lhs $\\ge$ rhs |\n+----------------------------+-----------------+\n|LessThan(lhs, rhs)          |   lhs $\\le$ rhs |\n+----------------------------+-----------------+\n|StrictGreaterThan(lhs, rhs) |   lhs $>$ rhs   |\n+----------------------------+-----------------+\n|StrictLessThan(lhs, rhs)    |   lhs $<$ rhs   |\n+----------------------------+-----------------+\n\nIn addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality\nobjects also have the .lts and .gts properties, which represent the \"less\nthan side\" and \"greater than side\" of the operator.  Use of .lts and .gts\nin an algorithm rather than .lhs and .rhs as an assumption of inequality\ndirection will make more explicit the intent of a certain section of code,\nand will make it similarly more robust to client code changes:\n\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational\n\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x'\n\nExamples\n========\n\nOne generally does not instantiate these classes directly, but uses various\nconvenience methods:\n\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2\n\nAnother option is to use the Python inequality operators (``>=``, ``>``,\n``<=``, ``<``) directly.  Their main advantage over the ``Ge``, ``Gt``,\n``Le``, and ``Lt`` counterparts, is that one can write a more\n\"mathematical looking\" statement rather than littering the math with\noddball function calls.  However there are certain (minor) caveats of\nwhich to be aware (search for 'gotcha', below).\n\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue\n\nHowever, it is also perfectly valid to instantiate a ``*Than`` class less\nsuccinctly and less conveniently:\n\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1\n\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1\n\nNotes\n=====\n\nThere are a couple of \"gotchas\" to be aware of when using Python's\noperators.\n\nThe first is that what your write is not always what you get:\n\n    >>> 1 < x\n    x > 1\n\n    Due to the order that Python parses a statement, it may\n    not immediately find two objects comparable.  When ``1 < x``\n    is evaluated, Python recognizes that the number 1 is a native\n    number and that x is *not*.  Because a native Python number does\n    not know how to compare itself with a SymPy object\n    Python will try the reflective operation, ``x > 1`` and that is the\n    form that gets evaluated, hence returned.\n\n    If the order of the statement is important (for visual output to\n    the console, perhaps), one can work around this annoyance in a\n    couple ways:\n\n    (1) \"sympify\" the literal before comparison\n\n    >>> S(1) < x\n    1 < x\n\n    (2) use one of the wrappers or less succinct methods described\n    above\n\n    >>> Lt(1, x)\n    1 < x\n    >>> Relational(1, x, \"<\")\n    1 < x\n\nThe second gotcha involves writing equality tests between relationals\nwhen one or both sides of the test involve a literal relational:\n\n    >>> e = x < 1; e\n    x < 1\n    >>> e == e  # neither side is a literal\n    True\n    >>> e == x < 1  # expecting True, too\n    False\n    >>> e != x < 1  # expecting False\n    x < 1\n    >>> x < 1 != x < 1  # expecting False or the same thing as before\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n    The solution for this case is to wrap literal relationals in\n    parentheses:\n\n    >>> e == (x < 1)\n    True\n    >>> e != (x < 1)\n    False\n    >>> (x < 1) != (x < 1)\n    False\n\nThe third gotcha involves chained inequalities not involving\n``==`` or ``!=``. Occasionally, one may be tempted to write:\n\n    >>> e = x < y < z\n    Traceback (most recent call last):\n    ...\n    TypeError: symbolic boolean expression has no truth value.\n\n    Due to an implementation detail or decision of Python [1]_,\n    there is no way for SymPy to create a chained inequality with\n    that syntax so one must use And:\n\n    >>> e = And(x < y, y < z)\n    >>> type( e )\n    And\n    >>> e\n    (x < y) & (y < z)\n\n    Although this can also be done with the '&' operator, it cannot\n    be done with the 'and' operarator:\n\n    >>> (x < y) & (y < z)\n    (x < y) & (y < z)\n    >>> (x < y) and (y < z)\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n.. [1] This implementation detail is that Python provides no reliable\n   method to determine that a chained inequality is being built.\n   Chained comparison operators are evaluated pairwise, using \"and\"\n   logic (see\n   https://docs.python.org/3/reference/expressions.html#not-in). This\n   is done in an efficient way, so that each object being compared\n   is only evaluated once and the comparison can short-circuit. For\n   example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2\n   > 3)``. The ``and`` operator coerces each side into a bool,\n   returning the object itself when it short-circuits. The bool of\n   the --Than operators will raise TypeError on purpose, because\n   SymPy cannot determine the mathematical ordering of symbolic\n   expressions. Thus, if we were to compute ``x > y > z``, with\n   ``x``, ``y``, and ``z`` being Symbols, Python converts the\n   statement (roughly) into these steps:\n\n    (1) x > y > z\n    (2) (x > y) and (y > z)\n    (3) (GreaterThanObject) and (y > z)\n    (4) (GreaterThanObject.__bool__()) and (y > z)\n    (5) TypeError\n\n   Because of the ``and`` added at step 2, the statement gets turned into a\n   weak ternary statement, and the first object's ``__bool__`` method will\n   raise TypeError.  Thus, creating a chained inequality is not possible.\n\n       In Python, there is no way to override the ``and`` operator, or to\n       control how it short circuits, so it is impossible to make something\n       like ``x > y > z`` work.  There was a PEP to change this,\n       :pep:`335`, but it was officially closed in March, 2012.",
        "methods": {
          "as_content_primitive": {
            "doc": "A stub to allow Basic args (like Tuple) to be skipped when computing\nthe content and primitive components of an expression.\n\nSee Also\n========\n\nsympy.core.expr.Expr.as_content_primitive",
            "signature": "(self, radical=False, clear=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "radical": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "clear": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_dummy": {
            "doc": "Return the expression with any objects having structurally\nbound symbols replaced with unique, canonical symbols within\nthe object in which they appear and having only the default\nassumption for commutativity being True. When applied to a\nsymbol a new symbol having only the same commutativity will be\nreturned.\n\nExamples\n========\n\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r\n\nNotes\n=====\n\nAny object that has structurally bound variables should have\na property, ``bound_symbols`` that returns those symbols\nappearing in the object.",
            "signature": "(self) -> \"'Self'\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "'Self'"
          },
          "as_set": {
            "doc": "Rewrites Boolean expression in terms of real sets.\n\nExamples\n========\n\n>>> from sympy import Symbol, Eq, Or, And\n>>> x = Symbol('x', real=True)\n>>> Eq(x, 0).as_set()\n{0}\n>>> (x > 0).as_set()\nInterval.open(0, oo)\n>>> And(-2 < x, x < 2).as_set()\nInterval.open(-2, 2)\n>>> Or(x < -2, 2 < x).as_set()\nUnion(Interval.open(-oo, -2), Interval.open(2, oo))",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "atoms": {
            "doc": "Returns the atoms that form the current object.\n\nBy default, only objects that are truly atomic and cannot\nbe divided into smaller pieces are returned: symbols, numbers,\nand number symbols like I and pi. It is possible to request\natoms of any type, however, as demonstrated below.\n\nExamples\n========\n\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y}\n\nIf one or more types are given, the results will contain only\nthose types of atoms.\n\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi}\n\nNote that I (imaginary unit) and zoo (complex infinity) are special\ntypes of number symbols and are not part of the NumberSymbol class.\n\nThe type can be given implicitly, too:\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y}\n\nBe careful to check your assumptions when using the implicit option\nsince ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\nof SymPy atom, while ``type(S(2))`` is type ``Integer`` and will find all\nintegers in an expression:\n\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2}\n\nFinally, arguments to atoms() can select more than atomic atoms: any\nSymPy type (loaded in core/__init__.py) can be listed as an argument\nand those types of \"atoms\" as found in scanning the arguments of the\nexpression recursively:\n\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)}\n\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)}",
            "signature": "(self, *types: 'Tbasic | type[Tbasic]') -> 'set[Basic] | set[Tbasic]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "types": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": "Tbasic | type[Tbasic]"
              }
            },
            "return_annotation": "set[Basic] | set[Tbasic]"
          },
          "class_key": {
            "doc": "Nice order of classes.",
            "signature": "() -> 'tuple[int, int, str]'",
            "parameters": {},
            "return_annotation": "tuple[int, int, str]"
          },
          "compare": {
            "doc": "Return -1, 0, 1 if the object is less than, equal,\nor greater than other in a canonical sense.\nNon-Basic are always greater than Basic.\nIf both names of the classes being compared appear\nin the `ordering_of_classes` then the ordering will\ndepend on the appearance of the names there.\nIf either does not appear in that list, then the\ncomparison is based on the class name.\nIf the names are the same then a comparison is made\non the length of the hashable content.\nItems of the equal-lengthed contents are then\nsuccessively compared using the same rules. If there\nis never a difference then 0 is returned.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1",
            "signature": "(self, other)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "other": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "copy": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "could_extract_minus_sign": {
            "doc": "",
            "signature": "(self) -> 'bool'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "bool"
          },
          "count": {
            "doc": "Count the number of matching subexpressions.",
            "signature": "(self, query)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "query": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "count_ops": {
            "doc": "Wrapper for count_ops that returns the operation count.",
            "signature": "(self, visual=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "visual": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      }
    },
    "functions": {},
    "constants": {}
  },
  "sympy.functions": {
    "classes": {
      "Abs": {
        "full_name": "sympy.functions.Abs",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "Return the absolute value of the argument.\n\nExplanation\n===========\n\nThis is an extension of the built-in function ``abs()`` to accept symbolic\nvalues.  If you pass a SymPy expression to the built-in ``abs()``, it will\npass it automatically to ``Abs()``.\n\nExamples\n========\n\n>>> from sympy import Abs, Symbol, S, I\n>>> Abs(-1)\n1\n>>> x = Symbol('x', real=True)\n>>> Abs(-x)\nAbs(x)\n>>> Abs(x**2)\nx**2\n>>> abs(-x) # The Python built-in\nAbs(x)\n>>> Abs(3*x + 2*I)\nsqrt(9*x**2 + 4)\n>>> Abs(8*I)\n8\n\nNote that the Python built-in will return either an Expr or int depending on\nthe argument::\n\n    >>> type(abs(-1))\n    <... 'int'>\n    >>> type(abs(S.NegativeOne))\n    <class 'sympy.core.numbers.One'>\n\nAbs will always return a SymPy object.\n\nParameters\n==========\n\narg : Expr\n    Real or complex expression.\n\nReturns\n=======\n\nexpr : Expr\n    Absolute value returned can be an expression or integer depending on\n    input arg.\n\nSee Also\n========\n\nsign, conjugate",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Chi": {
        "full_name": "sympy.functions.Chi",
        "bases": [
          "TrigonometricIntegral"
        ],
        "doc": "Cosh integral.\n\nExplanation\n===========\n\nThis function is defined for positive $x$ by\n\n.. math:: \\operatorname{Chi}(x) = \\gamma + \\log{x}\n                     + \\int_0^x \\frac{\\cosh{t} - 1}{t} \\mathrm{d}t,\n\nwhere $\\gamma$ is the Euler-Mascheroni constant.\n\nWe have\n\n.. math:: \\operatorname{Chi}(z) = \\operatorname{Ci}\\left(e^{i \\pi/2}z\\right)\n                     - i\\frac{\\pi}{2},\n\nwhich holds for all polar $z$ and thus provides an analytic\ncontinuation to the Riemann surface of the logarithm.\nBy lifting to the principal branch we obtain an analytic function on the\ncut complex plane.\n\nExamples\n========\n\n>>> from sympy import Chi\n>>> from sympy.abc import z\n\nThe $\\cosh$ integral is a primitive of $\\cosh(z)/z$:\n\n>>> Chi(z).diff(z)\ncosh(z)/z\n\nIt has a logarithmic branch point at the origin:\n\n>>> from sympy import exp_polar, I, pi\n>>> Chi(z*exp_polar(2*I*pi))\nChi(z) + 2*I*pi\n\nThe $\\cosh$ integral behaves somewhat like ordinary $\\cosh$ under\nmultiplication by $i$:\n\n>>> from sympy import polar_lift\n>>> Chi(polar_lift(I)*z)\nCi(z) + I*pi/2\n>>> Chi(polar_lift(-1)*z)\nChi(z) + I*pi\n\nIt can also be expressed in terms of exponential integrals:\n\n>>> from sympy import expint\n>>> Chi(z).rewrite(expint)\n-expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2\n\nSee Also\n========\n\nSi: Sine integral.\nCi: Cosine integral.\nShi: Hyperbolic sine integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Trigonometric_integral",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Ci": {
        "full_name": "sympy.functions.Ci",
        "bases": [
          "TrigonometricIntegral"
        ],
        "doc": "Cosine integral.\n\nExplanation\n===========\n\nThis function is defined for positive $x$ by\n\n.. math:: \\operatorname{Ci}(x) = \\gamma + \\log{x}\n                     + \\int_0^x \\frac{\\cos{t} - 1}{t} \\mathrm{d}t\n       = -\\int_x^\\infty \\frac{\\cos{t}}{t} \\mathrm{d}t,\n\nwhere $\\gamma$ is the Euler-Mascheroni constant.\n\nWe have\n\n.. math:: \\operatorname{Ci}(z) =\n    -\\frac{\\operatorname{E}_1\\left(e^{i\\pi/2} z\\right)\n           + \\operatorname{E}_1\\left(e^{-i \\pi/2} z\\right)}{2}\n\nwhich holds for all polar $z$ and thus provides an analytic\ncontinuation to the Riemann surface of the logarithm.\n\nThe formula also holds as stated\nfor $z \\in \\mathbb{C}$ with $\\Re(z) > 0$.\nBy lifting to the principal branch, we obtain an analytic function on the\ncut complex plane.\n\nExamples\n========\n\n>>> from sympy import Ci\n>>> from sympy.abc import z\n\nThe cosine integral is a primitive of $\\cos(z)/z$:\n\n>>> Ci(z).diff(z)\ncos(z)/z\n\nIt has a logarithmic branch point at the origin:\n\n>>> from sympy import exp_polar, I, pi\n>>> Ci(z*exp_polar(2*I*pi))\nCi(z) + 2*I*pi\n\nThe cosine integral behaves somewhat like ordinary $\\cos$ under\nmultiplication by $i$:\n\n>>> from sympy import polar_lift\n>>> Ci(polar_lift(I)*z)\nChi(z) + I*pi/2\n>>> Ci(polar_lift(-1)*z)\nCi(z) + I*pi\n\nIt can also be expressed in terms of exponential integrals:\n\n>>> from sympy import expint\n>>> Ci(z).rewrite(expint)\n-expint(1, z*exp_polar(-I*pi/2))/2 - expint(1, z*exp_polar(I*pi/2))/2\n\nSee Also\n========\n\nSi: Sine integral.\nShi: Hyperbolic sine integral.\nChi: Hyperbolic cosine integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Trigonometric_integral",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "DiracDelta": {
        "full_name": "sympy.functions.DiracDelta",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "The DiracDelta function and its derivatives.\n\nExplanation\n===========\n\nDiracDelta is not an ordinary function. It can be rigorously defined either\nas a distribution or as a measure.\n\nDiracDelta only makes sense in definite integrals, and in particular,\nintegrals of the form ``Integral(f(x)*DiracDelta(x - x0), (x, a, b))``,\nwhere it equals ``f(x0)`` if ``a <= x0 <= b`` and ``0`` otherwise. Formally,\nDiracDelta acts in some ways like a function that is ``0`` everywhere except\nat ``0``, but in many ways it also does not. It can often be useful to treat\nDiracDelta in formal ways, building up and manipulating expressions with\ndelta functions (which may eventually be integrated), but care must be taken\nto not treat it as a real function. SymPy's ``oo`` is similar. It only\ntruly makes sense formally in certain contexts (such as integration limits),\nbut SymPy allows its use everywhere, and it tries to be consistent with\noperations on it (like ``1/oo``), but it is easy to get into trouble and get\nwrong results if ``oo`` is treated too much like a number. Similarly, if\nDiracDelta is treated too much like a function, it is easy to get wrong or\nnonsensical results.\n\nDiracDelta function has the following properties:\n\n1) $\\frac{d}{d x} \\theta(x) = \\delta(x)$\n2) $\\int_{-\\infty}^\\infty \\delta(x - a)f(x)\\, dx = f(a)$ and $\\int_{a-\n   \\epsilon}^{a+\\epsilon} \\delta(x - a)f(x)\\, dx = f(a)$\n3) $\\delta(x) = 0$ for all $x \\neq 0$\n4) $\\delta(g(x)) = \\sum_i \\frac{\\delta(x - x_i)}{\\|g'(x_i)\\|}$ where $x_i$\n   are the roots of $g$\n5) $\\delta(-x) = \\delta(x)$\n\nDerivatives of ``k``-th order of DiracDelta have the following properties:\n\n6) $\\delta(x, k) = 0$ for all $x \\neq 0$\n7) $\\delta(-x, k) = -\\delta(x, k)$ for odd $k$\n8) $\\delta(-x, k) = \\delta(x, k)$ for even $k$\n\nExamples\n========\n\n>>> from sympy import DiracDelta, diff, pi\n>>> from sympy.abc import x, y\n\n>>> DiracDelta(x)\nDiracDelta(x)\n>>> DiracDelta(1)\n0\n>>> DiracDelta(-1)\n0\n>>> DiracDelta(pi)\n0\n>>> DiracDelta(x - 4).subs(x, 4)\nDiracDelta(0)\n>>> diff(DiracDelta(x))\nDiracDelta(x, 1)\n>>> diff(DiracDelta(x - 1), x, 2)\nDiracDelta(x - 1, 2)\n>>> diff(DiracDelta(x**2 - 1), x, 2)\n2*(2*x**2*DiracDelta(x**2 - 1, 2) + DiracDelta(x**2 - 1, 1))\n>>> DiracDelta(3*x).is_simple(x)\nTrue\n>>> DiracDelta(x**2).is_simple(x)\nFalse\n>>> DiracDelta((x**2 - 1)*y).expand(diracdelta=True, wrt=x)\nDiracDelta(x - 1)/(2*Abs(y)) + DiracDelta(x + 1)/(2*Abs(y))\n\nSee Also\n========\n\nHeaviside\nsympy.simplify.simplify.simplify, is_simple\nsympy.functions.special.tensor_functions.KroneckerDelta\n\nReferences\n==========\n\n.. [1] https://mathworld.wolfram.com/DeltaFunction.html",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Ei": {
        "full_name": "sympy.functions.Ei",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "The classical exponential integral.\n\nExplanation\n===========\n\nFor use in SymPy, this function is defined as\n\n.. math:: \\operatorname{Ei}(x) = \\sum_{n=1}^\\infty \\frac{x^n}{n\\, n!}\n                                 + \\log(x) + \\gamma,\n\nwhere $\\gamma$ is the Euler-Mascheroni constant.\n\nIf $x$ is a polar number, this defines an analytic function on the\nRiemann surface of the logarithm. Otherwise this defines an analytic\nfunction in the cut plane $\\mathbb{C} \\setminus (-\\infty, 0]$.\n\n**Background**\n\nThe name exponential integral comes from the following statement:\n\n.. math:: \\operatorname{Ei}(x) = \\int_{-\\infty}^x \\frac{e^t}{t} \\mathrm{d}t\n\nIf the integral is interpreted as a Cauchy principal value, this statement\nholds for $x > 0$ and $\\operatorname{Ei}(x)$ as defined above.\n\nExamples\n========\n\n>>> from sympy import Ei, polar_lift, exp_polar, I, pi\n>>> from sympy.abc import x\n\n>>> Ei(-1)\nEi(-1)\n\nThis yields a real value:\n\n>>> Ei(-1).n(chop=True)\n-0.219383934395520\n\nOn the other hand the analytic continuation is not real:\n\n>>> Ei(polar_lift(-1)).n(chop=True)\n-0.21938393439552 + 3.14159265358979*I\n\nThe exponential integral has a logarithmic branch point at the origin:\n\n>>> Ei(x*exp_polar(2*I*pi))\nEi(x) + 2*I*pi\n\nDifferentiation is supported:\n\n>>> Ei(x).diff(x)\nexp(x)/x\n\nThe exponential integral is related to many other special functions.\nFor example:\n\n>>> from sympy import expint, Shi\n>>> Ei(x).rewrite(expint)\n-expint(1, x*exp_polar(I*pi)) - I*pi\n>>> Ei(x).rewrite(Shi)\nChi(x) + Shi(x)\n\nSee Also\n========\n\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\nSi: Sine integral.\nCi: Cosine integral.\nShi: Hyperbolic sine integral.\nChi: Hyperbolic cosine integral.\nuppergamma: Upper incomplete gamma function.\n\nReferences\n==========\n\n.. [1] https://dlmf.nist.gov/6.6\n.. [2] https://en.wikipedia.org/wiki/Exponential_integral\n.. [3] Abramowitz & Stegun, section 5: https://web.archive.org/web/20201128173312/http://people.math.sfu.ca/~cbm/aands/page_228.htm",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "FallingFactorial": {
        "full_name": "sympy.functions.FallingFactorial",
        "bases": [
          "CombinatorialFunction"
        ],
        "doc": "Falling factorial (related to rising factorial) is a double valued\nfunction arising in concrete mathematics, hypergeometric functions\nand series expansions. It is defined by\n\n.. math:: \\texttt{ff(x, k)} = (x)_k = x \\cdot (x-1) \\cdots (x-k+1)\n\nwhere `x` can be arbitrary expression and `k` is an integer. For\nmore information check \"Concrete mathematics\" by Graham, pp. 66\nor [1]_.\n\nWhen `x` is a `~.Poly` instance of degree $\\ge 1$ with single variable,\n`(x)_k = x(y) \\cdot x(y-1) \\cdots x(y-k+1)`, where `y` is the\nvariable of `x`. This is as described in\n\n>>> from sympy import ff, Poly, Symbol\n>>> from sympy.abc import x\n>>> n = Symbol('n', integer=True)\n\n>>> ff(x, 0)\n1\n>>> ff(5, 5)\n120\n>>> ff(x, 5) == x*(x - 1)*(x - 2)*(x - 3)*(x - 4)\nTrue\n>>> ff(Poly(x**2, x), 2)\nPoly(x**4 - 2*x**3 + x**2, x, domain='ZZ')\n>>> ff(n, n)\nfactorial(n)\n\nRewriting is complicated unless the relationship between\nthe arguments is known, but falling factorial can\nbe rewritten in terms of gamma, factorial and binomial\nand rising factorial.\n\n>>> from sympy import factorial, rf, gamma, binomial, Symbol\n>>> n = Symbol('n', integer=True, positive=True)\n>>> F = ff(n, n - 2)\n>>> for i in (rf, ff, factorial, binomial, gamma):\n...  F.rewrite(i)\n...\nRisingFactorial(3, n - 2)\nFallingFactorial(n, n - 2)\nfactorial(n)/2\nbinomial(n, n - 2)*factorial(n - 2)\ngamma(n + 1)/2\n\nSee Also\n========\n\nfactorial, factorial2, RisingFactorial\n\nReferences\n==========\n\n.. [1] https://mathworld.wolfram.com/FallingFactorial.html\n.. [2] Peter Paule, \"Greatest Factorial Factorization and Symbolic\n       Summation\", Journal of Symbolic Computation, vol. 20, pp. 235-268,\n       1995.",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Heaviside": {
        "full_name": "sympy.functions.Heaviside",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "Heaviside step function.\n\nExplanation\n===========\n\nThe Heaviside step function has the following properties:\n\n1) $\\frac{d}{d x} \\theta(x) = \\delta(x)$\n2) $\\theta(x) = \\begin{cases} 0 & \\text{for}\\: x < 0 \\\\ \\frac{1}{2} &\n   \\text{for}\\: x = 0 \\\\1 & \\text{for}\\: x > 0 \\end{cases}$\n3) $\\frac{d}{d x} \\max(x, 0) = \\theta(x)$\n\nHeaviside(x) is printed as $\\theta(x)$ with the SymPy LaTeX printer.\n\nThe value at 0 is set differently in different fields. SymPy uses 1/2,\nwhich is a convention from electronics and signal processing, and is\nconsistent with solving improper integrals by Fourier transform and\nconvolution.\n\nTo specify a different value of Heaviside at ``x=0``, a second argument\ncan be given. Using ``Heaviside(x, nan)`` gives an expression that will\nevaluate to nan for x=0.\n\n.. versionchanged:: 1.9 ``Heaviside(0)`` now returns 1/2 (before: undefined)\n\nExamples\n========\n\n>>> from sympy import Heaviside, nan\n>>> from sympy.abc import x\n>>> Heaviside(9)\n1\n>>> Heaviside(-9)\n0\n>>> Heaviside(0)\n1/2\n>>> Heaviside(0, nan)\nnan\n>>> (Heaviside(x) + 1).replace(Heaviside(x), Heaviside(x, 1))\nHeaviside(x, 1) + 1\n\nSee Also\n========\n\nDiracDelta\n\nReferences\n==========\n\n.. [1] https://mathworld.wolfram.com/HeavisideStepFunction.html\n.. [2] https://dlmf.nist.gov/1.16#iv",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "KroneckerDelta": {
        "full_name": "sympy.functions.KroneckerDelta",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "The discrete, or Kronecker, delta function.\n\nExplanation\n===========\n\nA function that takes in two integers $i$ and $j$. It returns $0$ if $i$\nand $j$ are not equal, or it returns $1$ if $i$ and $j$ are equal.\n\nExamples\n========\n\nAn example with integer indices:\n\n    >>> from sympy import KroneckerDelta\n    >>> KroneckerDelta(1, 2)\n    0\n    >>> KroneckerDelta(3, 3)\n    1\n\nSymbolic indices:\n\n    >>> from sympy.abc import i, j, k\n    >>> KroneckerDelta(i, j)\n    KroneckerDelta(i, j)\n    >>> KroneckerDelta(i, i)\n    1\n    >>> KroneckerDelta(i, i + 1)\n    0\n    >>> KroneckerDelta(i, i + 1 + k)\n    KroneckerDelta(i, i + k + 1)\n\nParameters\n==========\n\ni : Number, Symbol\n    The first index of the delta function.\nj : Number, Symbol\n    The second index of the delta function.\n\nSee Also\n========\n\neval\nDiracDelta\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Kronecker_delta",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "LambertW": {
        "full_name": "sympy.functions.LambertW",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "The Lambert W function $W(z)$ is defined as the inverse\nfunction of $w \\exp(w)$ [1]_.\n\nExplanation\n===========\n\nIn other words, the value of $W(z)$ is such that $z = W(z) \\exp(W(z))$\nfor any complex number $z$.  The Lambert W function is a multivalued\nfunction with infinitely many branches $W_k(z)$, indexed by\n$k \\in \\mathbb{Z}$.  Each branch gives a different solution $w$\nof the equation $z = w \\exp(w)$.\n\nThe Lambert W function has two partially real branches: the\nprincipal branch ($k = 0$) is real for real $z > -1/e$, and the\n$k = -1$ branch is real for $-1/e < z < 0$. All branches except\n$k = 0$ have a logarithmic singularity at $z = 0$.\n\nExamples\n========\n\n>>> from sympy import LambertW\n>>> LambertW(1.2)\n0.635564016364870\n>>> LambertW(1.2, -1).n()\n-1.34747534407696 - 4.41624341514535*I\n>>> LambertW(-1).is_real\nFalse\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Lambert_W_function",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "LeviCivita": {
        "full_name": "sympy.functions.LeviCivita",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "Represent the Levi-Civita symbol.\n\nExplanation\n===========\n\nFor even permutations of indices it returns 1, for odd permutations -1, and\nfor everything else (a repeated index) it returns 0.\n\nThus it represents an alternating pseudotensor.\n\nExamples\n========\n\n>>> from sympy import LeviCivita\n>>> from sympy.abc import i, j, k\n>>> LeviCivita(1, 2, 3)\n1\n>>> LeviCivita(1, 3, 2)\n-1\n>>> LeviCivita(1, 2, 2)\n0\n>>> LeviCivita(i, j, k)\nLeviCivita(i, j, k)\n>>> LeviCivita(i, j, i)\n0\n\nSee Also\n========\n\nEijk",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Li": {
        "full_name": "sympy.functions.Li",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "The offset logarithmic integral.\n\nExplanation\n===========\n\nFor use in SymPy, this function is defined as\n\n.. math:: \\operatorname{Li}(x) = \\operatorname{li}(x) - \\operatorname{li}(2)\n\nExamples\n========\n\n>>> from sympy import Li\n>>> from sympy.abc import z\n\nThe following special value is known:\n\n>>> Li(2)\n0\n\nDifferentiation with respect to $z$ is supported:\n\n>>> from sympy import diff\n>>> diff(Li(z), z)\n1/log(z)\n\nThe shifted logarithmic integral can be written in terms of $li(z)$:\n\n>>> from sympy import li\n>>> Li(z).rewrite(li)\nli(z) - li(2)\n\nWe can numerically evaluate the logarithmic integral to arbitrary precision\non the whole complex plane (except the singular points):\n\n>>> Li(2).evalf(30)\n0\n\n>>> Li(4).evalf(30)\n1.92242131492155809316615998938\n\nSee Also\n========\n\nli: Logarithmic integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nSi: Sine integral.\nCi: Cosine integral.\nShi: Hyperbolic sine integral.\nChi: Hyperbolic cosine integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Logarithmic_integral\n.. [2] https://mathworld.wolfram.com/LogarithmicIntegral.html\n.. [3] https://dlmf.nist.gov/6",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Max": {
        "full_name": "sympy.functions.Max",
        "bases": [
          "MinMaxBase",
          "Application"
        ],
        "doc": "Return, if possible, the maximum value of the list.\n\nWhen number of arguments is equal one, then\nreturn this argument.\n\nWhen number of arguments is equal two, then\nreturn, if possible, the value from (a, b) that is $\\ge$ the other.\n\nIn common case, when the length of list greater than 2, the task\nis more complicated. Return only the arguments, which are greater\nthan others, if it is possible to determine directional relation.\n\nIf is not possible to determine such a relation, return a partially\nevaluated result.\n\nAssumptions are used to make the decision too.\n\nAlso, only comparable arguments are permitted.\n\nIt is named ``Max`` and not ``max`` to avoid conflicts\nwith the built-in function ``max``.\n\n\nExamples\n========\n\n>>> from sympy import Max, Symbol, oo\n>>> from sympy.abc import x, y, z\n>>> p = Symbol('p', positive=True)\n>>> n = Symbol('n', negative=True)\n\n>>> Max(x, -2)\nMax(-2, x)\n>>> Max(x, -2).subs(x, 3)\n3\n>>> Max(p, -2)\np\n>>> Max(x, y)\nMax(x, y)\n>>> Max(x, y) == Max(y, x)\nTrue\n>>> Max(x, Max(y, z))\nMax(x, y, z)\n>>> Max(n, 8, p, 7, -oo)\nMax(8, p)\n>>> Max (1, x, oo)\noo\n\n* Algorithm\n\nThe task can be considered as searching of supremums in the\ndirected complete partial orders [1]_.\n\nThe source values are sequentially allocated by the isolated subsets\nin which supremums are searched and result as Max arguments.\n\nIf the resulted supremum is single, then it is returned.\n\nThe isolated subsets are the sets of values which are only the comparable\nwith each other in the current set. E.g. natural numbers are comparable with\neach other, but not comparable with the `x` symbol. Another example: the\nsymbol `x` with negative assumption is comparable with a natural number.\n\nAlso there are \"least\" elements, which are comparable with all others,\nand have a zero property (maximum or minimum for all elements).\nFor example, in case of $\\infty$, the allocation operation is terminated\nand only this value is returned.\n\nAssumption:\n   - if $A > B > C$ then $A > C$\n   - if $A = B$ then $B$ can be removed\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Directed_complete_partial_order\n.. [2] https://en.wikipedia.org/wiki/Lattice_%28order%29\n\nSee Also\n========\n\nMin : find minimum values",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Min": {
        "full_name": "sympy.functions.Min",
        "bases": [
          "MinMaxBase",
          "Application"
        ],
        "doc": "Return, if possible, the minimum value of the list.\nIt is named ``Min`` and not ``min`` to avoid conflicts\nwith the built-in function ``min``.\n\nExamples\n========\n\n>>> from sympy import Min, Symbol, oo\n>>> from sympy.abc import x, y\n>>> p = Symbol('p', positive=True)\n>>> n = Symbol('n', negative=True)\n\n>>> Min(x, -2)\nMin(-2, x)\n>>> Min(x, -2).subs(x, 3)\n-2\n>>> Min(p, -3)\n-3\n>>> Min(x, y)\nMin(x, y)\n>>> Min(n, 8, p, -7, p, oo)\nMin(-7, n)\n\nSee Also\n========\n\nMax : find maximum values",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Piecewise": {
        "full_name": "sympy.functions.Piecewise",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "Represents a piecewise function.\n\nUsage:\n\n  Piecewise( (expr,cond), (expr,cond), ... )\n    - Each argument is a 2-tuple defining an expression and condition\n    - The conds are evaluated in turn returning the first that is True.\n      If any of the evaluated conds are not explicitly False,\n      e.g. ``x < 1``, the function is returned in symbolic form.\n    - If the function is evaluated at a place where all conditions are False,\n      nan will be returned.\n    - Pairs where the cond is explicitly False, will be removed and no pair\n      appearing after a True condition will ever be retained. If a single\n      pair with a True condition remains, it will be returned, even when\n      evaluation is False.\n\nExamples\n========\n\n>>> from sympy import Piecewise, log, piecewise_fold\n>>> from sympy.abc import x, y\n>>> f = x**2\n>>> g = log(x)\n>>> p = Piecewise((0, x < -1), (f, x <= 1), (g, True))\n>>> p.subs(x,1)\n1\n>>> p.subs(x,5)\nlog(5)\n\nBooleans can contain Piecewise elements:\n\n>>> cond = (x < y).subs(x, Piecewise((2, x < 0), (3, True))); cond\nPiecewise((2, x < 0), (3, True)) < y\n\nThe folded version of this results in a Piecewise whose\nexpressions are Booleans:\n\n>>> folded_cond = piecewise_fold(cond); folded_cond\nPiecewise((2 < y, x < 0), (3 < y, True))\n\nWhen a Boolean containing Piecewise (like cond) or a Piecewise\nwith Boolean expressions (like folded_cond) is used as a condition,\nit is converted to an equivalent :class:`~.ITE` object:\n\n>>> Piecewise((1, folded_cond))\nPiecewise((1, ITE(x < 0, y > 2, y > 3)))\n\nWhen a condition is an ``ITE``, it will be converted to a simplified\nBoolean expression:\n\n>>> piecewise_fold(_)\nPiecewise((1, ((x >= 0) | (y > 2)) & ((y > 3) | (x < 0))))\n\nSee Also\n========\n\npiecewise_fold\npiecewise_exclusive\nITE",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Rem": {
        "full_name": "sympy.functions.Rem",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "Returns the remainder when ``p`` is divided by ``q`` where ``p`` is finite\nand ``q`` is not equal to zero. The result, ``p - int(p/q)*q``, has the same sign\nas the divisor.\n\nParameters\n==========\n\np : Expr\n    Dividend.\n\nq : Expr\n    Divisor.\n\nNotes\n=====\n\n``Rem`` corresponds to the ``%`` operator in C.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> from sympy import Rem\n>>> Rem(x**3, y)\nRem(x**3, y)\n>>> Rem(x**3, y).subs({x: -5, y: 3})\n-2\n\nSee Also\n========\n\nMod",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "RisingFactorial": {
        "full_name": "sympy.functions.RisingFactorial",
        "bases": [
          "CombinatorialFunction"
        ],
        "doc": "Rising factorial (also called Pochhammer symbol [1]_) is a double valued\nfunction arising in concrete mathematics, hypergeometric functions\nand series expansions. It is defined by:\n\n.. math:: \\texttt{rf(y, k)} = (x)^k = x \\cdot (x+1) \\cdots (x+k-1)\n\nwhere `x` can be arbitrary expression and `k` is an integer. For\nmore information check \"Concrete mathematics\" by Graham, pp. 66\nor visit https://mathworld.wolfram.com/RisingFactorial.html page.\n\nWhen `x` is a `~.Poly` instance of degree $\\ge 1$ with a single variable,\n`(x)^k = x(y) \\cdot x(y+1) \\cdots x(y+k-1)`, where `y` is the\nvariable of `x`. This is as described in [2]_.\n\nExamples\n========\n\n>>> from sympy import rf, Poly\n>>> from sympy.abc import x\n>>> rf(x, 0)\n1\n>>> rf(1, 5)\n120\n>>> rf(x, 5) == x*(1 + x)*(2 + x)*(3 + x)*(4 + x)\nTrue\n>>> rf(Poly(x**3, x), 2)\nPoly(x**6 + 3*x**5 + 3*x**4 + x**3, x, domain='ZZ')\n\nRewriting is complicated unless the relationship between\nthe arguments is known, but rising factorial can\nbe rewritten in terms of gamma, factorial, binomial,\nand falling factorial.\n\n>>> from sympy import Symbol, factorial, ff, binomial, gamma\n>>> n = Symbol('n', integer=True, positive=True)\n>>> R = rf(n, n + 2)\n>>> for i in (rf, ff, factorial, binomial, gamma):\n...  R.rewrite(i)\n...\nRisingFactorial(n, n + 2)\nFallingFactorial(2*n + 1, n + 2)\nfactorial(2*n + 1)/factorial(n - 1)\nbinomial(2*n + 1, n + 2)*factorial(n + 2)\ngamma(2*n + 2)/gamma(n)\n\nSee Also\n========\n\nfactorial, factorial2, FallingFactorial\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Pochhammer_symbol\n.. [2] Peter Paule, \"Greatest Factorial Factorization and Symbolic\n       Summation\", Journal of Symbolic Computation, vol. 20, pp. 235-268,\n       1995.",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Shi": {
        "full_name": "sympy.functions.Shi",
        "bases": [
          "TrigonometricIntegral"
        ],
        "doc": "Sinh integral.\n\nExplanation\n===========\n\nThis function is defined by\n\n.. math:: \\operatorname{Shi}(z) = \\int_0^z \\frac{\\sinh{t}}{t} \\mathrm{d}t.\n\nIt is an entire function.\n\nExamples\n========\n\n>>> from sympy import Shi\n>>> from sympy.abc import z\n\nThe Sinh integral is a primitive of $\\sinh(z)/z$:\n\n>>> Shi(z).diff(z)\nsinh(z)/z\n\nIt is unbranched:\n\n>>> from sympy import exp_polar, I, pi\n>>> Shi(z*exp_polar(2*I*pi))\nShi(z)\n\nThe $\\sinh$ integral behaves much like ordinary $\\sinh$ under\nmultiplication by $i$:\n\n>>> Shi(I*z)\nI*Si(z)\n>>> Shi(-z)\n-Shi(z)\n\nIt can also be expressed in terms of exponential integrals, but beware\nthat the latter is branched:\n\n>>> from sympy import expint\n>>> Shi(z).rewrite(expint)\nexpint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2\n\nSee Also\n========\n\nSi: Sine integral.\nCi: Cosine integral.\nChi: Hyperbolic cosine integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Trigonometric_integral",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Si": {
        "full_name": "sympy.functions.Si",
        "bases": [
          "TrigonometricIntegral"
        ],
        "doc": "Sine integral.\n\nExplanation\n===========\n\nThis function is defined by\n\n.. math:: \\operatorname{Si}(z) = \\int_0^z \\frac{\\sin{t}}{t} \\mathrm{d}t.\n\nIt is an entire function.\n\nExamples\n========\n\n>>> from sympy import Si\n>>> from sympy.abc import z\n\nThe sine integral is an antiderivative of $sin(z)/z$:\n\n>>> Si(z).diff(z)\nsin(z)/z\n\nIt is unbranched:\n\n>>> from sympy import exp_polar, I, pi\n>>> Si(z*exp_polar(2*I*pi))\nSi(z)\n\nSine integral behaves much like ordinary sine under multiplication by ``I``:\n\n>>> Si(I*z)\nI*Shi(z)\n>>> Si(-z)\n-Si(z)\n\nIt can also be expressed in terms of exponential integrals, but beware\nthat the latter is branched:\n\n>>> from sympy import expint\n>>> Si(z).rewrite(expint)\n-I*(-expint(1, z*exp_polar(-I*pi/2))/2 +\n     expint(1, z*exp_polar(I*pi/2))/2) + pi/2\n\nIt can be rewritten in the form of sinc function (by definition):\n\n>>> from sympy import sinc\n>>> Si(z).rewrite(sinc)\nIntegral(sinc(_t), (_t, 0, z))\n\nSee Also\n========\n\nCi: Cosine integral.\nShi: Hyperbolic sine integral.\nChi: Hyperbolic cosine integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nsinc: unnormalized sinc function\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Trigonometric_integral",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "SingularityFunction": {
        "full_name": "sympy.functions.SingularityFunction",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "Singularity functions are a class of discontinuous functions.\n\nExplanation\n===========\n\nSingularity functions take a variable, an offset, and an exponent as\narguments. These functions are represented using Macaulay brackets as:\n\nSingularityFunction(x, a, n) := <x - a>^n\n\nThe singularity function will automatically evaluate to\n``Derivative(DiracDelta(x - a), x, -n - 1)`` if ``n < 0``\nand ``(x - a)**n*Heaviside(x - a, 1)`` if ``n >= 0``.\n\nExamples\n========\n\n>>> from sympy import SingularityFunction, diff, Piecewise, DiracDelta, Heaviside, Symbol\n>>> from sympy.abc import x, a, n\n>>> SingularityFunction(x, a, n)\nSingularityFunction(x, a, n)\n>>> y = Symbol('y', positive=True)\n>>> n = Symbol('n', nonnegative=True)\n>>> SingularityFunction(y, -10, n)\n(y + 10)**n\n>>> y = Symbol('y', negative=True)\n>>> SingularityFunction(y, 10, n)\n0\n>>> SingularityFunction(x, 4, -1).subs(x, 4)\noo\n>>> SingularityFunction(x, 10, -2).subs(x, 10)\noo\n>>> SingularityFunction(4, 1, 5)\n243\n>>> diff(SingularityFunction(x, 1, 5) + SingularityFunction(x, 1, 4), x)\n4*SingularityFunction(x, 1, 3) + 5*SingularityFunction(x, 1, 4)\n>>> diff(SingularityFunction(x, 4, 0), x, 2)\nSingularityFunction(x, 4, -2)\n>>> SingularityFunction(x, 4, 5).rewrite(Piecewise)\nPiecewise(((x - 4)**5, x >= 4), (0, True))\n>>> expr = SingularityFunction(x, a, n)\n>>> y = Symbol('y', positive=True)\n>>> n = Symbol('n', nonnegative=True)\n>>> expr.subs({x: y, a: -10, n: n})\n(y + 10)**n\n\nThe methods ``rewrite(DiracDelta)``, ``rewrite(Heaviside)``, and\n``rewrite('HeavisideDiracDelta')`` returns the same output. One can use any\nof these methods according to their choice.\n\n>>> expr = SingularityFunction(x, 4, 5) + SingularityFunction(x, -3, -1) - SingularityFunction(x, 0, -2)\n>>> expr.rewrite(Heaviside)\n(x - 4)**5*Heaviside(x - 4, 1) + DiracDelta(x + 3) - DiracDelta(x, 1)\n>>> expr.rewrite(DiracDelta)\n(x - 4)**5*Heaviside(x - 4, 1) + DiracDelta(x + 3) - DiracDelta(x, 1)\n>>> expr.rewrite('HeavisideDiracDelta')\n(x - 4)**5*Heaviside(x - 4, 1) + DiracDelta(x + 3) - DiracDelta(x, 1)\n\nSee Also\n========\n\nDiracDelta, Heaviside\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Singularity_function",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Ynm": {
        "full_name": "sympy.functions.Ynm",
        "bases": [
          "DefinedFunction"
        ],
        "doc": "Spherical harmonics defined as\n\n.. math::\n    Y_n^m(\\theta, \\varphi) := \\sqrt{\\frac{(2n+1)(n-m)!}{4\\pi(n+m)!}}\n                              \\exp(i m \\varphi)\n                              \\mathrm{P}_n^m\\left(\\cos(\\theta)\\right)\n\nExplanation\n===========\n\n``Ynm()`` gives the spherical harmonic function of order $n$ and $m$\nin $\\theta$ and $\\varphi$, $Y_n^m(\\theta, \\varphi)$. The four\nparameters are as follows: $n \\geq 0$ an integer and $m$ an integer\nsuch that $-n \\leq m \\leq n$ holds. The two angles are real-valued\nwith $\\theta \\in [0, \\pi]$ and $\\varphi \\in [0, 2\\pi]$.\n\nExamples\n========\n\n>>> from sympy import Ynm, Symbol, simplify\n>>> from sympy.abc import n,m\n>>> theta = Symbol(\"theta\")\n>>> phi = Symbol(\"phi\")\n\n>>> Ynm(n, m, theta, phi)\nYnm(n, m, theta, phi)\n\nSeveral symmetries are known, for the order:\n\n>>> Ynm(n, -m, theta, phi)\n(-1)**m*exp(-2*I*m*phi)*Ynm(n, m, theta, phi)\n\nAs well as for the angles:\n\n>>> Ynm(n, m, -theta, phi)\nYnm(n, m, theta, phi)\n\n>>> Ynm(n, m, theta, -phi)\nexp(-2*I*m*phi)*Ynm(n, m, theta, phi)\n\nFor specific integers $n$ and $m$ we can evaluate the harmonics\nto more useful expressions:\n\n>>> simplify(Ynm(0, 0, theta, phi).expand(func=True))\n1/(2*sqrt(pi))\n\n>>> simplify(Ynm(1, -1, theta, phi).expand(func=True))\nsqrt(6)*exp(-I*phi)*sin(theta)/(4*sqrt(pi))\n\n>>> simplify(Ynm(1, 0, theta, phi).expand(func=True))\nsqrt(3)*cos(theta)/(2*sqrt(pi))\n\n>>> simplify(Ynm(1, 1, theta, phi).expand(func=True))\n-sqrt(6)*exp(I*phi)*sin(theta)/(4*sqrt(pi))\n\n>>> simplify(Ynm(2, -2, theta, phi).expand(func=True))\nsqrt(30)*exp(-2*I*phi)*sin(theta)**2/(8*sqrt(pi))\n\n>>> simplify(Ynm(2, -1, theta, phi).expand(func=True))\nsqrt(30)*exp(-I*phi)*sin(2*theta)/(8*sqrt(pi))\n\n>>> simplify(Ynm(2, 0, theta, phi).expand(func=True))\nsqrt(5)*(3*cos(theta)**2 - 1)/(4*sqrt(pi))\n\n>>> simplify(Ynm(2, 1, theta, phi).expand(func=True))\n-sqrt(30)*exp(I*phi)*sin(2*theta)/(8*sqrt(pi))\n\n>>> simplify(Ynm(2, 2, theta, phi).expand(func=True))\nsqrt(30)*exp(2*I*phi)*sin(theta)**2/(8*sqrt(pi))\n\nWe can differentiate the functions with respect\nto both angles:\n\n>>> from sympy import Ynm, Symbol, diff\n>>> from sympy.abc import n,m\n>>> theta = Symbol(\"theta\")\n>>> phi = Symbol(\"phi\")\n\n>>> diff(Ynm(n, m, theta, phi), theta)\nm*cot(theta)*Ynm(n, m, theta, phi) + sqrt((-m + n)*(m + n + 1))*exp(-I*phi)*Ynm(n, m + 1, theta, phi)\n\n>>> diff(Ynm(n, m, theta, phi), phi)\nI*m*Ynm(n, m, theta, phi)\n\nFurther we can compute the complex conjugation:\n\n>>> from sympy import Ynm, Symbol, conjugate\n>>> from sympy.abc import n,m\n>>> theta = Symbol(\"theta\")\n>>> phi = Symbol(\"phi\")\n\n>>> conjugate(Ynm(n, m, theta, phi))\n(-1)**(2*m)*exp(-2*I*m*phi)*Ynm(n, m, theta, phi)\n\nTo get back the well known expressions in spherical\ncoordinates, we use full expansion:\n\n>>> from sympy import Ynm, Symbol, expand_func\n>>> from sympy.abc import n,m\n>>> theta = Symbol(\"theta\")\n>>> phi = Symbol(\"phi\")\n\n>>> expand_func(Ynm(n, m, theta, phi))\nsqrt((2*n + 1)*factorial(-m + n)/factorial(m + n))*exp(I*m*phi)*assoc_legendre(n, m, cos(theta))/(2*sqrt(pi))\n\nSee Also\n========\n\nYnm_c, Znm\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Spherical_harmonics\n.. [2] https://mathworld.wolfram.com/SphericalHarmonic.html\n.. [3] https://functions.wolfram.com/Polynomials/SphericalHarmonicY/\n.. [4] https://dlmf.nist.gov/14.30",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      }
    },
    "functions": {
      "E1": {
        "doc": "Classical case of the generalized exponential integral.\n\nExplanation\n===========\n\nThis is equivalent to ``expint(1, z)``.\n\nExamples\n========\n\n>>> from sympy import E1\n>>> E1(0)\nexpint(1, 0)\n\n>>> E1(5)\nexpint(1, 5)\n\nSee Also\n========\n\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\nSi: Sine integral.\nCi: Cosine integral.\nShi: Hyperbolic sine integral.\nChi: Hyperbolic cosine integral.",
        "signature": "(z)",
        "parameters": {
          "z": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "Eijk": {
        "doc": "Represent the Levi-Civita symbol.\n\nThis is a compatibility wrapper to ``LeviCivita()``.\n\nSee Also\n========\n\nLeviCivita",
        "signature": "(*args, **kwargs)",
        "parameters": {
          "args": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          },
          "kwargs": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      }
    },
    "constants": {}
  },
  "sympy.matrices": {
    "classes": {
      "Adjoint": {
        "full_name": "sympy.matrices.Adjoint",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "The Hermitian adjoint of a matrix expression.\n\nThis is a symbolic object that simply stores its argument without\nevaluating it. To actually compute the adjoint, use the ``adjoint()``\nfunction.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, Adjoint, adjoint\n>>> A = MatrixSymbol('A', 3, 5)\n>>> B = MatrixSymbol('B', 5, 3)\n>>> Adjoint(A*B)\nAdjoint(A*B)\n>>> adjoint(A*B)\nAdjoint(B)*Adjoint(A)\n>>> adjoint(A*B) == Adjoint(A*B)\nFalse\n>>> adjoint(A*B) == Adjoint(A*B).doit()\nTrue",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "BlockDiagMatrix": {
        "full_name": "sympy.matrices.BlockDiagMatrix",
        "bases": [
          "BlockMatrix"
        ],
        "doc": "A sparse matrix with block matrices along its diagonals\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, BlockDiagMatrix, symbols\n>>> n, m, l = symbols('n m l')\n>>> X = MatrixSymbol('X', n, n)\n>>> Y = MatrixSymbol('Y', m, m)\n>>> BlockDiagMatrix(X, Y)\nMatrix([\n[X, 0],\n[0, Y]])\n\nNotes\n=====\n\nIf you want to get the individual diagonal blocks, use\n:meth:`get_diag_blocks`.\n\nSee Also\n========\n\nsympy.matrices.dense.diag",
        "methods": {
          "LDUdecomposition": {
            "doc": "Returns the Block LDU decomposition of\na 2x2 Block Matrix\n\nReturns\n=======\n\n(L, D, U) : Matrices\n    L : Lower Diagonal Matrix\n    D : Diagonal Matrix\n    U : Upper Diagonal Matrix\n\nExamples\n========\n\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]])\n>>> L, D, U = X.LDUdecomposition()\n>>> block_collapse(L*D*U)\nMatrix([\n[A, B],\n[C, D]])\n\nRaises\n======\n\nShapeError\n    If the block matrix is not a 2x2 matrix\n\nNonInvertibleMatrixError\n    If the matrix \"A\" is non-invertible\n\nSee Also\n========\nsympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition\nsympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecomposition": {
            "doc": "Returns the Block LU decomposition of\na 2x2 Block Matrix\n\nReturns\n=======\n\n(L, U) : Matrices\n    L : Lower Diagonal Matrix\n    U : Upper Diagonal Matrix\n\nExamples\n========\n\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]])\n>>> L, U = X.LUdecomposition()\n>>> block_collapse(L*U)\nMatrix([\n[A, B],\n[C, D]])\n\nRaises\n======\n\nShapeError\n    If the block matrix is not a 2x2 matrix\n\nNonInvertibleMatrixError\n    If the matrix \"A\" is non-invertible\n\nSee Also\n========\nsympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition\nsympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "UDLdecomposition": {
            "doc": "Returns the Block UDL decomposition of\na 2x2 Block Matrix\n\nReturns\n=======\n\n(U, D, L) : Matrices\n    U : Upper Diagonal Matrix\n    D : Diagonal Matrix\n    L : Lower Diagonal Matrix\n\nExamples\n========\n\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]])\n>>> U, D, L = X.UDLdecomposition()\n>>> block_collapse(U*D*L)\nMatrix([\n[A, B],\n[C, D]])\n\nRaises\n======\n\nShapeError\n    If the block matrix is not a 2x2 matrix\n\nNonInvertibleMatrixError\n    If the matrix \"D\" is non-invertible\n\nSee Also\n========\nsympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition\nsympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "BlockMatrix": {
        "full_name": "sympy.matrices.BlockMatrix",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "A BlockMatrix is a Matrix comprised of other matrices.\n\nThe submatrices are stored in a SymPy Matrix object but accessed as part of\na Matrix Expression\n\n>>> from sympy import (MatrixSymbol, BlockMatrix, symbols,\n...     Identity, ZeroMatrix, block_collapse)\n>>> n,m,l = symbols('n m l')\n>>> X = MatrixSymbol('X', n, n)\n>>> Y = MatrixSymbol('Y', m, m)\n>>> Z = MatrixSymbol('Z', n, m)\n>>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])\n>>> print(B)\nMatrix([\n[X, Z],\n[0, Y]])\n\n>>> C = BlockMatrix([[Identity(n), Z]])\n>>> print(C)\nMatrix([[I, Z]])\n\n>>> print(block_collapse(C*B))\nMatrix([[X, Z + Z*Y]])\n\nSome matrices might be comprised of rows of blocks with\nthe matrices in each row having the same height and the\nrows all having the same total number of columns but\nnot having the same number of columns for each matrix\nin each row. In this case, the matrix is not a block\nmatrix and should be instantiated by Matrix.\n\n>>> from sympy import ones, Matrix\n>>> dat = [\n... [ones(3,2), ones(3,3)*2],\n... [ones(2,3)*3, ones(2,2)*4]]\n...\n>>> BlockMatrix(dat)\nTraceback (most recent call last):\n...\nValueError:\nAlthough this matrix is comprised of blocks, the blocks do not fill\nthe matrix in a size-symmetric fashion. To create a full matrix from\nthese arguments, pass them directly to Matrix.\n>>> Matrix(dat)\nMatrix([\n[1, 1, 2, 2, 2],\n[1, 1, 2, 2, 2],\n[1, 1, 2, 2, 2],\n[3, 3, 3, 4, 4],\n[3, 3, 3, 4, 4]])\n\nSee Also\n========\nsympy.matrices.matrixbase.MatrixBase.irregular",
        "methods": {
          "LDUdecomposition": {
            "doc": "Returns the Block LDU decomposition of\na 2x2 Block Matrix\n\nReturns\n=======\n\n(L, D, U) : Matrices\n    L : Lower Diagonal Matrix\n    D : Diagonal Matrix\n    U : Upper Diagonal Matrix\n\nExamples\n========\n\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]])\n>>> L, D, U = X.LDUdecomposition()\n>>> block_collapse(L*D*U)\nMatrix([\n[A, B],\n[C, D]])\n\nRaises\n======\n\nShapeError\n    If the block matrix is not a 2x2 matrix\n\nNonInvertibleMatrixError\n    If the matrix \"A\" is non-invertible\n\nSee Also\n========\nsympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition\nsympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecomposition": {
            "doc": "Returns the Block LU decomposition of\na 2x2 Block Matrix\n\nReturns\n=======\n\n(L, U) : Matrices\n    L : Lower Diagonal Matrix\n    U : Upper Diagonal Matrix\n\nExamples\n========\n\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]])\n>>> L, U = X.LUdecomposition()\n>>> block_collapse(L*U)\nMatrix([\n[A, B],\n[C, D]])\n\nRaises\n======\n\nShapeError\n    If the block matrix is not a 2x2 matrix\n\nNonInvertibleMatrixError\n    If the matrix \"A\" is non-invertible\n\nSee Also\n========\nsympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition\nsympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "UDLdecomposition": {
            "doc": "Returns the Block UDL decomposition of\na 2x2 Block Matrix\n\nReturns\n=======\n\n(U, D, L) : Matrices\n    U : Upper Diagonal Matrix\n    D : Diagonal Matrix\n    L : Lower Diagonal Matrix\n\nExamples\n========\n\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]])\n>>> U, D, L = X.UDLdecomposition()\n>>> block_collapse(U*D*L)\nMatrix([\n[A, B],\n[C, D]])\n\nRaises\n======\n\nShapeError\n    If the block matrix is not a 2x2 matrix\n\nNonInvertibleMatrixError\n    If the matrix \"D\" is non-invertible\n\nSee Also\n========\nsympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition\nsympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "DeferredVector": {
        "full_name": "sympy.matrices.DeferredVector",
        "bases": [
          "Symbol",
          "NotIterable"
        ],
        "doc": "A vector whose components are deferred (e.g. for use with lambdify).\n\nExamples\n========\n\n>>> from sympy import DeferredVector, lambdify\n>>> X = DeferredVector( 'X' )\n>>> X\nX\n>>> expr = (X[0] + 2, X[2] + 3)\n>>> func = lambdify( X, expr)\n>>> func( [1, 2, 3] )\n(3, 6)",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "Determinant": {
        "full_name": "sympy.matrices.Determinant",
        "bases": [
          "Expr"
        ],
        "doc": "Matrix Determinant\n\nRepresents the determinant of a matrix expression.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, Determinant, eye\n>>> A = MatrixSymbol('A', 3, 3)\n>>> Determinant(A)\nDeterminant(A)\n>>> Determinant(eye(3)).doit()\n1",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "DiagMatrix": {
        "full_name": "sympy.matrices.DiagMatrix",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "Turn a vector into a diagonal matrix.",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "DiagonalMatrix": {
        "full_name": "sympy.matrices.DiagonalMatrix",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "DiagonalMatrix(M) will create a matrix expression that\nbehaves as though all off-diagonal elements,\n`M[i, j]` where `i != j`, are zero.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, DiagonalMatrix, Symbol\n>>> n = Symbol('n', integer=True)\n>>> m = Symbol('m', integer=True)\n>>> D = DiagonalMatrix(MatrixSymbol('x', 2, 3))\n>>> D[1, 2]\n0\n>>> D[1, 1]\nx[1, 1]\n\nThe length of the diagonal -- the lesser of the two dimensions of `M` --\nis accessed through the `diagonal_length` property:\n\n>>> D.diagonal_length\n2\n>>> DiagonalMatrix(MatrixSymbol('x', n + 1, n)).diagonal_length\nn\n\nWhen one of the dimensions is symbolic the other will be treated as\nthough it is smaller:\n\n>>> tall = DiagonalMatrix(MatrixSymbol('x', n, 3))\n>>> tall.diagonal_length\n3\n>>> tall[10, 1]\n0\n\nWhen the size of the diagonal is not known, a value of None will\nbe returned:\n\n>>> DiagonalMatrix(MatrixSymbol('x', n, m)).diagonal_length is None\nTrue",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "DiagonalOf": {
        "full_name": "sympy.matrices.DiagonalOf",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "DiagonalOf(M) will create a matrix expression that\nis equivalent to the diagonal of `M`, represented as\na single column matrix.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, DiagonalOf, Symbol\n>>> n = Symbol('n', integer=True)\n>>> m = Symbol('m', integer=True)\n>>> x = MatrixSymbol('x', 2, 3)\n>>> diag = DiagonalOf(x)\n>>> diag.shape\n(2, 1)\n\nThe diagonal can be addressed like a matrix or vector and will\nreturn the corresponding element of the original matrix:\n\n>>> diag[1, 0] == diag[1] == x[1, 1]\nTrue\n\nThe length of the diagonal -- the lesser of the two dimensions of `M` --\nis accessed through the `diagonal_length` property:\n\n>>> diag.diagonal_length\n2\n>>> DiagonalOf(MatrixSymbol('x', n + 1, n)).diagonal_length\nn\n\nWhen only one of the dimensions is symbolic the other will be\ntreated as though it is smaller:\n\n>>> dtall = DiagonalOf(MatrixSymbol('x', n, 3))\n>>> dtall.diagonal_length\n3\n\nWhen the size of the diagonal is not known, a value of None will\nbe returned:\n\n>>> DiagonalOf(MatrixSymbol('x', n, m)).diagonal_length is None\nTrue",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "DotProduct": {
        "full_name": "sympy.matrices.DotProduct",
        "bases": [
          "Expr"
        ],
        "doc": "Dot product of vector matrices\n\nThe input should be two 1 x n or n x 1 matrices. The output represents the\nscalar dotproduct.\n\nThis is similar to using MatrixElement and MatMul, except DotProduct does\nnot require that one vector to be a row vector and the other vector to be\na column vector.\n\n>>> from sympy import MatrixSymbol, DotProduct\n>>> A = MatrixSymbol('A', 1, 3)\n>>> B = MatrixSymbol('B', 1, 3)\n>>> DotProduct(A, B)\nDotProduct(A, B)\n>>> DotProduct(A, B).doit()\nA[0, 0]*B[0, 0] + A[0, 1]*B[0, 1] + A[0, 2]*B[0, 2]",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      },
      "FunctionMatrix": {
        "full_name": "sympy.matrices.FunctionMatrix",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "Represents a matrix using a function (``Lambda``) which gives\noutputs according to the coordinates of each matrix entries.\n\nParameters\n==========\n\nrows : nonnegative integer. Can be symbolic.\n\ncols : nonnegative integer. Can be symbolic.\n\nlamda : Function, Lambda or str\n    If it is a SymPy ``Function`` or ``Lambda`` instance,\n    it should be able to accept two arguments which represents the\n    matrix coordinates.\n\n    If it is a pure string containing Python ``lambda`` semantics,\n    it is interpreted by the SymPy parser and casted into a SymPy\n    ``Lambda`` instance.\n\nExamples\n========\n\nCreating a ``FunctionMatrix`` from ``Lambda``:\n\n>>> from sympy import FunctionMatrix, symbols, Lambda, MatPow\n>>> i, j, n, m = symbols('i,j,n,m')\n>>> FunctionMatrix(n, m, Lambda((i, j), i + j))\nFunctionMatrix(n, m, Lambda((i, j), i + j))\n\nCreating a ``FunctionMatrix`` from a SymPy function:\n\n>>> from sympy import KroneckerDelta\n>>> X = FunctionMatrix(3, 3, KroneckerDelta)\n>>> X.as_explicit()\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n\nCreating a ``FunctionMatrix`` from a SymPy undefined function:\n\n>>> from sympy import Function\n>>> f = Function('f')\n>>> X = FunctionMatrix(3, 3, f)\n>>> X.as_explicit()\nMatrix([\n[f(0, 0), f(0, 1), f(0, 2)],\n[f(1, 0), f(1, 1), f(1, 2)],\n[f(2, 0), f(2, 1), f(2, 2)]])\n\nCreating a ``FunctionMatrix`` from Python ``lambda``:\n\n>>> FunctionMatrix(n, m, 'lambda i, j: i + j')\nFunctionMatrix(n, m, Lambda((i, j), i + j))\n\nExample of lazy evaluation of matrix product:\n\n>>> Y = FunctionMatrix(1000, 1000, Lambda((i, j), i + j))\n>>> isinstance(Y*Y, MatPow) # this is an expression object\nTrue\n>>> (Y**2)[10,10] # So this is evaluated lazily\n342923500\n\nNotes\n=====\n\nThis class provides an alternative way to represent an extremely\ndense matrix with entries in some form of a sequence, in a most\nsparse way.",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "HadamardPower": {
        "full_name": "sympy.matrices.HadamardPower",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "Elementwise power of matrix expressions\n\nParameters\n==========\n\nbase : scalar or matrix\n\nexp : scalar or matrix\n\nNotes\n=====\n\nThere are four definitions for the hadamard power which can be used.\nLet's consider `A, B` as `(m, n)` matrices, and `a, b` as scalars.\n\nMatrix raised to a scalar exponent:\n\n.. math::\n    A^{\\circ b} = \\begin{bmatrix}\n    A_{0, 0}^b   & A_{0, 1}^b   & \\cdots & A_{0, n-1}^b   \\\\\n    A_{1, 0}^b   & A_{1, 1}^b   & \\cdots & A_{1, n-1}^b   \\\\\n    \\vdots       & \\vdots       & \\ddots & \\vdots         \\\\\n    A_{m-1, 0}^b & A_{m-1, 1}^b & \\cdots & A_{m-1, n-1}^b\n    \\end{bmatrix}\n\nScalar raised to a matrix exponent:\n\n.. math::\n    a^{\\circ B} = \\begin{bmatrix}\n    a^{B_{0, 0}}   & a^{B_{0, 1}}   & \\cdots & a^{B_{0, n-1}}   \\\\\n    a^{B_{1, 0}}   & a^{B_{1, 1}}   & \\cdots & a^{B_{1, n-1}}   \\\\\n    \\vdots         & \\vdots         & \\ddots & \\vdots           \\\\\n    a^{B_{m-1, 0}} & a^{B_{m-1, 1}} & \\cdots & a^{B_{m-1, n-1}}\n    \\end{bmatrix}\n\nMatrix raised to a matrix exponent:\n\n.. math::\n    A^{\\circ B} = \\begin{bmatrix}\n    A_{0, 0}^{B_{0, 0}}     & A_{0, 1}^{B_{0, 1}}     &\n    \\cdots & A_{0, n-1}^{B_{0, n-1}}     \\\\\n    A_{1, 0}^{B_{1, 0}}     & A_{1, 1}^{B_{1, 1}}     &\n    \\cdots & A_{1, n-1}^{B_{1, n-1}}     \\\\\n    \\vdots                  & \\vdots                  &\n    \\ddots & \\vdots                      \\\\\n    A_{m-1, 0}^{B_{m-1, 0}} & A_{m-1, 1}^{B_{m-1, 1}} &\n    \\cdots & A_{m-1, n-1}^{B_{m-1, n-1}}\n    \\end{bmatrix}\n\nScalar raised to a scalar exponent:\n\n.. math::\n    a^{\\circ b} = a^b",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "HadamardProduct": {
        "full_name": "sympy.matrices.HadamardProduct",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "Elementwise product of matrix expressions\n\nExamples\n========\n\nHadamard product for matrix symbols:\n\n>>> from sympy import hadamard_product, HadamardProduct, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 5)\n>>> B = MatrixSymbol('B', 5, 5)\n>>> isinstance(hadamard_product(A, B), HadamardProduct)\nTrue\n\nNotes\n=====\n\nThis is a symbolic object that simply stores its argument without\nevaluating it. To actually compute the product, use the function\n``hadamard_product()`` or ``HadamardProduct.doit``",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "Identity": {
        "full_name": "sympy.matrices.Identity",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "The Matrix Identity I - multiplicative identity\n\nExamples\n========\n\n>>> from sympy import Identity, MatrixSymbol\n>>> A = MatrixSymbol('A', 3, 5)\n>>> I = Identity(3)\n>>> I*A\nA",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "ImmutableDenseMatrix": {
        "full_name": "sympy.matrices.ImmutableDenseMatrix",
        "bases": [
          "DenseMatrix",
          "ImmutableRepMatrix"
        ],
        "doc": "Create an immutable version of a matrix.\n\nExamples\n========\n\n>>> from sympy import eye, ImmutableMatrix\n>>> ImmutableMatrix(eye(3))\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> _[0, 0] = 42\nTraceback (most recent call last):\n...\nTypeError: Cannot set values of ImmutableDenseMatrix",
        "methods": {
          "LDLdecomposition": {
            "doc": "Returns the LDL Decomposition (L, D) of matrix A,\nsuch that L * D * L.H == A if hermitian flag is True, or\nL * D * L.T == A if hermitian is False.\nThis method eliminates the use of square root.\nFurther this ensures that all the diagonal entries of L are 1.\nA must be a Hermitian positive-definite matrix if hermitian is True,\nor a symmetric matrix otherwise.\n\nExamples\n========\n\n>>> from sympy import Matrix, eye\n>>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))\n>>> L, D = A.LDLdecomposition()\n>>> L\nMatrix([\n[   1,   0, 0],\n[ 3/5,   1, 0],\n[-1/5, 1/3, 1]])\n>>> D\nMatrix([\n[25, 0, 0],\n[ 0, 9, 0],\n[ 0, 0, 9]])\n>>> L * D * L.T * A.inv() == eye(A.rows)\nTrue\n\nThe matrix can have complex entries:\n\n>>> from sympy import I\n>>> A = Matrix(((9, 3*I), (-3*I, 5)))\n>>> L, D = A.LDLdecomposition()\n>>> L\nMatrix([\n[   1, 0],\n[-I/3, 1]])\n>>> D\nMatrix([\n[9, 0],\n[0, 4]])\n>>> L*D*L.H == A\nTrue\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.cholesky\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nQRdecomposition",
            "signature": "(self, hermitian=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "hermitian": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LDLsolve": {
            "doc": "Solves ``Ax = B`` using LDL decomposition,\nfor a general square and non-singular matrix.\n\nFor a non-square matrix with rows > cols,\nthe least squares solution is returned.\n\nExamples\n========\n\n>>> from sympy import Matrix, eye\n>>> A = eye(2)*2\n>>> B = Matrix([[1, 2], [3, 4]])\n>>> A.LDLsolve(B) == B/2\nTrue\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.LDLdecomposition\nsympy.matrices.dense.DenseMatrix.lower_triangular_solve\nsympy.matrices.dense.DenseMatrix.upper_triangular_solve\ngauss_jordan_solve\ncholesky_solve\ndiagonal_solve\nLUsolve\nQRsolve\npinv_solve\ncramer_solve",
            "signature": "(self, rhs)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rhs": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecomposition": {
            "doc": "Returns (L, U, perm) where L is a lower triangular matrix with unit\ndiagonal, U is an upper triangular matrix, and perm is a list of row\nswap index pairs. If A is the original matrix, then\n``A = (L*U).permuteBkwd(perm)``, and the row permutation matrix P such\nthat $P A = L U$ can be computed by ``P = eye(A.rows).permuteFwd(perm)``.\n\nSee documentation for LUCombined for details about the keyword argument\nrankcheck, iszerofunc, and simpfunc.\n\nParameters\n==========\n\nrankcheck : bool, optional\n    Determines if this function should detect the rank\n    deficiency of the matrixis and should raise a\n    ``ValueError``.\n\niszerofunc : function, optional\n    A function which determines if a given expression is zero.\n\n    The function should be a callable that takes a single\n    SymPy expression and returns a 3-valued boolean value\n    ``True``, ``False``, or ``None``.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nsimpfunc : function or None, optional\n    A function that simplifies the input.\n\n    If this is specified as a function, this function should be\n    a callable that takes a single SymPy expression and returns\n    an another SymPy expression that is algebraically\n    equivalent.\n\n    If ``None``, it indicates that the pivot search algorithm\n    should not attempt to simplify any candidate pivots.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nExamples\n========\n\n>>> from sympy import Matrix\n>>> a = Matrix([[4, 3], [6, 3]])\n>>> L, U, _ = a.LUdecomposition()\n>>> L\nMatrix([\n[  1, 0],\n[3/2, 1]])\n>>> U\nMatrix([\n[4,    3],\n[0, -3/2]])\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.cholesky\nsympy.matrices.dense.DenseMatrix.LDLdecomposition\nQRdecomposition\nLUdecomposition_Simple\nLUdecompositionFF\nLUsolve",
            "signature": "(self, iszerofunc=<function _iszero at 0x7f1c4ab3d440>, simpfunc=None, rankcheck=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "iszerofunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "<function _iszero at 0x7f1c4ab3d440>",
                "annotation": null
              },
              "simpfunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "rankcheck": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecompositionFF": {
            "doc": "Compute a fraction-free LU decomposition.\n\nReturns 4 matrices P, L, D, U such that PA = L D**-1 U.\nIf the elements of the matrix belong to some integral domain I, then all\nelements of L, D and U are guaranteed to belong to I.\n\nSee Also\n========\n\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nLUdecomposition_Simple\nLUsolve\n\nReferences\n==========\n\n.. [1] W. Zhou & D.J. Jeffrey, \"Fraction-free matrix factors: new forms\n    for LU and QR factors\". Frontiers in Computer Science in China,\n    Vol 2, no. 1, pp. 67-80, 2008.",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecomposition_Simple": {
            "doc": "Compute the PLU decomposition of the matrix.\n\nParameters\n==========\n\nrankcheck : bool, optional\n    Determines if this function should detect the rank\n    deficiency of the matrixis and should raise a\n    ``ValueError``.\n\niszerofunc : function, optional\n    A function which determines if a given expression is zero.\n\n    The function should be a callable that takes a single\n    SymPy expression and returns a 3-valued boolean value\n    ``True``, ``False``, or ``None``.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nsimpfunc : function or None, optional\n    A function that simplifies the input.\n\n    If this is specified as a function, this function should be\n    a callable that takes a single SymPy expression and returns\n    an another SymPy expression that is algebraically\n    equivalent.\n\n    If ``None``, it indicates that the pivot search algorithm\n    should not attempt to simplify any candidate pivots.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nReturns\n=======\n\n(lu, row_swaps) : (Matrix, list)\n    If the original matrix is a $m, n$ matrix:\n\n    *lu* is a $m, n$ matrix, which contains result of the\n    decomposition in a compressed form. See the notes section\n    to see how the matrix is compressed.\n\n    *row_swaps* is a $m$-element list where each element is a\n    pair of row exchange indices.\n\n    ``A = (L*U).permute_backward(perm)``, and the row\n    permutation matrix $P$ from the formula $P A = L U$ can be\n    computed by ``P=eye(A.row).permute_forward(perm)``.\n\nRaises\n======\n\nValueError\n    Raised if ``rankcheck=True`` and the matrix is found to\n    be rank deficient during the computation.\n\nNotes\n=====\n\nAbout the PLU decomposition:\n\nPLU decomposition is a generalization of a LU decomposition\nwhich can be extended for rank-deficient matrices.\n\nIt can further be generalized for non-square matrices, and this\nis the notation that SymPy is using.\n\nPLU decomposition is a decomposition of a $m, n$ matrix $A$ in\nthe form of $P A = L U$ where\n\n* $L$ is a $m, m$ lower triangular matrix with unit diagonal\n    entries.\n* $U$ is a $m, n$ upper triangular matrix.\n* $P$ is a $m, m$ permutation matrix.\n\nSo, for a square matrix, the decomposition would look like:\n\n.. math::\n    L = \\begin{bmatrix}\n    1 & 0 & 0 & \\cdots & 0 \\\\\n    L_{1, 0} & 1 & 0 & \\cdots & 0 \\\\\n    L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & 1\n    \\end{bmatrix}\n\n.. math::\n    U = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    0 & 0 & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & U_{n-1, n-1}\n    \\end{bmatrix}\n\nAnd for a matrix with more rows than the columns,\nthe decomposition would look like:\n\n.. math::\n    L = \\begin{bmatrix}\n    1 & 0 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n    L_{1, 0} & 1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n    L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\ddots\n    & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & 1 & 0\n    & \\cdots & 0 \\\\\n    L_{n, 0} & L_{n, 1} & L_{n, 2} & \\cdots & L_{n, n-1} & 1\n    & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots\n    & \\ddots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & L_{m-1, n-1}\n    & 0 & \\cdots & 1 \\\\\n    \\end{bmatrix}\n\n.. math::\n    U = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    0 & 0 & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & U_{n-1, n-1} \\\\\n    0 & 0 & 0 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & 0\n    \\end{bmatrix}\n\nFinally, for a matrix with more columns than the rows, the\ndecomposition would look like:\n\n.. math::\n    L = \\begin{bmatrix}\n    1 & 0 & 0 & \\cdots & 0 \\\\\n    L_{1, 0} & 1 & 0 & \\cdots & 0 \\\\\n    L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & 1\n    \\end{bmatrix}\n\n.. math::\n    U = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, m-1}\n    & \\cdots & U_{0, n-1} \\\\\n    0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, m-1}\n    & \\cdots & U_{1, n-1} \\\\\n    0 & 0 & U_{2, 2} & \\cdots & U_{2, m-1}\n    & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\n    & \\cdots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & U_{m-1, m-1}\n    & \\cdots & U_{m-1, n-1} \\\\\n    \\end{bmatrix}\n\nAbout the compressed LU storage:\n\nThe results of the decomposition are often stored in compressed\nforms rather than returning $L$ and $U$ matrices individually.\n\nIt may be less intiuitive, but it is commonly used for a lot of\nnumeric libraries because of the efficiency.\n\nThe storage matrix is defined as following for this specific\nmethod:\n\n* The subdiagonal elements of $L$ are stored in the subdiagonal\n    portion of $LU$, that is $LU_{i, j} = L_{i, j}$ whenever\n    $i > j$.\n* The elements on the diagonal of $L$ are all 1, and are not\n    explicitly stored.\n* $U$ is stored in the upper triangular portion of $LU$, that is\n    $LU_{i, j} = U_{i, j}$ whenever $i <= j$.\n* For a case of $m > n$, the right side of the $L$ matrix is\n    trivial to store.\n* For a case of $m < n$, the below side of the $U$ matrix is\n    trivial to store.\n\nSo, for a square matrix, the compressed output matrix would be:\n\n.. math::\n    LU = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & U_{n-1, n-1}\n    \\end{bmatrix}\n\nFor a matrix with more rows than the columns, the compressed\noutput matrix would be:\n\n.. math::\n    LU = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots\n    & U_{n-1, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots\n    & L_{m-1, n-1} \\\\\n    \\end{bmatrix}\n\nFor a matrix with more columns than the rows, the compressed\noutput matrix would be:\n\n.. math::\n    LU = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, m-1}\n    & \\cdots & U_{0, n-1} \\\\\n    L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, m-1}\n    & \\cdots & U_{1, n-1} \\\\\n    L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, m-1}\n    & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\n    & \\cdots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & U_{m-1, m-1}\n    & \\cdots & U_{m-1, n-1} \\\\\n    \\end{bmatrix}\n\nAbout the pivot searching algorithm:\n\nWhen a matrix contains symbolic entries, the pivot search algorithm\ndiffers from the case where every entry can be categorized as zero or\nnonzero.\nThe algorithm searches column by column through the submatrix whose\ntop left entry coincides with the pivot position.\nIf it exists, the pivot is the first entry in the current search\ncolumn that iszerofunc guarantees is nonzero.\nIf no such candidate exists, then each candidate pivot is simplified\nif simpfunc is not None.\nThe search is repeated, with the difference that a candidate may be\nthe pivot if ``iszerofunc()`` cannot guarantee that it is nonzero.\nIn the second search the pivot is the first candidate that\niszerofunc can guarantee is nonzero.\nIf no such candidate exists, then the pivot is the first candidate\nfor which iszerofunc returns None.\nIf no such candidate exists, then the search is repeated in the next\ncolumn to the right.\nThe pivot search algorithm differs from the one in ``rref()``, which\nrelies on ``_find_reasonable_pivot()``.\nFuture versions of ``LUdecomposition_simple()`` may use\n``_find_reasonable_pivot()``.\n\nSee Also\n========\n\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nLUdecompositionFF\nLUsolve",
            "signature": "(self, iszerofunc=<function _iszero at 0x7f1c4ab3d440>, simpfunc=None, rankcheck=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "iszerofunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "<function _iszero at 0x7f1c4ab3d440>",
                "annotation": null
              },
              "simpfunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "rankcheck": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUsolve": {
            "doc": "Solve the linear system ``Ax = rhs`` for ``x`` where ``A = M``.\n\nThis is for symbolic matrices, for real or complex ones use\nmpmath.lu_solve or mpmath.qr_solve.\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.lower_triangular_solve\nsympy.matrices.dense.DenseMatrix.upper_triangular_solve\ngauss_jordan_solve\ncholesky_solve\ndiagonal_solve\nLDLsolve\nQRsolve\npinv_solve\nLUdecomposition\ncramer_solve",
            "signature": "(self, rhs, iszerofunc=<function _iszero at 0x7f1c4ab3d440>)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rhs": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "iszerofunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "<function _iszero at 0x7f1c4ab3d440>",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "QRdecomposition": {
            "doc": "Returns a QR decomposition.\n\nExplanation\n===========\n\nA QR decomposition is a decomposition in the form $A = Q R$\nwhere\n\n- $Q$ is a column orthogonal matrix.\n- $R$ is a upper triangular (trapezoidal) matrix.\n\nA column orthogonal matrix satisfies\n$\\mathbb{I} = Q^H Q$ while a full orthogonal matrix satisfies\nrelation $\\mathbb{I} = Q Q^H = Q^H Q$ where $I$ is an identity\nmatrix with matching dimensions.\n\nFor matrices which are not square or are rank-deficient, it is\nsufficient to return a column orthogonal matrix because augmenting\nthem may introduce redundant computations.\nAnd an another advantage of this is that you can easily inspect the\nmatrix rank by counting the number of columns of $Q$.\n\nIf you want to augment the results to return a full orthogonal\ndecomposition, you should use the following procedures.\n\n- Augment the $Q$ matrix with columns that are orthogonal to every\n  other columns and make it square.\n- Augment the $R$ matrix with zero rows to make it have the same\n  shape as the original matrix.\n\nThe procedure will be illustrated in the examples section.\n\nExamples\n========\n\nA full rank matrix example:\n\n>>> from sympy import Matrix\n>>> A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])\n>>> Q, R = A.QRdecomposition()\n>>> Q\nMatrix([\n[ 6/7, -69/175, -58/175],\n[ 3/7, 158/175,   6/175],\n[-2/7,    6/35,  -33/35]])\n>>> R\nMatrix([\n[14,  21, -14],\n[ 0, 175, -70],\n[ 0,   0,  35]])\n\nIf the matrix is square and full rank, the $Q$ matrix becomes\northogonal in both directions, and needs no augmentation.\n\n>>> Q * Q.H\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> Q.H * Q\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n\n>>> A == Q*R\nTrue\n\nA rank deficient matrix example:\n\n>>> A = Matrix([[12, -51, 0], [6, 167, 0], [-4, 24, 0]])\n>>> Q, R = A.QRdecomposition()\n>>> Q\nMatrix([\n[ 6/7, -69/175],\n[ 3/7, 158/175],\n[-2/7,    6/35]])\n>>> R\nMatrix([\n[14,  21, 0],\n[ 0, 175, 0]])\n\nQRdecomposition might return a matrix Q that is rectangular.\nIn this case the orthogonality condition might be satisfied as\n$\\mathbb{I} = Q.H*Q$ but not in the reversed product\n$\\mathbb{I} = Q * Q.H$.\n\n>>> Q.H * Q\nMatrix([\n[1, 0],\n[0, 1]])\n>>> Q * Q.H\nMatrix([\n[27261/30625,   348/30625, -1914/6125],\n[  348/30625, 30589/30625,   198/6125],\n[ -1914/6125,    198/6125,   136/1225]])\n\nIf you want to augment the results to be a full orthogonal\ndecomposition, you should augment $Q$ with an another orthogonal\ncolumn.\n\nYou are able to append an identity matrix,\nand you can run the Gram-Schmidt\nprocess to make them augmented as orthogonal basis.\n\n>>> Q_aug = Q.row_join(Matrix.eye(3))\n>>> Q_aug = Q_aug.QRdecomposition()[0]\n>>> Q_aug\nMatrix([\n[ 6/7, -69/175, 58/175],\n[ 3/7, 158/175, -6/175],\n[-2/7,    6/35,  33/35]])\n>>> Q_aug.H * Q_aug\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> Q_aug * Q_aug.H\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n\nAugmenting the $R$ matrix with zero row is straightforward.\n\n>>> R_aug = R.col_join(Matrix([[0, 0, 0]]))\n>>> R_aug\nMatrix([\n[14,  21, 0],\n[ 0, 175, 0],\n[ 0,   0, 0]])\n>>> Q_aug * R_aug == A\nTrue\n\nA zero matrix example:\n\n>>> from sympy import Matrix\n>>> A = Matrix.zeros(3, 4)\n>>> Q, R = A.QRdecomposition()\n\nThey may return matrices with zero rows and columns.\n\n>>> Q\nMatrix(3, 0, [])\n>>> R\nMatrix(0, 4, [])\n>>> Q*R\nMatrix([\n[0, 0, 0, 0],\n[0, 0, 0, 0],\n[0, 0, 0, 0]])\n\nAs the same augmentation rule described above, $Q$ can be augmented\nwith columns of an identity matrix and $R$ can be augmented with\nrows of a zero matrix.\n\n>>> Q_aug = Q.row_join(Matrix.eye(3))\n>>> R_aug = R.col_join(Matrix.zeros(3, 4))\n>>> Q_aug * Q_aug.T\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> R_aug\nMatrix([\n[0, 0, 0, 0],\n[0, 0, 0, 0],\n[0, 0, 0, 0]])\n>>> Q_aug * R_aug == A\nTrue\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.cholesky\nsympy.matrices.dense.DenseMatrix.LDLdecomposition\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nQRsolve",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "QRsolve": {
            "doc": "Solve the linear system ``Ax = b``.\n\n``M`` is the matrix ``A``, the method argument is the vector\n``b``.  The method returns the solution vector ``x``.  If ``b`` is a\nmatrix, the system is solved for each column of ``b`` and the\nreturn value is a matrix of the same shape as ``b``.\n\nThis method is slower (approximately by a factor of 2) but\nmore stable for floating-point arithmetic than the LUsolve method.\nHowever, LUsolve usually uses an exact arithmetic, so you do not need\nto use QRsolve.\n\nThis is mainly for educational purposes and symbolic matrices, for real\n(or complex) matrices use mpmath.qr_solve.\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.lower_triangular_solve\nsympy.matrices.dense.DenseMatrix.upper_triangular_solve\ngauss_jordan_solve\ncholesky_solve\ndiagonal_solve\nLDLsolve\nLUsolve\npinv_solve\nQRdecomposition\ncramer_solve",
            "signature": "(self, b)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "b": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "add": {
            "doc": "Return self + b.",
            "signature": "(self, b)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "b": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "adjoint": {
            "doc": "Conjugate transpose or Hermitian conjugation.",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "ImmutableMatrix": {
        "full_name": "sympy.matrices.ImmutableMatrix",
        "bases": [
          "DenseMatrix",
          "ImmutableRepMatrix"
        ],
        "doc": "Create an immutable version of a matrix.\n\nExamples\n========\n\n>>> from sympy import eye, ImmutableMatrix\n>>> ImmutableMatrix(eye(3))\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> _[0, 0] = 42\nTraceback (most recent call last):\n...\nTypeError: Cannot set values of ImmutableDenseMatrix",
        "methods": {
          "LDLdecomposition": {
            "doc": "Returns the LDL Decomposition (L, D) of matrix A,\nsuch that L * D * L.H == A if hermitian flag is True, or\nL * D * L.T == A if hermitian is False.\nThis method eliminates the use of square root.\nFurther this ensures that all the diagonal entries of L are 1.\nA must be a Hermitian positive-definite matrix if hermitian is True,\nor a symmetric matrix otherwise.\n\nExamples\n========\n\n>>> from sympy import Matrix, eye\n>>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))\n>>> L, D = A.LDLdecomposition()\n>>> L\nMatrix([\n[   1,   0, 0],\n[ 3/5,   1, 0],\n[-1/5, 1/3, 1]])\n>>> D\nMatrix([\n[25, 0, 0],\n[ 0, 9, 0],\n[ 0, 0, 9]])\n>>> L * D * L.T * A.inv() == eye(A.rows)\nTrue\n\nThe matrix can have complex entries:\n\n>>> from sympy import I\n>>> A = Matrix(((9, 3*I), (-3*I, 5)))\n>>> L, D = A.LDLdecomposition()\n>>> L\nMatrix([\n[   1, 0],\n[-I/3, 1]])\n>>> D\nMatrix([\n[9, 0],\n[0, 4]])\n>>> L*D*L.H == A\nTrue\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.cholesky\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nQRdecomposition",
            "signature": "(self, hermitian=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "hermitian": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LDLsolve": {
            "doc": "Solves ``Ax = B`` using LDL decomposition,\nfor a general square and non-singular matrix.\n\nFor a non-square matrix with rows > cols,\nthe least squares solution is returned.\n\nExamples\n========\n\n>>> from sympy import Matrix, eye\n>>> A = eye(2)*2\n>>> B = Matrix([[1, 2], [3, 4]])\n>>> A.LDLsolve(B) == B/2\nTrue\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.LDLdecomposition\nsympy.matrices.dense.DenseMatrix.lower_triangular_solve\nsympy.matrices.dense.DenseMatrix.upper_triangular_solve\ngauss_jordan_solve\ncholesky_solve\ndiagonal_solve\nLUsolve\nQRsolve\npinv_solve\ncramer_solve",
            "signature": "(self, rhs)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rhs": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecomposition": {
            "doc": "Returns (L, U, perm) where L is a lower triangular matrix with unit\ndiagonal, U is an upper triangular matrix, and perm is a list of row\nswap index pairs. If A is the original matrix, then\n``A = (L*U).permuteBkwd(perm)``, and the row permutation matrix P such\nthat $P A = L U$ can be computed by ``P = eye(A.rows).permuteFwd(perm)``.\n\nSee documentation for LUCombined for details about the keyword argument\nrankcheck, iszerofunc, and simpfunc.\n\nParameters\n==========\n\nrankcheck : bool, optional\n    Determines if this function should detect the rank\n    deficiency of the matrixis and should raise a\n    ``ValueError``.\n\niszerofunc : function, optional\n    A function which determines if a given expression is zero.\n\n    The function should be a callable that takes a single\n    SymPy expression and returns a 3-valued boolean value\n    ``True``, ``False``, or ``None``.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nsimpfunc : function or None, optional\n    A function that simplifies the input.\n\n    If this is specified as a function, this function should be\n    a callable that takes a single SymPy expression and returns\n    an another SymPy expression that is algebraically\n    equivalent.\n\n    If ``None``, it indicates that the pivot search algorithm\n    should not attempt to simplify any candidate pivots.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nExamples\n========\n\n>>> from sympy import Matrix\n>>> a = Matrix([[4, 3], [6, 3]])\n>>> L, U, _ = a.LUdecomposition()\n>>> L\nMatrix([\n[  1, 0],\n[3/2, 1]])\n>>> U\nMatrix([\n[4,    3],\n[0, -3/2]])\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.cholesky\nsympy.matrices.dense.DenseMatrix.LDLdecomposition\nQRdecomposition\nLUdecomposition_Simple\nLUdecompositionFF\nLUsolve",
            "signature": "(self, iszerofunc=<function _iszero at 0x7f1c4ab3d440>, simpfunc=None, rankcheck=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "iszerofunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "<function _iszero at 0x7f1c4ab3d440>",
                "annotation": null
              },
              "simpfunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "rankcheck": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecompositionFF": {
            "doc": "Compute a fraction-free LU decomposition.\n\nReturns 4 matrices P, L, D, U such that PA = L D**-1 U.\nIf the elements of the matrix belong to some integral domain I, then all\nelements of L, D and U are guaranteed to belong to I.\n\nSee Also\n========\n\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nLUdecomposition_Simple\nLUsolve\n\nReferences\n==========\n\n.. [1] W. Zhou & D.J. Jeffrey, \"Fraction-free matrix factors: new forms\n    for LU and QR factors\". Frontiers in Computer Science in China,\n    Vol 2, no. 1, pp. 67-80, 2008.",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecomposition_Simple": {
            "doc": "Compute the PLU decomposition of the matrix.\n\nParameters\n==========\n\nrankcheck : bool, optional\n    Determines if this function should detect the rank\n    deficiency of the matrixis and should raise a\n    ``ValueError``.\n\niszerofunc : function, optional\n    A function which determines if a given expression is zero.\n\n    The function should be a callable that takes a single\n    SymPy expression and returns a 3-valued boolean value\n    ``True``, ``False``, or ``None``.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nsimpfunc : function or None, optional\n    A function that simplifies the input.\n\n    If this is specified as a function, this function should be\n    a callable that takes a single SymPy expression and returns\n    an another SymPy expression that is algebraically\n    equivalent.\n\n    If ``None``, it indicates that the pivot search algorithm\n    should not attempt to simplify any candidate pivots.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nReturns\n=======\n\n(lu, row_swaps) : (Matrix, list)\n    If the original matrix is a $m, n$ matrix:\n\n    *lu* is a $m, n$ matrix, which contains result of the\n    decomposition in a compressed form. See the notes section\n    to see how the matrix is compressed.\n\n    *row_swaps* is a $m$-element list where each element is a\n    pair of row exchange indices.\n\n    ``A = (L*U).permute_backward(perm)``, and the row\n    permutation matrix $P$ from the formula $P A = L U$ can be\n    computed by ``P=eye(A.row).permute_forward(perm)``.\n\nRaises\n======\n\nValueError\n    Raised if ``rankcheck=True`` and the matrix is found to\n    be rank deficient during the computation.\n\nNotes\n=====\n\nAbout the PLU decomposition:\n\nPLU decomposition is a generalization of a LU decomposition\nwhich can be extended for rank-deficient matrices.\n\nIt can further be generalized for non-square matrices, and this\nis the notation that SymPy is using.\n\nPLU decomposition is a decomposition of a $m, n$ matrix $A$ in\nthe form of $P A = L U$ where\n\n* $L$ is a $m, m$ lower triangular matrix with unit diagonal\n    entries.\n* $U$ is a $m, n$ upper triangular matrix.\n* $P$ is a $m, m$ permutation matrix.\n\nSo, for a square matrix, the decomposition would look like:\n\n.. math::\n    L = \\begin{bmatrix}\n    1 & 0 & 0 & \\cdots & 0 \\\\\n    L_{1, 0} & 1 & 0 & \\cdots & 0 \\\\\n    L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & 1\n    \\end{bmatrix}\n\n.. math::\n    U = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    0 & 0 & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & U_{n-1, n-1}\n    \\end{bmatrix}\n\nAnd for a matrix with more rows than the columns,\nthe decomposition would look like:\n\n.. math::\n    L = \\begin{bmatrix}\n    1 & 0 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n    L_{1, 0} & 1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n    L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\ddots\n    & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & 1 & 0\n    & \\cdots & 0 \\\\\n    L_{n, 0} & L_{n, 1} & L_{n, 2} & \\cdots & L_{n, n-1} & 1\n    & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots\n    & \\ddots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & L_{m-1, n-1}\n    & 0 & \\cdots & 1 \\\\\n    \\end{bmatrix}\n\n.. math::\n    U = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    0 & 0 & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & U_{n-1, n-1} \\\\\n    0 & 0 & 0 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & 0\n    \\end{bmatrix}\n\nFinally, for a matrix with more columns than the rows, the\ndecomposition would look like:\n\n.. math::\n    L = \\begin{bmatrix}\n    1 & 0 & 0 & \\cdots & 0 \\\\\n    L_{1, 0} & 1 & 0 & \\cdots & 0 \\\\\n    L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & 1\n    \\end{bmatrix}\n\n.. math::\n    U = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, m-1}\n    & \\cdots & U_{0, n-1} \\\\\n    0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, m-1}\n    & \\cdots & U_{1, n-1} \\\\\n    0 & 0 & U_{2, 2} & \\cdots & U_{2, m-1}\n    & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\n    & \\cdots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & U_{m-1, m-1}\n    & \\cdots & U_{m-1, n-1} \\\\\n    \\end{bmatrix}\n\nAbout the compressed LU storage:\n\nThe results of the decomposition are often stored in compressed\nforms rather than returning $L$ and $U$ matrices individually.\n\nIt may be less intiuitive, but it is commonly used for a lot of\nnumeric libraries because of the efficiency.\n\nThe storage matrix is defined as following for this specific\nmethod:\n\n* The subdiagonal elements of $L$ are stored in the subdiagonal\n    portion of $LU$, that is $LU_{i, j} = L_{i, j}$ whenever\n    $i > j$.\n* The elements on the diagonal of $L$ are all 1, and are not\n    explicitly stored.\n* $U$ is stored in the upper triangular portion of $LU$, that is\n    $LU_{i, j} = U_{i, j}$ whenever $i <= j$.\n* For a case of $m > n$, the right side of the $L$ matrix is\n    trivial to store.\n* For a case of $m < n$, the below side of the $U$ matrix is\n    trivial to store.\n\nSo, for a square matrix, the compressed output matrix would be:\n\n.. math::\n    LU = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & U_{n-1, n-1}\n    \\end{bmatrix}\n\nFor a matrix with more rows than the columns, the compressed\noutput matrix would be:\n\n.. math::\n    LU = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots\n    & U_{n-1, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots\n    & L_{m-1, n-1} \\\\\n    \\end{bmatrix}\n\nFor a matrix with more columns than the rows, the compressed\noutput matrix would be:\n\n.. math::\n    LU = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, m-1}\n    & \\cdots & U_{0, n-1} \\\\\n    L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, m-1}\n    & \\cdots & U_{1, n-1} \\\\\n    L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, m-1}\n    & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\n    & \\cdots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & U_{m-1, m-1}\n    & \\cdots & U_{m-1, n-1} \\\\\n    \\end{bmatrix}\n\nAbout the pivot searching algorithm:\n\nWhen a matrix contains symbolic entries, the pivot search algorithm\ndiffers from the case where every entry can be categorized as zero or\nnonzero.\nThe algorithm searches column by column through the submatrix whose\ntop left entry coincides with the pivot position.\nIf it exists, the pivot is the first entry in the current search\ncolumn that iszerofunc guarantees is nonzero.\nIf no such candidate exists, then each candidate pivot is simplified\nif simpfunc is not None.\nThe search is repeated, with the difference that a candidate may be\nthe pivot if ``iszerofunc()`` cannot guarantee that it is nonzero.\nIn the second search the pivot is the first candidate that\niszerofunc can guarantee is nonzero.\nIf no such candidate exists, then the pivot is the first candidate\nfor which iszerofunc returns None.\nIf no such candidate exists, then the search is repeated in the next\ncolumn to the right.\nThe pivot search algorithm differs from the one in ``rref()``, which\nrelies on ``_find_reasonable_pivot()``.\nFuture versions of ``LUdecomposition_simple()`` may use\n``_find_reasonable_pivot()``.\n\nSee Also\n========\n\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nLUdecompositionFF\nLUsolve",
            "signature": "(self, iszerofunc=<function _iszero at 0x7f1c4ab3d440>, simpfunc=None, rankcheck=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "iszerofunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "<function _iszero at 0x7f1c4ab3d440>",
                "annotation": null
              },
              "simpfunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "rankcheck": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUsolve": {
            "doc": "Solve the linear system ``Ax = rhs`` for ``x`` where ``A = M``.\n\nThis is for symbolic matrices, for real or complex ones use\nmpmath.lu_solve or mpmath.qr_solve.\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.lower_triangular_solve\nsympy.matrices.dense.DenseMatrix.upper_triangular_solve\ngauss_jordan_solve\ncholesky_solve\ndiagonal_solve\nLDLsolve\nQRsolve\npinv_solve\nLUdecomposition\ncramer_solve",
            "signature": "(self, rhs, iszerofunc=<function _iszero at 0x7f1c4ab3d440>)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rhs": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "iszerofunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "<function _iszero at 0x7f1c4ab3d440>",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "QRdecomposition": {
            "doc": "Returns a QR decomposition.\n\nExplanation\n===========\n\nA QR decomposition is a decomposition in the form $A = Q R$\nwhere\n\n- $Q$ is a column orthogonal matrix.\n- $R$ is a upper triangular (trapezoidal) matrix.\n\nA column orthogonal matrix satisfies\n$\\mathbb{I} = Q^H Q$ while a full orthogonal matrix satisfies\nrelation $\\mathbb{I} = Q Q^H = Q^H Q$ where $I$ is an identity\nmatrix with matching dimensions.\n\nFor matrices which are not square or are rank-deficient, it is\nsufficient to return a column orthogonal matrix because augmenting\nthem may introduce redundant computations.\nAnd an another advantage of this is that you can easily inspect the\nmatrix rank by counting the number of columns of $Q$.\n\nIf you want to augment the results to return a full orthogonal\ndecomposition, you should use the following procedures.\n\n- Augment the $Q$ matrix with columns that are orthogonal to every\n  other columns and make it square.\n- Augment the $R$ matrix with zero rows to make it have the same\n  shape as the original matrix.\n\nThe procedure will be illustrated in the examples section.\n\nExamples\n========\n\nA full rank matrix example:\n\n>>> from sympy import Matrix\n>>> A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])\n>>> Q, R = A.QRdecomposition()\n>>> Q\nMatrix([\n[ 6/7, -69/175, -58/175],\n[ 3/7, 158/175,   6/175],\n[-2/7,    6/35,  -33/35]])\n>>> R\nMatrix([\n[14,  21, -14],\n[ 0, 175, -70],\n[ 0,   0,  35]])\n\nIf the matrix is square and full rank, the $Q$ matrix becomes\northogonal in both directions, and needs no augmentation.\n\n>>> Q * Q.H\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> Q.H * Q\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n\n>>> A == Q*R\nTrue\n\nA rank deficient matrix example:\n\n>>> A = Matrix([[12, -51, 0], [6, 167, 0], [-4, 24, 0]])\n>>> Q, R = A.QRdecomposition()\n>>> Q\nMatrix([\n[ 6/7, -69/175],\n[ 3/7, 158/175],\n[-2/7,    6/35]])\n>>> R\nMatrix([\n[14,  21, 0],\n[ 0, 175, 0]])\n\nQRdecomposition might return a matrix Q that is rectangular.\nIn this case the orthogonality condition might be satisfied as\n$\\mathbb{I} = Q.H*Q$ but not in the reversed product\n$\\mathbb{I} = Q * Q.H$.\n\n>>> Q.H * Q\nMatrix([\n[1, 0],\n[0, 1]])\n>>> Q * Q.H\nMatrix([\n[27261/30625,   348/30625, -1914/6125],\n[  348/30625, 30589/30625,   198/6125],\n[ -1914/6125,    198/6125,   136/1225]])\n\nIf you want to augment the results to be a full orthogonal\ndecomposition, you should augment $Q$ with an another orthogonal\ncolumn.\n\nYou are able to append an identity matrix,\nand you can run the Gram-Schmidt\nprocess to make them augmented as orthogonal basis.\n\n>>> Q_aug = Q.row_join(Matrix.eye(3))\n>>> Q_aug = Q_aug.QRdecomposition()[0]\n>>> Q_aug\nMatrix([\n[ 6/7, -69/175, 58/175],\n[ 3/7, 158/175, -6/175],\n[-2/7,    6/35,  33/35]])\n>>> Q_aug.H * Q_aug\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> Q_aug * Q_aug.H\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n\nAugmenting the $R$ matrix with zero row is straightforward.\n\n>>> R_aug = R.col_join(Matrix([[0, 0, 0]]))\n>>> R_aug\nMatrix([\n[14,  21, 0],\n[ 0, 175, 0],\n[ 0,   0, 0]])\n>>> Q_aug * R_aug == A\nTrue\n\nA zero matrix example:\n\n>>> from sympy import Matrix\n>>> A = Matrix.zeros(3, 4)\n>>> Q, R = A.QRdecomposition()\n\nThey may return matrices with zero rows and columns.\n\n>>> Q\nMatrix(3, 0, [])\n>>> R\nMatrix(0, 4, [])\n>>> Q*R\nMatrix([\n[0, 0, 0, 0],\n[0, 0, 0, 0],\n[0, 0, 0, 0]])\n\nAs the same augmentation rule described above, $Q$ can be augmented\nwith columns of an identity matrix and $R$ can be augmented with\nrows of a zero matrix.\n\n>>> Q_aug = Q.row_join(Matrix.eye(3))\n>>> R_aug = R.col_join(Matrix.zeros(3, 4))\n>>> Q_aug * Q_aug.T\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> R_aug\nMatrix([\n[0, 0, 0, 0],\n[0, 0, 0, 0],\n[0, 0, 0, 0]])\n>>> Q_aug * R_aug == A\nTrue\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.cholesky\nsympy.matrices.dense.DenseMatrix.LDLdecomposition\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nQRsolve",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "QRsolve": {
            "doc": "Solve the linear system ``Ax = b``.\n\n``M`` is the matrix ``A``, the method argument is the vector\n``b``.  The method returns the solution vector ``x``.  If ``b`` is a\nmatrix, the system is solved for each column of ``b`` and the\nreturn value is a matrix of the same shape as ``b``.\n\nThis method is slower (approximately by a factor of 2) but\nmore stable for floating-point arithmetic than the LUsolve method.\nHowever, LUsolve usually uses an exact arithmetic, so you do not need\nto use QRsolve.\n\nThis is mainly for educational purposes and symbolic matrices, for real\n(or complex) matrices use mpmath.qr_solve.\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.lower_triangular_solve\nsympy.matrices.dense.DenseMatrix.upper_triangular_solve\ngauss_jordan_solve\ncholesky_solve\ndiagonal_solve\nLDLsolve\nLUsolve\npinv_solve\nQRdecomposition\ncramer_solve",
            "signature": "(self, b)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "b": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "add": {
            "doc": "Return self + b.",
            "signature": "(self, b)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "b": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "adjoint": {
            "doc": "Conjugate transpose or Hermitian conjugation.",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "ImmutableSparseMatrix": {
        "full_name": "sympy.matrices.ImmutableSparseMatrix",
        "bases": [
          "SparseRepMatrix",
          "ImmutableRepMatrix"
        ],
        "doc": "Create an immutable version of a sparse matrix.\n\nExamples\n========\n\n>>> from sympy import eye, ImmutableSparseMatrix\n>>> ImmutableSparseMatrix(1, 1, {})\nMatrix([[0]])\n>>> ImmutableSparseMatrix(eye(3))\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> _[0, 0] = 42\nTraceback (most recent call last):\n...\nTypeError: Cannot set values of ImmutableSparseMatrix\n>>> _.shape\n(3, 3)",
        "methods": {
          "LDLdecomposition": {
            "doc": "Returns the LDL Decomposition (matrices ``L`` and ``D``) of matrix\n``A``, such that ``L * D * L.T == A``. ``A`` must be a square,\nsymmetric, positive-definite and non-singular.\n\nThis method eliminates the use of square root and ensures that all\nthe diagonal entries of L are 1.\n\nExamples\n========\n\n>>> from sympy import SparseMatrix\n>>> A = SparseMatrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))\n>>> L, D = A.LDLdecomposition()\n>>> L\nMatrix([\n[   1,   0, 0],\n[ 3/5,   1, 0],\n[-1/5, 1/3, 1]])\n>>> D\nMatrix([\n[25, 0, 0],\n[ 0, 9, 0],\n[ 0, 0, 9]])\n>>> L * D * L.T == A\nTrue",
            "signature": "(self, hermitian=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "hermitian": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LDLsolve": {
            "doc": "Solves ``Ax = B`` using LDL decomposition,\nfor a general square and non-singular matrix.\n\nFor a non-square matrix with rows > cols,\nthe least squares solution is returned.\n\nExamples\n========\n\n>>> from sympy import Matrix, eye\n>>> A = eye(2)*2\n>>> B = Matrix([[1, 2], [3, 4]])\n>>> A.LDLsolve(B) == B/2\nTrue\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.LDLdecomposition\nsympy.matrices.dense.DenseMatrix.lower_triangular_solve\nsympy.matrices.dense.DenseMatrix.upper_triangular_solve\ngauss_jordan_solve\ncholesky_solve\ndiagonal_solve\nLUsolve\nQRsolve\npinv_solve\ncramer_solve",
            "signature": "(self, rhs)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rhs": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecomposition": {
            "doc": "Returns (L, U, perm) where L is a lower triangular matrix with unit\ndiagonal, U is an upper triangular matrix, and perm is a list of row\nswap index pairs. If A is the original matrix, then\n``A = (L*U).permuteBkwd(perm)``, and the row permutation matrix P such\nthat $P A = L U$ can be computed by ``P = eye(A.rows).permuteFwd(perm)``.\n\nSee documentation for LUCombined for details about the keyword argument\nrankcheck, iszerofunc, and simpfunc.\n\nParameters\n==========\n\nrankcheck : bool, optional\n    Determines if this function should detect the rank\n    deficiency of the matrixis and should raise a\n    ``ValueError``.\n\niszerofunc : function, optional\n    A function which determines if a given expression is zero.\n\n    The function should be a callable that takes a single\n    SymPy expression and returns a 3-valued boolean value\n    ``True``, ``False``, or ``None``.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nsimpfunc : function or None, optional\n    A function that simplifies the input.\n\n    If this is specified as a function, this function should be\n    a callable that takes a single SymPy expression and returns\n    an another SymPy expression that is algebraically\n    equivalent.\n\n    If ``None``, it indicates that the pivot search algorithm\n    should not attempt to simplify any candidate pivots.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nExamples\n========\n\n>>> from sympy import Matrix\n>>> a = Matrix([[4, 3], [6, 3]])\n>>> L, U, _ = a.LUdecomposition()\n>>> L\nMatrix([\n[  1, 0],\n[3/2, 1]])\n>>> U\nMatrix([\n[4,    3],\n[0, -3/2]])\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.cholesky\nsympy.matrices.dense.DenseMatrix.LDLdecomposition\nQRdecomposition\nLUdecomposition_Simple\nLUdecompositionFF\nLUsolve",
            "signature": "(self, iszerofunc=<function _iszero at 0x7f1c4ab3d440>, simpfunc=None, rankcheck=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "iszerofunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "<function _iszero at 0x7f1c4ab3d440>",
                "annotation": null
              },
              "simpfunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "rankcheck": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecompositionFF": {
            "doc": "Compute a fraction-free LU decomposition.\n\nReturns 4 matrices P, L, D, U such that PA = L D**-1 U.\nIf the elements of the matrix belong to some integral domain I, then all\nelements of L, D and U are guaranteed to belong to I.\n\nSee Also\n========\n\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nLUdecomposition_Simple\nLUsolve\n\nReferences\n==========\n\n.. [1] W. Zhou & D.J. Jeffrey, \"Fraction-free matrix factors: new forms\n    for LU and QR factors\". Frontiers in Computer Science in China,\n    Vol 2, no. 1, pp. 67-80, 2008.",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUdecomposition_Simple": {
            "doc": "Compute the PLU decomposition of the matrix.\n\nParameters\n==========\n\nrankcheck : bool, optional\n    Determines if this function should detect the rank\n    deficiency of the matrixis and should raise a\n    ``ValueError``.\n\niszerofunc : function, optional\n    A function which determines if a given expression is zero.\n\n    The function should be a callable that takes a single\n    SymPy expression and returns a 3-valued boolean value\n    ``True``, ``False``, or ``None``.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nsimpfunc : function or None, optional\n    A function that simplifies the input.\n\n    If this is specified as a function, this function should be\n    a callable that takes a single SymPy expression and returns\n    an another SymPy expression that is algebraically\n    equivalent.\n\n    If ``None``, it indicates that the pivot search algorithm\n    should not attempt to simplify any candidate pivots.\n\n    It is internally used by the pivot searching algorithm.\n    See the notes section for a more information about the\n    pivot searching algorithm.\n\nReturns\n=======\n\n(lu, row_swaps) : (Matrix, list)\n    If the original matrix is a $m, n$ matrix:\n\n    *lu* is a $m, n$ matrix, which contains result of the\n    decomposition in a compressed form. See the notes section\n    to see how the matrix is compressed.\n\n    *row_swaps* is a $m$-element list where each element is a\n    pair of row exchange indices.\n\n    ``A = (L*U).permute_backward(perm)``, and the row\n    permutation matrix $P$ from the formula $P A = L U$ can be\n    computed by ``P=eye(A.row).permute_forward(perm)``.\n\nRaises\n======\n\nValueError\n    Raised if ``rankcheck=True`` and the matrix is found to\n    be rank deficient during the computation.\n\nNotes\n=====\n\nAbout the PLU decomposition:\n\nPLU decomposition is a generalization of a LU decomposition\nwhich can be extended for rank-deficient matrices.\n\nIt can further be generalized for non-square matrices, and this\nis the notation that SymPy is using.\n\nPLU decomposition is a decomposition of a $m, n$ matrix $A$ in\nthe form of $P A = L U$ where\n\n* $L$ is a $m, m$ lower triangular matrix with unit diagonal\n    entries.\n* $U$ is a $m, n$ upper triangular matrix.\n* $P$ is a $m, m$ permutation matrix.\n\nSo, for a square matrix, the decomposition would look like:\n\n.. math::\n    L = \\begin{bmatrix}\n    1 & 0 & 0 & \\cdots & 0 \\\\\n    L_{1, 0} & 1 & 0 & \\cdots & 0 \\\\\n    L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & 1\n    \\end{bmatrix}\n\n.. math::\n    U = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    0 & 0 & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & U_{n-1, n-1}\n    \\end{bmatrix}\n\nAnd for a matrix with more rows than the columns,\nthe decomposition would look like:\n\n.. math::\n    L = \\begin{bmatrix}\n    1 & 0 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n    L_{1, 0} & 1 & 0 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n    L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 & 0 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\ddots\n    & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & 1 & 0\n    & \\cdots & 0 \\\\\n    L_{n, 0} & L_{n, 1} & L_{n, 2} & \\cdots & L_{n, n-1} & 1\n    & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots\n    & \\ddots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & L_{m-1, n-1}\n    & 0 & \\cdots & 1 \\\\\n    \\end{bmatrix}\n\n.. math::\n    U = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    0 & 0 & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & U_{n-1, n-1} \\\\\n    0 & 0 & 0 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & 0\n    \\end{bmatrix}\n\nFinally, for a matrix with more columns than the rows, the\ndecomposition would look like:\n\n.. math::\n    L = \\begin{bmatrix}\n    1 & 0 & 0 & \\cdots & 0 \\\\\n    L_{1, 0} & 1 & 0 & \\cdots & 0 \\\\\n    L_{2, 0} & L_{2, 1} & 1 & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & 1\n    \\end{bmatrix}\n\n.. math::\n    U = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, m-1}\n    & \\cdots & U_{0, n-1} \\\\\n    0 & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, m-1}\n    & \\cdots & U_{1, n-1} \\\\\n    0 & 0 & U_{2, 2} & \\cdots & U_{2, m-1}\n    & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\n    & \\cdots & \\vdots \\\\\n    0 & 0 & 0 & \\cdots & U_{m-1, m-1}\n    & \\cdots & U_{m-1, n-1} \\\\\n    \\end{bmatrix}\n\nAbout the compressed LU storage:\n\nThe results of the decomposition are often stored in compressed\nforms rather than returning $L$ and $U$ matrices individually.\n\nIt may be less intiuitive, but it is commonly used for a lot of\nnumeric libraries because of the efficiency.\n\nThe storage matrix is defined as following for this specific\nmethod:\n\n* The subdiagonal elements of $L$ are stored in the subdiagonal\n    portion of $LU$, that is $LU_{i, j} = L_{i, j}$ whenever\n    $i > j$.\n* The elements on the diagonal of $L$ are all 1, and are not\n    explicitly stored.\n* $U$ is stored in the upper triangular portion of $LU$, that is\n    $LU_{i, j} = U_{i, j}$ whenever $i <= j$.\n* For a case of $m > n$, the right side of the $L$ matrix is\n    trivial to store.\n* For a case of $m < n$, the below side of the $U$ matrix is\n    trivial to store.\n\nSo, for a square matrix, the compressed output matrix would be:\n\n.. math::\n    LU = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots & U_{n-1, n-1}\n    \\end{bmatrix}\n\nFor a matrix with more rows than the columns, the compressed\noutput matrix would be:\n\n.. math::\n    LU = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, n-1} \\\\\n    L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, n-1} \\\\\n    L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \\cdots\n    & U_{n-1, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots\n    & L_{m-1, n-1} \\\\\n    \\end{bmatrix}\n\nFor a matrix with more columns than the rows, the compressed\noutput matrix would be:\n\n.. math::\n    LU = \\begin{bmatrix}\n    U_{0, 0} & U_{0, 1} & U_{0, 2} & \\cdots & U_{0, m-1}\n    & \\cdots & U_{0, n-1} \\\\\n    L_{1, 0} & U_{1, 1} & U_{1, 2} & \\cdots & U_{1, m-1}\n    & \\cdots & U_{1, n-1} \\\\\n    L_{2, 0} & L_{2, 1} & U_{2, 2} & \\cdots & U_{2, m-1}\n    & \\cdots & U_{2, n-1} \\\\\n    \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\n    & \\cdots & \\vdots \\\\\n    L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \\cdots & U_{m-1, m-1}\n    & \\cdots & U_{m-1, n-1} \\\\\n    \\end{bmatrix}\n\nAbout the pivot searching algorithm:\n\nWhen a matrix contains symbolic entries, the pivot search algorithm\ndiffers from the case where every entry can be categorized as zero or\nnonzero.\nThe algorithm searches column by column through the submatrix whose\ntop left entry coincides with the pivot position.\nIf it exists, the pivot is the first entry in the current search\ncolumn that iszerofunc guarantees is nonzero.\nIf no such candidate exists, then each candidate pivot is simplified\nif simpfunc is not None.\nThe search is repeated, with the difference that a candidate may be\nthe pivot if ``iszerofunc()`` cannot guarantee that it is nonzero.\nIn the second search the pivot is the first candidate that\niszerofunc can guarantee is nonzero.\nIf no such candidate exists, then the pivot is the first candidate\nfor which iszerofunc returns None.\nIf no such candidate exists, then the search is repeated in the next\ncolumn to the right.\nThe pivot search algorithm differs from the one in ``rref()``, which\nrelies on ``_find_reasonable_pivot()``.\nFuture versions of ``LUdecomposition_simple()`` may use\n``_find_reasonable_pivot()``.\n\nSee Also\n========\n\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nLUdecompositionFF\nLUsolve",
            "signature": "(self, iszerofunc=<function _iszero at 0x7f1c4ab3d440>, simpfunc=None, rankcheck=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "iszerofunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "<function _iszero at 0x7f1c4ab3d440>",
                "annotation": null
              },
              "simpfunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "rankcheck": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "LUsolve": {
            "doc": "Solve the linear system ``Ax = rhs`` for ``x`` where ``A = M``.\n\nThis is for symbolic matrices, for real or complex ones use\nmpmath.lu_solve or mpmath.qr_solve.\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.lower_triangular_solve\nsympy.matrices.dense.DenseMatrix.upper_triangular_solve\ngauss_jordan_solve\ncholesky_solve\ndiagonal_solve\nLDLsolve\nQRsolve\npinv_solve\nLUdecomposition\ncramer_solve",
            "signature": "(self, rhs, iszerofunc=<function _iszero at 0x7f1c4ab3d440>)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rhs": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "iszerofunc": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "<function _iszero at 0x7f1c4ab3d440>",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "QRdecomposition": {
            "doc": "Returns a QR decomposition.\n\nExplanation\n===========\n\nA QR decomposition is a decomposition in the form $A = Q R$\nwhere\n\n- $Q$ is a column orthogonal matrix.\n- $R$ is a upper triangular (trapezoidal) matrix.\n\nA column orthogonal matrix satisfies\n$\\mathbb{I} = Q^H Q$ while a full orthogonal matrix satisfies\nrelation $\\mathbb{I} = Q Q^H = Q^H Q$ where $I$ is an identity\nmatrix with matching dimensions.\n\nFor matrices which are not square or are rank-deficient, it is\nsufficient to return a column orthogonal matrix because augmenting\nthem may introduce redundant computations.\nAnd an another advantage of this is that you can easily inspect the\nmatrix rank by counting the number of columns of $Q$.\n\nIf you want to augment the results to return a full orthogonal\ndecomposition, you should use the following procedures.\n\n- Augment the $Q$ matrix with columns that are orthogonal to every\n  other columns and make it square.\n- Augment the $R$ matrix with zero rows to make it have the same\n  shape as the original matrix.\n\nThe procedure will be illustrated in the examples section.\n\nExamples\n========\n\nA full rank matrix example:\n\n>>> from sympy import Matrix\n>>> A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])\n>>> Q, R = A.QRdecomposition()\n>>> Q\nMatrix([\n[ 6/7, -69/175, -58/175],\n[ 3/7, 158/175,   6/175],\n[-2/7,    6/35,  -33/35]])\n>>> R\nMatrix([\n[14,  21, -14],\n[ 0, 175, -70],\n[ 0,   0,  35]])\n\nIf the matrix is square and full rank, the $Q$ matrix becomes\northogonal in both directions, and needs no augmentation.\n\n>>> Q * Q.H\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> Q.H * Q\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n\n>>> A == Q*R\nTrue\n\nA rank deficient matrix example:\n\n>>> A = Matrix([[12, -51, 0], [6, 167, 0], [-4, 24, 0]])\n>>> Q, R = A.QRdecomposition()\n>>> Q\nMatrix([\n[ 6/7, -69/175],\n[ 3/7, 158/175],\n[-2/7,    6/35]])\n>>> R\nMatrix([\n[14,  21, 0],\n[ 0, 175, 0]])\n\nQRdecomposition might return a matrix Q that is rectangular.\nIn this case the orthogonality condition might be satisfied as\n$\\mathbb{I} = Q.H*Q$ but not in the reversed product\n$\\mathbb{I} = Q * Q.H$.\n\n>>> Q.H * Q\nMatrix([\n[1, 0],\n[0, 1]])\n>>> Q * Q.H\nMatrix([\n[27261/30625,   348/30625, -1914/6125],\n[  348/30625, 30589/30625,   198/6125],\n[ -1914/6125,    198/6125,   136/1225]])\n\nIf you want to augment the results to be a full orthogonal\ndecomposition, you should augment $Q$ with an another orthogonal\ncolumn.\n\nYou are able to append an identity matrix,\nand you can run the Gram-Schmidt\nprocess to make them augmented as orthogonal basis.\n\n>>> Q_aug = Q.row_join(Matrix.eye(3))\n>>> Q_aug = Q_aug.QRdecomposition()[0]\n>>> Q_aug\nMatrix([\n[ 6/7, -69/175, 58/175],\n[ 3/7, 158/175, -6/175],\n[-2/7,    6/35,  33/35]])\n>>> Q_aug.H * Q_aug\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> Q_aug * Q_aug.H\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n\nAugmenting the $R$ matrix with zero row is straightforward.\n\n>>> R_aug = R.col_join(Matrix([[0, 0, 0]]))\n>>> R_aug\nMatrix([\n[14,  21, 0],\n[ 0, 175, 0],\n[ 0,   0, 0]])\n>>> Q_aug * R_aug == A\nTrue\n\nA zero matrix example:\n\n>>> from sympy import Matrix\n>>> A = Matrix.zeros(3, 4)\n>>> Q, R = A.QRdecomposition()\n\nThey may return matrices with zero rows and columns.\n\n>>> Q\nMatrix(3, 0, [])\n>>> R\nMatrix(0, 4, [])\n>>> Q*R\nMatrix([\n[0, 0, 0, 0],\n[0, 0, 0, 0],\n[0, 0, 0, 0]])\n\nAs the same augmentation rule described above, $Q$ can be augmented\nwith columns of an identity matrix and $R$ can be augmented with\nrows of a zero matrix.\n\n>>> Q_aug = Q.row_join(Matrix.eye(3))\n>>> R_aug = R.col_join(Matrix.zeros(3, 4))\n>>> Q_aug * Q_aug.T\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> R_aug\nMatrix([\n[0, 0, 0, 0],\n[0, 0, 0, 0],\n[0, 0, 0, 0]])\n>>> Q_aug * R_aug == A\nTrue\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.cholesky\nsympy.matrices.dense.DenseMatrix.LDLdecomposition\nsympy.matrices.matrixbase.MatrixBase.LUdecomposition\nQRsolve",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "QRsolve": {
            "doc": "Solve the linear system ``Ax = b``.\n\n``M`` is the matrix ``A``, the method argument is the vector\n``b``.  The method returns the solution vector ``x``.  If ``b`` is a\nmatrix, the system is solved for each column of ``b`` and the\nreturn value is a matrix of the same shape as ``b``.\n\nThis method is slower (approximately by a factor of 2) but\nmore stable for floating-point arithmetic than the LUsolve method.\nHowever, LUsolve usually uses an exact arithmetic, so you do not need\nto use QRsolve.\n\nThis is mainly for educational purposes and symbolic matrices, for real\n(or complex) matrices use mpmath.qr_solve.\n\nSee Also\n========\n\nsympy.matrices.dense.DenseMatrix.lower_triangular_solve\nsympy.matrices.dense.DenseMatrix.upper_triangular_solve\ngauss_jordan_solve\ncholesky_solve\ndiagonal_solve\nLDLsolve\nLUsolve\npinv_solve\nQRdecomposition\ncramer_solve",
            "signature": "(self, b)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "b": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "add": {
            "doc": "Return self + b.",
            "signature": "(self, b)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "b": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "adjoint": {
            "doc": "Conjugate transpose or Hermitian conjugation.",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "Inverse": {
        "full_name": "sympy.matrices.Inverse",
        "bases": [
          "MatPow"
        ],
        "doc": "The multiplicative inverse of a matrix expression\n\nThis is a symbolic object that simply stores its argument without\nevaluating it. To actually compute the inverse, use the ``.inverse()``\nmethod of matrices.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, Inverse\n>>> A = MatrixSymbol('A', 3, 3)\n>>> B = MatrixSymbol('B', 3, 3)\n>>> Inverse(A)\nA**(-1)\n>>> A.inverse() == Inverse(A)\nTrue\n>>> (A*B).inverse()\nB**(-1)*A**(-1)\n>>> Inverse(A*B)\n(A*B)**(-1)",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "KroneckerProduct": {
        "full_name": "sympy.matrices.KroneckerProduct",
        "bases": [
          "MatrixExpr"
        ],
        "doc": "The Kronecker product of two or more arguments.\n\nThe Kronecker product is a non-commutative product of matrices.\nGiven two matrices of dimension (m, n) and (s, t) it produces a matrix\nof dimension (m s, n t).\n\nThis is a symbolic object that simply stores its argument without\nevaluating it. To actually compute the product, use the function\n``kronecker_product()`` or call the ``.doit()`` or  ``.as_explicit()``\nmethods.\n\n>>> from sympy import KroneckerProduct, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 5)\n>>> B = MatrixSymbol('B', 5, 5)\n>>> isinstance(KroneckerProduct(A, B), KroneckerProduct)\nTrue",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "MatAdd": {
        "full_name": "sympy.matrices.MatAdd",
        "bases": [
          "MatrixExpr",
          "Add"
        ],
        "doc": "A Sum of Matrix Expressions\n\nMatAdd inherits from and operates like SymPy Add\n\nExamples\n========\n\n>>> from sympy import MatAdd, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 5)\n>>> B = MatrixSymbol('B', 5, 5)\n>>> C = MatrixSymbol('C', 5, 5)\n>>> MatAdd(A, B, C)\nA + B + C",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False, deps=None) -> 'tuple[Number, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "deps": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              }
            },
            "return_annotation": "tuple[Number, Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Returns a tuple (coeff, args) where self is treated as an Add and coeff\nis the Number term and args is a tuple of all other terms.\n\nExamples\n========\n\n>>> from sympy.abc import x\n>>> (7 + 3*x).as_coeff_add()\n(7, (3*x,))\n>>> (7*x).as_coeff_add()\n(0, (7*x,))",
            "signature": "(self, *deps)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mmul": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      },
      "MatMul": {
        "full_name": "sympy.matrices.MatMul",
        "bases": [
          "MatrixExpr",
          "Mul"
        ],
        "doc": "A product of matrix expressions\n\nExamples\n========\n\n>>> from sympy import MatMul, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 4)\n>>> B = MatrixSymbol('B', 4, 3)\n>>> C = MatrixSymbol('C', 3, 6)\n>>> MatMul(A, B, C)\nA*B*C",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "applyfunc": {
            "doc": "",
            "signature": "(self, func)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "func": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, **kwargs)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational=False)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_matrices": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          }
        },
        "properties": {}
      }
    },
    "functions": {
      "GramSchmidt": {
        "doc": "Apply the Gram-Schmidt process to a set of vectors.\n\nParameters\n==========\n\nvlist : List of Matrix\n    Vectors to be orthogonalized for.\n\northonormal : Bool, optional\n    If true, return an orthonormal basis.\n\nReturns\n=======\n\nvlist : List of Matrix\n    Orthogonalized vectors\n\nNotes\n=====\n\nThis routine is mostly duplicate from ``Matrix.orthogonalize``,\nexcept for some difference that this always raises error when\nlinearly dependent vectors are found, and the keyword ``normalize``\nhas been named as ``orthonormal`` in this function.\n\nSee Also\n========\n\n.matrixbase.MatrixBase.orthogonalize\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process",
        "signature": "(vlist, orthonormal=False)",
        "parameters": {
          "vlist": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "orthonormal": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "False",
            "annotation": null
          }
        },
        "return_annotation": null
      }
    },
    "constants": {}
  },
  "sympy.solvers": {
    "classes": {},
    "functions": {
      "checkodesol": {
        "doc": "Substitutes ``sol`` into ``ode`` and checks that the result is ``0``.\n\nThis works when ``func`` is one function, like `f(x)` or a list of\nfunctions like `[f(x), g(x)]` when `ode` is a system of ODEs.  ``sol`` can\nbe a single solution or a list of solutions.  Each solution may be an\n:py:class:`~sympy.core.relational.Equality` that the solution satisfies,\ne.g. ``Eq(f(x), C1), Eq(f(x) + C1, 0)``; or simply an\n:py:class:`~sympy.core.expr.Expr`, e.g. ``f(x) - C1``. In most cases it\nwill not be necessary to explicitly identify the function, but if the\nfunction cannot be inferred from the original equation it can be supplied\nthrough the ``func`` argument.\n\nIf a sequence of solutions is passed, the same sort of container will be\nused to return the result for each solution.\n\nIt tries the following methods, in order, until it finds zero equivalence:\n\n1. Substitute the solution for `f` in the original equation.  This only\n   works if ``ode`` is solved for `f`.  It will attempt to solve it first\n   unless ``solve_for_func == False``.\n2. Take `n` derivatives of the solution, where `n` is the order of\n   ``ode``, and check to see if that is equal to the solution.  This only\n   works on exact ODEs.\n3. Take the 1st, 2nd, ..., `n`\\th derivatives of the solution, each time\n   solving for the derivative of `f` of that order (this will always be\n   possible because `f` is a linear operator). Then back substitute each\n   derivative into ``ode`` in reverse order.\n\nThis function returns a tuple.  The first item in the tuple is ``True`` if\nthe substitution results in ``0``, and ``False`` otherwise. The second\nitem in the tuple is what the substitution results in.  It should always\nbe ``0`` if the first item is ``True``. Sometimes this function will\nreturn ``False`` even when an expression is identically equal to ``0``.\nThis happens when :py:meth:`~sympy.simplify.simplify.simplify` does not\nreduce the expression to ``0``.  If an expression returned by this\nfunction vanishes identically, then ``sol`` really is a solution to\nthe ``ode``.\n\nIf this function seems to hang, it is probably because of a hard\nsimplification.\n\nTo use this function to test, test the first item of the tuple.\n\nExamples\n========\n\n>>> from sympy import (Eq, Function, checkodesol, symbols,\n...     Derivative, exp)\n>>> x, C1, C2 = symbols('x,C1,C2')\n>>> f, g = symbols('f g', cls=Function)\n>>> checkodesol(f(x).diff(x), Eq(f(x), C1))\n(True, 0)\n>>> assert checkodesol(f(x).diff(x), C1)[0]\n>>> assert not checkodesol(f(x).diff(x), x)[0]\n>>> checkodesol(f(x).diff(x, 2), x**2)\n(False, 2)\n\n>>> eqs = [Eq(Derivative(f(x), x), f(x)), Eq(Derivative(g(x), x), g(x))]\n>>> sol = [Eq(f(x), C1*exp(x)), Eq(g(x), C2*exp(x))]\n>>> checkodesol(eqs, sol)\n(True, [0, 0])",
        "signature": "(ode, sol, func=None, order='auto', solve_for_func=True)",
        "parameters": {
          "ode": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "sol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "func": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "order": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "auto",
            "annotation": null
          },
          "solve_for_func": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "True",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "checkpdesol": {
        "doc": "Checks if the given solution satisfies the partial differential\nequation.\n\npde is the partial differential equation which can be given in the\nform of an equation or an expression. sol is the solution for which\nthe pde is to be checked. This can also be given in an equation or\nan expression form. If the function is not provided, the helper\nfunction _preprocess from deutils is used to identify the function.\n\nIf a sequence of solutions is passed, the same sort of container will be\nused to return the result for each solution.\n\nThe following methods are currently being implemented to check if the\nsolution satisfies the PDE:\n\n    1. Directly substitute the solution in the PDE and check. If the\n       solution has not been solved for f, then it will solve for f\n       provided solve_for_func has not been set to False.\n\nIf the solution satisfies the PDE, then a tuple (True, 0) is returned.\nOtherwise a tuple (False, expr) where expr is the value obtained\nafter substituting the solution in the PDE. However if a known solution\nreturns False, it may be due to the inability of doit() to simplify it to zero.\n\nExamples\n========\n\n>>> from sympy import Function, symbols\n>>> from sympy.solvers.pde import checkpdesol, pdsolve\n>>> x, y = symbols('x y')\n>>> f = Function('f')\n>>> eq = 2*f(x,y) + 3*f(x,y).diff(x) + 4*f(x,y).diff(y)\n>>> sol = pdsolve(eq)\n>>> assert checkpdesol(eq, sol)[0]\n>>> eq = x*f(x,y) + f(x,y).diff(x)\n>>> checkpdesol(eq, sol)\n(False, (x*F(4*x - 3*y) - 6*F(4*x - 3*y)/25 + 4*Subs(Derivative(F(_xi_1), _xi_1), _xi_1, 4*x - 3*y))*exp(-6*x/25 - 8*y/25))",
        "signature": "(pde, sol, func=None, solve_for_func=True)",
        "parameters": {
          "pde": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "sol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "func": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "solve_for_func": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "True",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "checksol": {
        "doc": "Checks whether sol is a solution of equation f == 0.\n\nExplanation\n===========\n\nInput can be either a single symbol and corresponding value\nor a dictionary of symbols and values. When given as a dictionary\nand flag ``simplify=True``, the values in the dictionary will be\nsimplified. *f* can be a single equation or an iterable of equations.\nA solution must satisfy all equations in *f* to be considered valid;\nif a solution does not satisfy any equation, False is returned; if one or\nmore checks are inconclusive (and none are False) then None is returned.\n\nExamples\n========\n\n>>> from sympy import checksol, symbols\n>>> x, y = symbols('x,y')\n>>> checksol(x**4 - 1, x, 1)\nTrue\n>>> checksol(x**4 - 1, x, 0)\nFalse\n>>> checksol(x**2 + y**2 - 5**2, {x: 3, y: 4})\nTrue\n\nTo check if an expression is zero using ``checksol()``, pass it\nas *f* and send an empty dictionary for *symbol*:\n\n>>> checksol(x**2 + x - x*(x + 1), {})\nTrue\n\nNone is returned if ``checksol()`` could not conclude.\n\nflags:\n    'numerical=True (default)'\n       do a fast numerical check if ``f`` has only one symbol.\n    'minimal=True (default is False)'\n       a very fast, minimal testing.\n    'warn=True (default is False)'\n       show a warning if checksol() could not conclude.\n    'simplify=True (default)'\n       simplify solution before substituting into function and\n       simplify the function before trying specific simplifications\n    'force=True (default is False)'\n       make positive all symbols without assumptions regarding sign.",
        "signature": "(f, symbol, sol=None, **flags)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "sol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "flags": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "classify_ode": {
        "doc": "Returns a tuple of possible :py:meth:`~sympy.solvers.ode.dsolve`\nclassifications for an ODE.\n\nThe tuple is ordered so that first item is the classification that\n:py:meth:`~sympy.solvers.ode.dsolve` uses to solve the ODE by default.  In\ngeneral, classifications at the near the beginning of the list will\nproduce better solutions faster than those near the end, thought there are\nalways exceptions.  To make :py:meth:`~sympy.solvers.ode.dsolve` use a\ndifferent classification, use ``dsolve(ODE, func,\nhint=<classification>)``.  See also the\n:py:meth:`~sympy.solvers.ode.dsolve` docstring for different meta-hints\nyou can use.\n\nIf ``dict`` is true, :py:meth:`~sympy.solvers.ode.classify_ode` will\nreturn a dictionary of ``hint:match`` expression terms. This is intended\nfor internal use by :py:meth:`~sympy.solvers.ode.dsolve`.  Note that\nbecause dictionaries are ordered arbitrarily, this will most likely not be\nin the same order as the tuple.\n\nYou can get help on different hints by executing\n``help(ode.ode_hintname)``, where ``hintname`` is the name of the hint\nwithout ``_Integral``.\n\nSee :py:data:`~sympy.solvers.ode.allhints` or the\n:py:mod:`~sympy.solvers.ode` docstring for a list of all supported hints\nthat can be returned from :py:meth:`~sympy.solvers.ode.classify_ode`.\n\nNotes\n=====\n\nThese are remarks on hint names.\n\n``_Integral``\n\n    If a classification has ``_Integral`` at the end, it will return the\n    expression with an unevaluated :py:class:`~.Integral`\n    class in it.  Note that a hint may do this anyway if\n    :py:meth:`~sympy.core.expr.Expr.integrate` cannot do the integral,\n    though just using an ``_Integral`` will do so much faster.  Indeed, an\n    ``_Integral`` hint will always be faster than its corresponding hint\n    without ``_Integral`` because\n    :py:meth:`~sympy.core.expr.Expr.integrate` is an expensive routine.\n    If :py:meth:`~sympy.solvers.ode.dsolve` hangs, it is probably because\n    :py:meth:`~sympy.core.expr.Expr.integrate` is hanging on a tough or\n    impossible integral.  Try using an ``_Integral`` hint or\n    ``all_Integral`` to get it return something.\n\n    Note that some hints do not have ``_Integral`` counterparts. This is\n    because :py:func:`~sympy.integrals.integrals.integrate` is not used in\n    solving the ODE for those method. For example, `n`\\th order linear\n    homogeneous ODEs with constant coefficients do not require integration\n    to solve, so there is no\n    ``nth_linear_homogeneous_constant_coeff_Integrate`` hint. You can\n    easily evaluate any unevaluated\n    :py:class:`~sympy.integrals.integrals.Integral`\\s in an expression by\n    doing ``expr.doit()``.\n\nOrdinals\n\n    Some hints contain an ordinal such as ``1st_linear``.  This is to help\n    differentiate them from other hints, as well as from other methods\n    that may not be implemented yet. If a hint has ``nth`` in it, such as\n    the ``nth_linear`` hints, this means that the method used to applies\n    to ODEs of any order.\n\n``indep`` and ``dep``\n\n    Some hints contain the words ``indep`` or ``dep``.  These reference\n    the independent variable and the dependent function, respectively. For\n    example, if an ODE is in terms of `f(x)`, then ``indep`` will refer to\n    `x` and ``dep`` will refer to `f`.\n\n``subs``\n\n    If a hints has the word ``subs`` in it, it means that the ODE is solved\n    by substituting the expression given after the word ``subs`` for a\n    single dummy variable.  This is usually in terms of ``indep`` and\n    ``dep`` as above.  The substituted expression will be written only in\n    characters allowed for names of Python objects, meaning operators will\n    be spelled out.  For example, ``indep``/``dep`` will be written as\n    ``indep_div_dep``.\n\n``coeff``\n\n    The word ``coeff`` in a hint refers to the coefficients of something\n    in the ODE, usually of the derivative terms.  See the docstring for\n    the individual methods for more info (``help(ode)``).  This is\n    contrast to ``coefficients``, as in ``undetermined_coefficients``,\n    which refers to the common name of a method.\n\n``_best``\n\n    Methods that have more than one fundamental way to solve will have a\n    hint for each sub-method and a ``_best`` meta-classification. This\n    will evaluate all hints and return the best, using the same\n    considerations as the normal ``best`` meta-hint.\n\n\nExamples\n========\n\n>>> from sympy import Function, classify_ode, Eq\n>>> from sympy.abc import x\n>>> f = Function('f')\n>>> classify_ode(Eq(f(x).diff(x), 0), f(x))\n('nth_algebraic',\n'separable',\n'1st_exact',\n'1st_linear',\n'Bernoulli',\n'1st_homogeneous_coeff_best',\n'1st_homogeneous_coeff_subs_indep_div_dep',\n'1st_homogeneous_coeff_subs_dep_div_indep',\n'1st_power_series', 'lie_group', 'nth_linear_constant_coeff_homogeneous',\n'nth_linear_euler_eq_homogeneous',\n'nth_algebraic_Integral', 'separable_Integral', '1st_exact_Integral',\n'1st_linear_Integral', 'Bernoulli_Integral',\n'1st_homogeneous_coeff_subs_indep_div_dep_Integral',\n'1st_homogeneous_coeff_subs_dep_div_indep_Integral')\n>>> classify_ode(f(x).diff(x, 2) + 3*f(x).diff(x) + 2*f(x) - 4)\n('factorable', 'nth_linear_constant_coeff_undetermined_coefficients',\n'nth_linear_constant_coeff_variation_of_parameters',\n'nth_linear_constant_coeff_variation_of_parameters_Integral')",
        "signature": "(eq, func=None, dict=False, ics=None, *, prep=True, xi=None, eta=None, n=None, **kwargs)",
        "parameters": {
          "eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "func": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "dict": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "False",
            "annotation": null
          },
          "ics": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "prep": {
            "kind": "KEYWORD_ONLY",
            "default": "True",
            "annotation": null
          },
          "xi": {
            "kind": "KEYWORD_ONLY",
            "default": "None",
            "annotation": null
          },
          "eta": {
            "kind": "KEYWORD_ONLY",
            "default": "None",
            "annotation": null
          },
          "n": {
            "kind": "KEYWORD_ONLY",
            "default": "None",
            "annotation": null
          },
          "kwargs": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "classify_pde": {
        "doc": "Returns a tuple of possible pdsolve() classifications for a PDE.\n\nThe tuple is ordered so that first item is the classification that\npdsolve() uses to solve the PDE by default.  In general,\nclassifications near the beginning of the list will produce\nbetter solutions faster than those near the end, though there are\nalways exceptions.  To make pdsolve use a different classification,\nuse pdsolve(PDE, func, hint=<classification>).  See also the pdsolve()\ndocstring for different meta-hints you can use.\n\nIf ``dict`` is true, classify_pde() will return a dictionary of\nhint:match expression terms. This is intended for internal use by\npdsolve().  Note that because dictionaries are ordered arbitrarily,\nthis will most likely not be in the same order as the tuple.\n\nYou can get help on different hints by doing help(pde.pde_hintname),\nwhere hintname is the name of the hint without \"_Integral\".\n\nSee sympy.pde.allhints or the sympy.pde docstring for a list of all\nsupported hints that can be returned from classify_pde.\n\n\nExamples\n========\n\n>>> from sympy.solvers.pde import classify_pde\n>>> from sympy import Function, Eq\n>>> from sympy.abc import x, y\n>>> f = Function('f')\n>>> u = f(x, y)\n>>> ux = u.diff(x)\n>>> uy = u.diff(y)\n>>> eq = Eq(1 + (2*(ux/u)) + (3*(uy/u)), 0)\n>>> classify_pde(eq)\n('1st_linear_constant_coeff_homogeneous',)",
        "signature": "(eq, func=None, dict=False, *, prep=True, **kwargs)",
        "parameters": {
          "eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "func": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "dict": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "False",
            "annotation": null
          },
          "prep": {
            "kind": "KEYWORD_ONLY",
            "default": "True",
            "annotation": null
          },
          "kwargs": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "decompogen": {
        "doc": "Computes General functional decomposition of ``f``.\nGiven an expression ``f``, returns a list ``[f_1, f_2, ..., f_n]``,\nwhere::\n          f = f_1 o f_2 o ... f_n = f_1(f_2(... f_n))\n\nNote: This is a General decomposition function. It also decomposes\nPolynomials. For only Polynomial decomposition see ``decompose`` in polys.\n\nExamples\n========\n\n>>> from sympy.abc import x\n>>> from sympy import decompogen, sqrt, sin, cos\n>>> decompogen(sin(cos(x)), x)\n[sin(x), cos(x)]\n>>> decompogen(sin(x)**2 + sin(x) + 1, x)\n[x**2 + x + 1, sin(x)]\n>>> decompogen(sqrt(6*x**2 - 5), x)\n[sqrt(x), 6*x**2 - 5]\n>>> decompogen(sin(sqrt(cos(x**2 + 1))), x)\n[sin(x), sqrt(x), cos(x), x**2 + 1]\n>>> decompogen(x**4 + 2*x**3 - x - 1, x)\n[x**2 - x - 1, x**2 + x]",
        "signature": "(f, symbol)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "det_quick": {
        "doc": "Return ``det(M)`` assuming that either\nthere are lots of zeros or the size of the matrix\nis small. If this assumption is not met, then the normal\nMatrix.det function will be used with method = ``method``.\n\nSee Also\n========\n\ndet_minor\ndet_perm",
        "signature": "(M, method=None)",
        "parameters": {
          "M": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "method": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "diophantine": {
        "doc": "Simplify the solution procedure of diophantine equation ``eq`` by\nconverting it into a product of terms which should equal zero.\n\nExplanation\n===========\n\nFor example, when solving, `x^2 - y^2 = 0` this is treated as\n`(x + y)(x - y) = 0` and `x + y = 0` and `x - y = 0` are solved\nindependently and combined. Each term is solved by calling\n``diop_solve()``. (Although it is possible to call ``diop_solve()``\ndirectly, one must be careful to pass an equation in the correct\nform and to interpret the output correctly; ``diophantine()`` is\nthe public-facing function to use in general.)\n\nOutput of ``diophantine()`` is a set of tuples. The elements of the\ntuple are the solutions for each variable in the equation and\nare arranged according to the alphabetic ordering of the variables.\ne.g. For an equation with two variables, `a` and `b`, the first\nelement of the tuple is the solution for `a` and the second for `b`.\n\nUsage\n=====\n\n``diophantine(eq, t, syms)``: Solve the diophantine\nequation ``eq``.\n``t`` is the optional parameter to be used by ``diop_solve()``.\n``syms`` is an optional list of symbols which determines the\norder of the elements in the returned tuple.\n\nBy default, only the base solution is returned. If ``permute`` is set to\nTrue then permutations of the base solution and/or permutations of the\nsigns of the values will be returned when applicable.\n\nDetails\n=======\n\n``eq`` should be an expression which is assumed to be zero.\n``t`` is the parameter to be used in the solution.\n\nExamples\n========\n\n>>> from sympy import diophantine\n>>> from sympy.abc import a, b\n>>> eq = a**4 + b**4 - (2**4 + 3**4)\n>>> diophantine(eq)\n{(2, 3)}\n>>> diophantine(eq, permute=True)\n{(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n\n>>> from sympy.abc import x, y, z\n>>> diophantine(x**2 - y**2)\n{(t_0, -t_0), (t_0, t_0)}\n\n>>> diophantine(x*(2*x + 3*y - z))\n{(0, n1, n2), (t_0, t_1, 2*t_0 + 3*t_1)}\n>>> diophantine(x**2 + 3*x*y + 4*x)\n{(0, n1), (-3*t_0 - 4, t_0)}\n\nSee Also\n========\n\ndiop_solve\nsympy.utilities.iterables.permute_signs\nsympy.utilities.iterables.signed_permutations",
        "signature": "(eq, param=t, syms=None, permute=False)",
        "parameters": {
          "eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "param": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "t",
            "annotation": null
          },
          "syms": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "permute": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "False",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "dsolve": {
        "doc": "Solves any (supported) kind of ordinary differential equation and\nsystem of ordinary differential equations.\n\nFor single ordinary differential equation\n=========================================\n\nIt is classified under this when number of equation in ``eq`` is one.\n**Usage**\n\n    ``dsolve(eq, f(x), hint)`` -> Solve ordinary differential equation\n    ``eq`` for function ``f(x)``, using method ``hint``.\n\n**Details**\n\n    ``eq`` can be any supported ordinary differential equation (see the\n        :py:mod:`~sympy.solvers.ode` docstring for supported methods).\n        This can either be an :py:class:`~sympy.core.relational.Equality`,\n        or an expression, which is assumed to be equal to ``0``.\n\n    ``f(x)`` is a function of one variable whose derivatives in that\n        variable make up the ordinary differential equation ``eq``.  In\n        many cases it is not necessary to provide this; it will be\n        autodetected (and an error raised if it could not be detected).\n\n    ``hint`` is the solving method that you want dsolve to use.  Use\n        ``classify_ode(eq, f(x))`` to get all of the possible hints for an\n        ODE.  The default hint, ``default``, will use whatever hint is\n        returned first by :py:meth:`~sympy.solvers.ode.classify_ode`.  See\n        Hints below for more options that you can use for hint.\n\n    ``simplify`` enables simplification by\n        :py:meth:`~sympy.solvers.ode.ode.odesimp`.  See its docstring for more\n        information.  Turn this off, for example, to disable solving of\n        solutions for ``func`` or simplification of arbitrary constants.\n        It will still integrate with this hint. Note that the solution may\n        contain more arbitrary constants than the order of the ODE with\n        this option enabled.\n\n    ``xi`` and ``eta`` are the infinitesimal functions of an ordinary\n        differential equation. They are the infinitesimals of the Lie group\n        of point transformations for which the differential equation is\n        invariant. The user can specify values for the infinitesimals. If\n        nothing is specified, ``xi`` and ``eta`` are calculated using\n        :py:meth:`~sympy.solvers.ode.infinitesimals` with the help of various\n        heuristics.\n\n    ``ics`` is the set of initial/boundary conditions for the differential equation.\n      It should be given in the form of ``{f(x0): x1, f(x).diff(x).subs(x, x2):\n      x3}`` and so on.  For power series solutions, if no initial\n      conditions are specified ``f(0)`` is assumed to be ``C0`` and the power\n      series solution is calculated about 0.\n\n    ``x0`` is the point about which the power series solution of a differential\n      equation is to be evaluated.\n\n    ``n`` gives the exponent of the dependent variable up to which the power series\n      solution of a differential equation is to be evaluated.\n\n**Hints**\n\n    Aside from the various solving methods, there are also some meta-hints\n    that you can pass to :py:meth:`~sympy.solvers.ode.dsolve`:\n\n    ``default``:\n            This uses whatever hint is returned first by\n            :py:meth:`~sympy.solvers.ode.classify_ode`. This is the\n            default argument to :py:meth:`~sympy.solvers.ode.dsolve`.\n\n    ``all``:\n            To make :py:meth:`~sympy.solvers.ode.dsolve` apply all\n            relevant classification hints, use ``dsolve(ODE, func,\n            hint=\"all\")``.  This will return a dictionary of\n            ``hint:solution`` terms.  If a hint causes dsolve to raise the\n            ``NotImplementedError``, value of that hint's key will be the\n            exception object raised.  The dictionary will also include\n            some special keys:\n\n            - ``order``: The order of the ODE.  See also\n              :py:meth:`~sympy.solvers.deutils.ode_order` in\n              ``deutils.py``.\n            - ``best``: The simplest hint; what would be returned by\n              ``best`` below.\n            - ``best_hint``: The hint that would produce the solution\n              given by ``best``.  If more than one hint produces the best\n              solution, the first one in the tuple returned by\n              :py:meth:`~sympy.solvers.ode.classify_ode` is chosen.\n            - ``default``: The solution that would be returned by default.\n              This is the one produced by the hint that appears first in\n              the tuple returned by\n              :py:meth:`~sympy.solvers.ode.classify_ode`.\n\n    ``all_Integral``:\n            This is the same as ``all``, except if a hint also has a\n            corresponding ``_Integral`` hint, it only returns the\n            ``_Integral`` hint.  This is useful if ``all`` causes\n            :py:meth:`~sympy.solvers.ode.dsolve` to hang because of a\n            difficult or impossible integral.  This meta-hint will also be\n            much faster than ``all``, because\n            :py:meth:`~sympy.core.expr.Expr.integrate` is an expensive\n            routine.\n\n    ``best``:\n            To have :py:meth:`~sympy.solvers.ode.dsolve` try all methods\n            and return the simplest one.  This takes into account whether\n            the solution is solvable in the function, whether it contains\n            any Integral classes (i.e.  unevaluatable integrals), and\n            which one is the shortest in size.\n\n    See also the :py:meth:`~sympy.solvers.ode.classify_ode` docstring for\n    more info on hints, and the :py:mod:`~sympy.solvers.ode` docstring for\n    a list of all supported hints.\n\n**Tips**\n\n    - You can declare the derivative of an unknown function this way:\n\n        >>> from sympy import Function, Derivative\n        >>> from sympy.abc import x # x is the independent variable\n        >>> f = Function(\"f\")(x) # f is a function of x\n        >>> # f_ will be the derivative of f with respect to x\n        >>> f_ = Derivative(f, x)\n\n    - See ``test_ode.py`` for many tests, which serves also as a set of\n      examples for how to use :py:meth:`~sympy.solvers.ode.dsolve`.\n    - :py:meth:`~sympy.solvers.ode.dsolve` always returns an\n      :py:class:`~sympy.core.relational.Equality` class (except for the\n      case when the hint is ``all`` or ``all_Integral``).  If possible, it\n      solves the solution explicitly for the function being solved for.\n      Otherwise, it returns an implicit solution.\n    - Arbitrary constants are symbols named ``C1``, ``C2``, and so on.\n    - Because all solutions should be mathematically equivalent, some\n      hints may return the exact same result for an ODE. Often, though,\n      two different hints will return the same solution formatted\n      differently.  The two should be equivalent. Also note that sometimes\n      the values of the arbitrary constants in two different solutions may\n      not be the same, because one constant may have \"absorbed\" other\n      constants into it.\n    - Do ``help(ode.ode_<hintname>)`` to get help more information on a\n      specific hint, where ``<hintname>`` is the name of a hint without\n      ``_Integral``.\n\nFor system of ordinary differential equations\n=============================================\n\n**Usage**\n    ``dsolve(eq, func)`` -> Solve a system of ordinary differential\n    equations ``eq`` for ``func`` being list of functions including\n    `x(t)`, `y(t)`, `z(t)` where number of functions in the list depends\n    upon the number of equations provided in ``eq``.\n\n**Details**\n\n    ``eq`` can be any supported system of ordinary differential equations\n    This can either be an :py:class:`~sympy.core.relational.Equality`,\n    or an expression, which is assumed to be equal to ``0``.\n\n    ``func`` holds ``x(t)`` and ``y(t)`` being functions of one variable which\n    together with some of their derivatives make up the system of ordinary\n    differential equation ``eq``. It is not necessary to provide this; it\n    will be autodetected (and an error raised if it could not be detected).\n\n**Hints**\n\n    The hints are formed by parameters returned by classify_sysode, combining\n    them give hints name used later for forming method name.\n\nExamples\n========\n\n>>> from sympy import Function, dsolve, Eq, Derivative, sin, cos, symbols\n>>> from sympy.abc import x\n>>> f = Function('f')\n>>> dsolve(Derivative(f(x), x, x) + 9*f(x), f(x))\nEq(f(x), C1*sin(3*x) + C2*cos(3*x))\n\n>>> eq = sin(x)*cos(f(x)) + cos(x)*sin(f(x))*f(x).diff(x)\n>>> dsolve(eq, hint='1st_exact')\n[Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]\n>>> dsolve(eq, hint='almost_linear')\n[Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]\n>>> t = symbols('t')\n>>> x, y = symbols('x, y', cls=Function)\n>>> eq = (Eq(Derivative(x(t),t), 12*t*x(t) + 8*y(t)), Eq(Derivative(y(t),t), 21*x(t) + 7*t*y(t)))\n>>> dsolve(eq)\n[Eq(x(t), C1*x0(t) + C2*x0(t)*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)**2, t)),\nEq(y(t), C1*y0(t) + C2*(y0(t)*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)**2, t) +\nexp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)))]\n>>> eq = (Eq(Derivative(x(t),t),x(t)*y(t)*sin(t)), Eq(Derivative(y(t),t),y(t)**2*sin(t)))\n>>> dsolve(eq)\n{Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t))), Eq(y(t), -1/(C1 - cos(t)))}",
        "signature": "(eq, func=None, hint='default', simplify=True, ics=None, xi=None, eta=None, x0=0, n=6, **kwargs)",
        "parameters": {
          "eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "func": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "hint": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "default",
            "annotation": null
          },
          "simplify": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "True",
            "annotation": null
          },
          "ics": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "xi": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "eta": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "x0": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "0",
            "annotation": null
          },
          "n": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "6",
            "annotation": null
          },
          "kwargs": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "factor_system": {
        "doc": "Factorizes a system of polynomial equations into\nirreducible subsystems.\n\nParameters\n==========\n\neqs : list\n    List of expressions to be factored.\n    Each expression is assumed to be equal to zero.\n\ngens : list, optional\n    Generator(s) of the polynomial ring.\n    If not provided, all free symbols will be used.\n\n**kwargs : dict, optional\n    Same optional arguments taken by ``factor``\n\nReturns\n=======\n\nlist[list[Expr]]\n    A list of lists of expressions, where each sublist represents\n    an irreducible subsystem. When solved, each subsystem gives\n    one component of the solution. Only generic solutions are\n    returned (cases not requiring parameters to be zero).\n\nExamples\n========\n\n>>> from sympy.solvers.polysys import factor_system, factor_system_cond\n>>> from sympy.abc import x, y, a, b, c\n\nA simple system with multiple solutions:\n\n>>> factor_system([x**2 - 1, y - 1])\n[[x + 1, y - 1], [x - 1, y - 1]]\n\nA system with no solution:\n\n>>> factor_system([x, 1])\n[]\n\nA system where any value of the symbol(s) is a solution:\n\n>>> factor_system([x - x, (x + 1)**2 - (x**2 + 2*x + 1)])\n[[]]\n\nA system with no generic solution:\n\n>>> factor_system([a*x*(x-1), b*y, c], [x, y])\n[]\n\nIf c is added to the unknowns then the system has a generic solution:\n\n>>> factor_system([a*x*(x-1), b*y, c], [x, y, c])\n[[x - 1, y, c], [x, y, c]]\n\nAlternatively :func:`factor_system_cond` can be used to get degenerate\ncases as well:\n\n>>> factor_system_cond([a*x*(x-1), b*y, c], [x, y])\n[[x - 1, y, c], [x, y, c], [x - 1, b, c], [x, b, c], [y, a, c], [a, b, c]]\n\nEach of the above cases is only satisfiable in the degenerate case `c = 0`.\n\nThe solution set of the original system represented\nby eqs is the union of the solution sets of the\nfactorized systems.\n\nAn empty list [] means no generic solution exists.\nA list containing an empty list [[]] means any value of\nthe symbol(s) is a solution.\n\nSee Also\n========\n\nfactor_system_cond : Returns both generic and degenerate solutions\nfactor_system_bool : Returns a Boolean combination representing all solutions\nsympy.polys.polytools.factor : Factors a polynomial into irreducible factors\n                               over the rational numbers",
        "signature": "(eqs: 'Sequence[Expr | complex]', gens: 'Sequence[Expr]' = (), **kwargs: 'Any') -> 'list[list[Expr]]'",
        "parameters": {
          "eqs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": "Sequence[Expr | complex]"
          },
          "gens": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "()",
            "annotation": "Sequence[Expr]"
          },
          "kwargs": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": "Any"
          }
        },
        "return_annotation": "list[list[Expr]]"
      },
      "homogeneous_order": {
        "doc": "Returns the order `n` if `g` is homogeneous and ``None`` if it is not\nhomogeneous.\n\nDetermines if a function is homogeneous and if so of what order.  A\nfunction `f(x, y, \\cdots)` is homogeneous of order `n` if `f(t x, t y,\n\\cdots) = t^n f(x, y, \\cdots)`.\n\nIf the function is of two variables, `F(x, y)`, then `f` being homogeneous\nof any order is equivalent to being able to rewrite `F(x, y)` as `G(x/y)`\nor `H(y/x)`.  This fact is used to solve 1st order ordinary differential\nequations whose coefficients are homogeneous of the same order (see the\ndocstrings of\n:obj:`~sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep` and\n:obj:`~sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep`).\n\nSymbols can be functions, but every argument of the function must be a\nsymbol, and the arguments of the function that appear in the expression\nmust match those given in the list of symbols.  If a declared function\nappears with different arguments than given in the list of symbols,\n``None`` is returned.\n\nExamples\n========\n\n>>> from sympy import Function, homogeneous_order, sqrt\n>>> from sympy.abc import x, y\n>>> f = Function('f')\n>>> homogeneous_order(f(x), f(x)) is None\nTrue\n>>> homogeneous_order(f(x,y), f(y, x), x, y) is None\nTrue\n>>> homogeneous_order(f(x), f(x), x)\n1\n>>> homogeneous_order(x**2*f(x)/sqrt(x**2+f(x)**2), x, f(x))\n2\n>>> homogeneous_order(x**2+f(x), x, f(x)) is None\nTrue",
        "signature": "(eq, *symbols)",
        "parameters": {
          "eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbols": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "inv_quick": {
        "doc": "Return the inverse of ``M``, assuming that either\nthere are lots of zeros or the size of the matrix\nis small.",
        "signature": "(M)",
        "parameters": {
          "M": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "linear_eq_to_matrix": {
        "doc": "Converts a given System of Equations into Matrix form. Here ``equations``\nmust be a linear system of equations in ``symbols``. Element ``M[i, j]``\ncorresponds to the coefficient of the jth symbol in the ith equation.\n\nThe Matrix form corresponds to the augmented matrix form. For example:\n\n.. math::\n\n   4x + 2y + 3z & = 1 \\\\\n   3x +  y +  z & = -6 \\\\\n   2x + 4y + 9z & = 2\n\nThis system will return :math:`A` and :math:`b` as:\n\n.. math::\n\n   A = \\left[\\begin{array}{ccc}\n   4 & 2 & 3 \\\\\n   3 & 1 & 1 \\\\\n   2 & 4 & 9\n   \\end{array}\\right] \\\\\n\n.. math::\n\n   b = \\left[\\begin{array}{c}\n   1 \\\\ -6 \\\\ 2\n   \\end{array}\\right]\n\nThe only simplification performed is to convert\n``Eq(a, b)`` :math:`\\Rightarrow a - b`.\n\nRaises\n======\n\nNonlinearError\n    The equations contain a nonlinear term.\nValueError\n    The symbols are not given or are not unique.\n\nExamples\n========\n\n>>> from sympy import linear_eq_to_matrix, symbols\n>>> c, x, y, z = symbols('c, x, y, z')\n\nThe coefficients (numerical or symbolic) of the symbols will\nbe returned as matrices:\n\n>>> eqns = [c*x + z - 1 - c, y + z, x - y]\n>>> A, b = linear_eq_to_matrix(eqns, [x, y, z])\n>>> A\nMatrix([\n[c,  0, 1],\n[0,  1, 1],\n[1, -1, 0]])\n>>> b\nMatrix([\n[c + 1],\n[    0],\n[    0]])\n\nThis routine does not simplify expressions and will raise an error\nif nonlinearity is encountered:\n\n>>> eqns = [\n...     (x**2 - 3*x)/(x - 3) - 3,\n...     y**2 - 3*y - y*(y - 4) + x - 4]\n>>> linear_eq_to_matrix(eqns, [x, y])\nTraceback (most recent call last):\n...\nNonlinearError:\nsymbol-dependent term can be ignored using `strict=False`\n\nSimplifying these equations will discard the removable singularity in the\nfirst and reveal the linear structure of the second:\n\n>>> [e.simplify() for e in eqns]\n[x - 3, x + y - 4]\n\nAny such simplification needed to eliminate nonlinear terms must be done\n*before* calling this routine.",
        "signature": "(equations, *symbols)",
        "parameters": {
          "equations": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbols": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "linprog": {
        "doc": "Return the minimization of ``c*x`` with the given\nconstraints ``A*x <= b`` and ``A_eq*x = b_eq``. Unless bounds\nare given, variables will have nonnegative values in the solution.\n\nIf ``A`` is not given, then the dimension of the system will\nbe determined by the length of ``C``.\n\nBy default, all variables will be nonnegative. If ``bounds``\nis given as a single tuple, ``(lo, hi)``, then all variables\nwill be constrained to be between ``lo`` and ``hi``. Use\nNone for a ``lo`` or ``hi`` if it is unconstrained in the\nnegative or positive direction, respectively, e.g.\n``(None, 0)`` indicates nonpositive values. To set\nindividual ranges, pass a list with length equal to the\nnumber of columns in ``A``, each element being a tuple; if\nonly a few variables take on non-default values they can be\npassed as a dictionary with keys giving the corresponding\ncolumn to which the variable is assigned, e.g. ``bounds={2:\n(1, 4)}`` would limit the 3rd variable to have a value in\nrange ``[1, 4]``.\n\nExamples\n========\n\n>>> from sympy.solvers.simplex import linprog\n>>> from sympy import symbols, Eq, linear_eq_to_matrix as M, Matrix\n>>> x = x1, x2, x3, x4 = symbols('x1:5')\n>>> X = Matrix(x)\n>>> c, d = M(5*x2 + x3 + 4*x4 - x1, x)\n>>> a, b = M([5*x2 + 2*x3 + 5*x4 - (x1 + 5)], x)\n>>> aeq, beq = M([Eq(3*x2 + x4, 2), Eq(-x1 + x3 + 2*x4, 1)], x)\n>>> constr = [i <= j for i,j in zip(a*X, b)]\n>>> constr += [Eq(i, j) for i,j in zip(aeq*X, beq)]\n>>> linprog(c, a, b, aeq, beq)\n(9/2, [0, 1/2, 0, 1/2])\n>>> assert all(i.subs(dict(zip(x, _[1]))) for i in constr)\n\nSee Also\n========\nlpmin, lpmax",
        "signature": "(c, A=None, b=None, A_eq=None, b_eq=None, bounds=None)",
        "parameters": {
          "c": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "A": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "b": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "A_eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "b_eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "bounds": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "linsolve": {
        "doc": "Solve system of $N$ linear equations with $M$ variables; both\nunderdetermined and overdetermined systems are supported.\nThe possible number of solutions is zero, one or infinite.\nZero solutions throws a ValueError, whereas infinite\nsolutions are represented parametrically in terms of the given\nsymbols. For unique solution a :class:`~.FiniteSet` of ordered tuples\nis returned.\n\nAll standard input formats are supported:\nFor the given set of equations, the respective input types\nare given below:\n\n.. math:: 3x + 2y -   z = 1\n.. math:: 2x - 2y + 4z = -2\n.. math:: 2x -   y + 2z = 0\n\n* Augmented matrix form, ``system`` given below:\n\n$$ \\text{system} = \\left[{array}{cccc}\n    3 &  2 & -1 &  1\\\\\n    2 & -2 &  4 & -2\\\\\n    2 & -1 &  2 &  0\n    \\end{array}\\right] $$\n\n::\n\n    system = Matrix([[3, 2, -1, 1], [2, -2, 4, -2], [2, -1, 2, 0]])\n\n* List of equations form\n\n::\n\n    system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]\n\n* Input $A$ and $b$ in matrix form (from $Ax = b$) are given as:\n\n$$ A = \\left[\\begin{array}{ccc}\n    3 &  2 & -1 \\\\\n    2 & -2 &  4 \\\\\n    2 & -1 &  2\n    \\end{array}\\right] \\ \\  b = \\left[\\begin{array}{c}\n    1 \\\\ -2 \\\\ 0\n    \\end{array}\\right] $$\n\n::\n\n    A = Matrix([[3, 2, -1], [2, -2, 4], [2, -1, 2]])\n    b = Matrix([[1], [-2], [0]])\n    system = (A, b)\n\nSymbols can always be passed but are actually only needed\nwhen 1) a system of equations is being passed and 2) the\nsystem is passed as an underdetermined matrix and one wants\nto control the name of the free variables in the result.\nAn error is raised if no symbols are used for case 1, but if\nno symbols are provided for case 2, internally generated symbols\nwill be provided. When providing symbols for case 2, there should\nbe at least as many symbols are there are columns in matrix A.\n\nThe algorithm used here is Gauss-Jordan elimination, which\nresults, after elimination, in a row echelon form matrix.\n\nReturns\n=======\n\nA FiniteSet containing an ordered tuple of values for the\nunknowns for which the `system` has a solution. (Wrapping\nthe tuple in FiniteSet is used to maintain a consistent\noutput format throughout solveset.)\n\nReturns EmptySet, if the linear system is inconsistent.\n\nRaises\n======\n\nValueError\n    The input is not valid.\n    The symbols are not given.\n\nExamples\n========\n\n>>> from sympy import Matrix, linsolve, symbols\n>>> x, y, z = symbols(\"x, y, z\")\n>>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\n>>> b = Matrix([3, 6, 9])\n>>> A\nMatrix([\n[1, 2,  3],\n[4, 5,  6],\n[7, 8, 10]])\n>>> b\nMatrix([\n[3],\n[6],\n[9]])\n>>> linsolve((A, b), [x, y, z])\n{(-1, 2, 0)}\n\n* Parametric Solution: In case the system is underdetermined, the\n  function will return a parametric solution in terms of the given\n  symbols. Those that are free will be returned unchanged. e.g. in\n  the system below, `z` is returned as the solution for variable z;\n  it can take on any value.\n\n>>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n>>> b = Matrix([3, 6, 9])\n>>> linsolve((A, b), x, y, z)\n{(z - 1, 2 - 2*z, z)}\n\nIf no symbols are given, internally generated symbols will be used.\nThe ``tau0`` in the third position indicates (as before) that the third\nvariable -- whatever it is named -- can take on any value:\n\n>>> linsolve((A, b))\n{(tau0 - 1, 2 - 2*tau0, tau0)}\n\n* List of equations as input\n\n>>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]\n>>> linsolve(Eqns, x, y, z)\n{(1, -2, -2)}\n\n* Augmented matrix as input\n\n>>> aug = Matrix([[2, 1, 3, 1], [2, 6, 8, 3], [6, 8, 18, 5]])\n>>> aug\nMatrix([\n[2, 1,  3, 1],\n[2, 6,  8, 3],\n[6, 8, 18, 5]])\n>>> linsolve(aug, x, y, z)\n{(3/10, 2/5, 0)}\n\n* Solve for symbolic coefficients\n\n>>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')\n>>> eqns = [a*x + b*y - c, d*x + e*y - f]\n>>> linsolve(eqns, x, y)\n{((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))}\n\n* A degenerate system returns solution as set of given\n  symbols.\n\n>>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))\n>>> linsolve(system, x, y)\n{(x, y)}\n\n* For an empty system linsolve returns empty set\n\n>>> linsolve([], x)\nEmptySet\n\n* An error is raised if any nonlinearity is detected, even\n  if it could be removed with expansion\n\n>>> linsolve([x*(1/x - 1)], x)\nTraceback (most recent call last):\n...\nNonlinearError: nonlinear term: 1/x\n\n>>> linsolve([x*(y + 1)], x, y)\nTraceback (most recent call last):\n...\nNonlinearError: nonlinear cross-term: x*(y + 1)\n\n>>> linsolve([x**2 - 1], x)\nTraceback (most recent call last):\n...\nNonlinearError: nonlinear term: x**2",
        "signature": "(system, *symbols)",
        "parameters": {
          "system": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbols": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "lpmax": {
        "doc": "return maximum of linear equation ``f`` under\nlinear constraints expressed using Ge, Le or Eq.\n\nAll variables are unbounded unless constrained.\n\nExamples\n========\n\n>>> from sympy.solvers.simplex import lpmax\n>>> from sympy import Eq\n>>> from sympy.abc import x, y\n>>> lpmax(x, [2*x - 3*y >= -1, Eq(x+ 3*y,2), x <= 2*y])\n(4/5, {x: 4/5, y: 2/5})\n\nNegative values for variables are permitted unless explicitly\nexcluding:\n\n>>> lpmax(x, [x <= -1])\n(-1, {x: -1})\n\nIf a non-negative constraint is added for x, there is no\npossible solution:\n\n>>> lpmax(x, [x <= -1, x >= 0])\nTraceback (most recent call last):\n...\nsympy.solvers.simplex.InfeasibleLPError: inconsistent/False constraint\n\nSee Also\n========\nlinprog, lpmin",
        "signature": "(f, constr)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "constr": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "lpmin": {
        "doc": "return minimum of linear equation ``f`` under\nlinear constraints expressed using Ge, Le or Eq.\n\nAll variables are unbounded unless constrained.\n\nExamples\n========\n\n>>> from sympy.solvers.simplex import lpmin\n>>> from sympy import Eq\n>>> from sympy.abc import x, y\n>>> lpmin(x, [2*x - 3*y >= -1, Eq(x + 3*y, 2), x <= 2*y])\n(1/3, {x: 1/3, y: 5/9})\n\nNegative values for variables are permitted unless explicitly\nexcluding, so minimizing ``x`` for ``x <= 3`` is an\nunbounded problem while the following has a bounded solution:\n\n>>> lpmin(x, [x >= 0, x <= 3])\n(0, {x: 0})\n\nWithout indicating that ``x`` is nonnegative, there\nis no minimum for this objective:\n\n>>> lpmin(x, [x <= 3])\nTraceback (most recent call last):\n...\nsympy.solvers.simplex.UnboundedLPError:\nObjective function can assume arbitrarily large values!\n\nSee Also\n========\nlinprog, lpmax",
        "signature": "(f, constr)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "constr": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "nonlinsolve": {
        "doc": "Solve system of $N$ nonlinear equations with $M$ variables, which means both\nunder and overdetermined systems are supported. Positive dimensional\nsystem is also supported (A system with infinitely many solutions is said\nto be positive-dimensional). In a positive dimensional system the solution will\nbe dependent on at least one symbol. Returns both real solution\nand complex solution (if they exist).\n\nParameters\n==========\n\nsystem : list of equations\n    The target system of equations\nsymbols : list of Symbols\n    symbols should be given as a sequence eg. list\n\nReturns\n=======\n\nA :class:`~.FiniteSet` of ordered tuple of values of `symbols` for which the `system`\nhas solution. Order of values in the tuple is same as symbols present in\nthe parameter `symbols`.\n\nPlease note that general :class:`~.FiniteSet` is unordered, the solution\nreturned here is not simply a :class:`~.FiniteSet` of solutions, rather it\nis a :class:`~.FiniteSet` of ordered tuple, i.e. the first and only\nargument to :class:`~.FiniteSet` is a tuple of solutions, which is\nordered, and, hence ,the returned solution is ordered.\n\nAlso note that solution could also have been returned as an ordered tuple,\nFiniteSet is just a wrapper ``{}`` around the tuple. It has no other\nsignificance except for the fact it is just used to maintain a consistent\noutput format throughout the solveset.\n\nFor the given set of equations, the respective input types\nare given below:\n\n.. math:: xy - 1 = 0\n.. math:: 4x^2 + y^2 - 5 = 0\n\n::\n\n   system  = [x*y - 1, 4*x**2 + y**2 - 5]\n   symbols = [x, y]\n\nRaises\n======\n\nValueError\n    The input is not valid.\n    The symbols are not given.\nAttributeError\n    The input symbols are not `Symbol` type.\n\nExamples\n========\n\n>>> from sympy import symbols, nonlinsolve\n>>> x, y, z = symbols('x, y, z', real=True)\n>>> nonlinsolve([x*y - 1, 4*x**2 + y**2 - 5], [x, y])\n{(-1, -1), (-1/2, -2), (1/2, 2), (1, 1)}\n\n1. Positive dimensional system and complements:\n\n>>> from sympy import pprint\n>>> from sympy.polys.polytools import is_zero_dimensional\n>>> a, b, c, d = symbols('a, b, c, d', extended_real=True)\n>>> eq1 =  a + b + c + d\n>>> eq2 = a*b + b*c + c*d + d*a\n>>> eq3 = a*b*c + b*c*d + c*d*a + d*a*b\n>>> eq4 = a*b*c*d - 1\n>>> system = [eq1, eq2, eq3, eq4]\n>>> is_zero_dimensional(system)\nFalse\n>>> pprint(nonlinsolve(system, [a, b, c, d]), use_unicode=False)\n  -1       1               1      -1\n{(---, -d, -, {d} \\ {0}), (-, -d, ---, {d} \\ {0})}\n   d       d               d       d\n>>> nonlinsolve([(x+y)**2 - 4, x + y - 2], [x, y])\n{(2 - y, y)}\n\n2. If some of the equations are non-polynomial then `nonlinsolve`\nwill call the ``substitution`` function and return real and complex solutions,\nif present.\n\n>>> from sympy import exp, sin\n>>> nonlinsolve([exp(x) - sin(y), y**2 - 4], [x, y])\n{(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),\n (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}\n\n3. If system is non-linear polynomial and zero-dimensional then it\nreturns both solution (real and complex solutions, if present) using\n:func:`~.solve_poly_system`:\n\n>>> from sympy import sqrt\n>>> nonlinsolve([x**2 - 2*y**2 -2, x*y - 2], [x, y])\n{(-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I)}\n\n4. ``nonlinsolve`` can solve some linear (zero or positive dimensional)\nsystem (because it uses the :func:`sympy.polys.polytools.groebner` function to get the\ngroebner basis and then uses the ``substitution`` function basis as the\nnew `system`). But it is not recommended to solve linear system using\n``nonlinsolve``, because :func:`~.linsolve` is better for general linear systems.\n\n>>> nonlinsolve([x + 2*y -z - 3, x - y - 4*z + 9, y + z - 4], [x, y, z])\n{(3*z - 5, 4 - z, z)}\n\n5. System having polynomial equations and only real solution is\nsolved using :func:`~.solve_poly_system`:\n\n>>> e1 = sqrt(x**2 + y**2) - 10\n>>> e2 = sqrt(y**2 + (-x + 10)**2) - 3\n>>> nonlinsolve((e1, e2), (x, y))\n{(191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20)}\n>>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [x, y])\n{(1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5))}\n>>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [y, x])\n{(2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5))}\n\n6. It is better to use symbols instead of trigonometric functions or\n:class:`~.Function`. For example, replace $\\sin(x)$ with a symbol, replace\n$f(x)$ with a symbol and so on. Get a solution from ``nonlinsolve`` and then\nuse :func:`~.solveset` to get the value of $x$.\n\nHow nonlinsolve is better than old solver ``_solve_system`` :\n=============================================================\n\n1. A positive dimensional system solver: nonlinsolve can return\nsolution for positive dimensional system. It finds the\nGroebner Basis of the positive dimensional system(calling it as\nbasis) then we can start solving equation(having least number of\nvariable first in the basis) using solveset and substituting that\nsolved solutions into other equation(of basis) to get solution in\nterms of minimum variables. Here the important thing is how we\nare substituting the known values and in which equations.\n\n2. Real and complex solutions: nonlinsolve returns both real\nand complex solution. If all the equations in the system are polynomial\nthen using :func:`~.solve_poly_system` both real and complex solution is returned.\nIf all the equations in the system are not polynomial equation then goes to\n``substitution`` method with this polynomial and non polynomial equation(s),\nto solve for unsolved variables. Here to solve for particular variable\nsolveset_real and solveset_complex is used. For both real and complex\nsolution ``_solve_using_known_values`` is used inside ``substitution``\n(``substitution`` will be called when any non-polynomial equation is present).\nIf a solution is valid its general solution is added to the final result.\n\n3. :class:`~.Complement` and :class:`~.Intersection` will be added:\nnonlinsolve maintains dict for complements and intersections. If solveset\nfind complements or/and intersections with any interval or set during the\nexecution of ``substitution`` function, then complement or/and\nintersection for that variable is added before returning final solution.",
        "signature": "(system, *symbols)",
        "parameters": {
          "system": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbols": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "nsolve": {
        "doc": "Solve a nonlinear equation system numerically: ``nsolve(f, [args,] x0,\nmodules=['mpmath'], **kwargs)``.\n\nExplanation\n===========\n\n``f`` is a vector function of symbolic expressions representing the system.\n*args* are the variables. If there is only one variable, this argument can\nbe omitted. ``x0`` is a starting vector close to a solution.\n\nUse the modules keyword to specify which modules should be used to\nevaluate the function and the Jacobian matrix. Make sure to use a module\nthat supports matrices. For more information on the syntax, please see the\ndocstring of ``lambdify``.\n\nIf the keyword arguments contain ``dict=True`` (default is False) ``nsolve``\nwill return a list (perhaps empty) of solution mappings. This might be\nespecially useful if you want to use ``nsolve`` as a fallback to solve since\nusing the dict argument for both methods produces return values of\nconsistent type structure. Please note: to keep this consistent with\n``solve``, the solution will be returned in a list even though ``nsolve``\n(currently at least) only finds one solution at a time.\n\nOverdetermined systems are supported.\n\nExamples\n========\n\n>>> from sympy import Symbol, nsolve\n>>> import mpmath\n>>> mpmath.mp.dps = 15\n>>> x1 = Symbol('x1')\n>>> x2 = Symbol('x2')\n>>> f1 = 3 * x1**2 - 2 * x2**2 - 1\n>>> f2 = x1**2 - 2 * x1 + x2**2 + 2 * x2 - 8\n>>> print(nsolve((f1, f2), (x1, x2), (-1, 1)))\nMatrix([[-1.19287309935246], [1.27844411169911]])\n\nFor one-dimensional functions the syntax is simplified:\n\n>>> from sympy import sin, nsolve\n>>> from sympy.abc import x\n>>> nsolve(sin(x), x, 2)\n3.14159265358979\n>>> nsolve(sin(x), 2)\n3.14159265358979\n\nTo solve with higher precision than the default, use the prec argument:\n\n>>> from sympy import cos\n>>> nsolve(cos(x) - x, 1)\n0.739085133215161\n>>> nsolve(cos(x) - x, 1, prec=50)\n0.73908513321516064165531208767387340401341175890076\n>>> cos(_)\n0.73908513321516064165531208767387340401341175890076\n\nTo solve for complex roots of real functions, a nonreal initial point\nmust be specified:\n\n>>> from sympy import I\n>>> nsolve(x**2 + 2, I)\n1.4142135623731*I\n\n``mpmath.findroot`` is used and you can find their more extensive\ndocumentation, especially concerning keyword parameters and\navailable solvers. Note, however, that functions which are very\nsteep near the root, the verification of the solution may fail. In\nthis case you should use the flag ``verify=False`` and\nindependently verify the solution.\n\n>>> from sympy import cos, cosh\n>>> f = cos(x)*cosh(x) - 1\n>>> nsolve(f, 3.14*100)\nTraceback (most recent call last):\n...\nValueError: Could not find root within given tolerance. (1.39267e+230 > 2.1684e-19)\n>>> ans = nsolve(f, 3.14*100, verify=False); ans\n312.588469032184\n>>> f.subs(x, ans).n(2)\n2.1e+121\n>>> (f/f.diff(x)).subs(x, ans).n(2)\n7.4e-15\n\nOne might safely skip the verification if bounds of the root are known\nand a bisection method is used:\n\n>>> bounds = lambda i: (3.14*i, 3.14*(i + 1))\n>>> nsolve(f, bounds(100), solver='bisect', verify=False)\n315.730061685774\n\nAlternatively, a function may be better behaved when the\ndenominator is ignored. Since this is not always the case, however,\nthe decision of what function to use is left to the discretion of\nthe user.\n\n>>> eq = x**2/(1 - x)/(1 - 2*x)**2 - 100\n>>> nsolve(eq, 0.46)\nTraceback (most recent call last):\n...\nValueError: Could not find root within given tolerance. (10000 > 2.1684e-19)\nTry another starting point or tweak arguments.\n>>> nsolve(eq.as_numer_denom()[0], 0.46)\n0.46792545969349058",
        "signature": "(*args, dict=False, **kwargs)",
        "parameters": {
          "args": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          },
          "dict": {
            "kind": "KEYWORD_ONLY",
            "default": "False",
            "annotation": null
          },
          "kwargs": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "ode_order": {
        "doc": "Returns the order of a given differential\nequation with respect to func.\n\nThis function is implemented recursively.\n\nExamples\n========\n\n>>> from sympy import Function\n>>> from sympy.solvers.deutils import ode_order\n>>> from sympy.abc import x\n>>> f, g = map(Function, ['f', 'g'])\n>>> ode_order(f(x).diff(x, 2) + f(x).diff(x)**2 +\n... f(x).diff(x), f(x))\n2\n>>> ode_order(f(x).diff(x, 2) + g(x).diff(x, 3), f(x))\n2\n>>> ode_order(f(x).diff(x, 2) + g(x).diff(x, 3), g(x))\n3",
        "signature": "(expr, func)",
        "parameters": {
          "expr": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "func": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "pde_separate": {
        "doc": "Separate variables in partial differential equation either by additive\nor multiplicative separation approach. It tries to rewrite an equation so\nthat one of the specified variables occurs on a different side of the\nequation than the others.\n\n:param eq: Partial differential equation\n\n:param fun: Original function F(x, y, z)\n\n:param sep: List of separated functions [X(x), u(y, z)]\n\n:param strategy: Separation strategy. You can choose between additive\n    separation ('add') and multiplicative separation ('mul') which is\n    default.\n\nExamples\n========\n\n>>> from sympy import E, Eq, Function, pde_separate, Derivative as D\n>>> from sympy.abc import x, t\n>>> u, X, T = map(Function, 'uXT')\n\n>>> eq = Eq(D(u(x, t), x), E**(u(x, t))*D(u(x, t), t))\n>>> pde_separate(eq, u(x, t), [X(x), T(t)], strategy='add')\n[exp(-X(x))*Derivative(X(x), x), exp(T(t))*Derivative(T(t), t)]\n\n>>> eq = Eq(D(u(x, t), x, 2), D(u(x, t), t, 2))\n>>> pde_separate(eq, u(x, t), [X(x), T(t)], strategy='mul')\n[Derivative(X(x), (x, 2))/X(x), Derivative(T(t), (t, 2))/T(t)]\n\nSee Also\n========\npde_separate_add, pde_separate_mul",
        "signature": "(eq, fun, sep, strategy='mul')",
        "parameters": {
          "eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "fun": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "sep": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "strategy": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "mul",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "pde_separate_add": {
        "doc": "Helper function for searching additive separable solutions.\n\nConsider an equation of two independent variables x, y and a dependent\nvariable w, we look for the product of two functions depending on different\narguments:\n\n`w(x, y, z) = X(x) + y(y, z)`\n\nExamples\n========\n\n>>> from sympy import E, Eq, Function, pde_separate_add, Derivative as D\n>>> from sympy.abc import x, t\n>>> u, X, T = map(Function, 'uXT')\n\n>>> eq = Eq(D(u(x, t), x), E**(u(x, t))*D(u(x, t), t))\n>>> pde_separate_add(eq, u(x, t), [X(x), T(t)])\n[exp(-X(x))*Derivative(X(x), x), exp(T(t))*Derivative(T(t), t)]",
        "signature": "(eq, fun, sep)",
        "parameters": {
          "eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "fun": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "sep": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "pde_separate_mul": {
        "doc": "Helper function for searching multiplicative separable solutions.\n\nConsider an equation of two independent variables x, y and a dependent\nvariable w, we look for the product of two functions depending on different\narguments:\n\n`w(x, y, z) = X(x)*u(y, z)`\n\nExamples\n========\n\n>>> from sympy import Function, Eq, pde_separate_mul, Derivative as D\n>>> from sympy.abc import x, y\n>>> u, X, Y = map(Function, 'uXY')\n\n>>> eq = Eq(D(u(x, y), x, 2), D(u(x, y), y, 2))\n>>> pde_separate_mul(eq, u(x, y), [X(x), Y(y)])\n[Derivative(X(x), (x, 2))/X(x), Derivative(Y(y), (y, 2))/Y(y)]",
        "signature": "(eq, fun, sep)",
        "parameters": {
          "eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "fun": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "sep": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "pdsolve": {
        "doc": "Solves any (supported) kind of partial differential equation.\n\n**Usage**\n\n    pdsolve(eq, f(x,y), hint) -> Solve partial differential equation\n    eq for function f(x,y), using method hint.\n\n**Details**\n\n    ``eq`` can be any supported partial differential equation (see\n        the pde docstring for supported methods).  This can either\n        be an Equality, or an expression, which is assumed to be\n        equal to 0.\n\n    ``f(x,y)`` is a function of two variables whose derivatives in that\n        variable make up the partial differential equation. In many\n        cases it is not necessary to provide this; it will be autodetected\n        (and an error raised if it could not be detected).\n\n    ``hint`` is the solving method that you want pdsolve to use.  Use\n        classify_pde(eq, f(x,y)) to get all of the possible hints for\n        a PDE.  The default hint, 'default', will use whatever hint\n        is returned first by classify_pde().  See Hints below for\n        more options that you can use for hint.\n\n    ``solvefun`` is the convention used for arbitrary functions returned\n        by the PDE solver. If not set by the user, it is set by default\n        to be F.\n\n**Hints**\n\n    Aside from the various solving methods, there are also some\n    meta-hints that you can pass to pdsolve():\n\n    \"default\":\n            This uses whatever hint is returned first by\n            classify_pde(). This is the default argument to\n            pdsolve().\n\n    \"all\":\n            To make pdsolve apply all relevant classification hints,\n            use pdsolve(PDE, func, hint=\"all\").  This will return a\n            dictionary of hint:solution terms.  If a hint causes\n            pdsolve to raise the NotImplementedError, value of that\n            hint's key will be the exception object raised.  The\n            dictionary will also include some special keys:\n\n            - order: The order of the PDE.  See also ode_order() in\n              deutils.py\n            - default: The solution that would be returned by\n              default.  This is the one produced by the hint that\n              appears first in the tuple returned by classify_pde().\n\n    \"all_Integral\":\n            This is the same as \"all\", except if a hint also has a\n            corresponding \"_Integral\" hint, it only returns the\n            \"_Integral\" hint.  This is useful if \"all\" causes\n            pdsolve() to hang because of a difficult or impossible\n            integral.  This meta-hint will also be much faster than\n            \"all\", because integrate() is an expensive routine.\n\n    See also the classify_pde() docstring for more info on hints,\n    and the pde docstring for a list of all supported hints.\n\n**Tips**\n    - You can declare the derivative of an unknown function this way:\n\n        >>> from sympy import Function, Derivative\n        >>> from sympy.abc import x, y # x and y are the independent variables\n        >>> f = Function(\"f\")(x, y) # f is a function of x and y\n        >>> # fx will be the partial derivative of f with respect to x\n        >>> fx = Derivative(f, x)\n        >>> # fy will be the partial derivative of f with respect to y\n        >>> fy = Derivative(f, y)\n\n    - See test_pde.py for many tests, which serves also as a set of\n      examples for how to use pdsolve().\n    - pdsolve always returns an Equality class (except for the case\n      when the hint is \"all\" or \"all_Integral\"). Note that it is not possible\n      to get an explicit solution for f(x, y) as in the case of ODE's\n    - Do help(pde.pde_hintname) to get help more information on a\n      specific hint\n\n\nExamples\n========\n\n>>> from sympy.solvers.pde import pdsolve\n>>> from sympy import Function, Eq\n>>> from sympy.abc import x, y\n>>> f = Function('f')\n>>> u = f(x, y)\n>>> ux = u.diff(x)\n>>> uy = u.diff(y)\n>>> eq = Eq(1 + (2*(ux/u)) + (3*(uy/u)), 0)\n>>> pdsolve(eq)\nEq(f(x, y), F(3*x - 2*y)*exp(-2*x/13 - 3*y/13))",
        "signature": "(eq, func=None, hint='default', dict=False, solvefun=None, **kwargs)",
        "parameters": {
          "eq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "func": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "hint": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "default",
            "annotation": null
          },
          "dict": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "False",
            "annotation": null
          },
          "solvefun": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "kwargs": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "reduce_abs_inequalities": {
        "doc": "Reduce a system of inequalities with nested absolute values.\n\nExamples\n========\n\n>>> from sympy import reduce_abs_inequalities, Abs, Symbol\n>>> x = Symbol('x', extended_real=True)\n\n>>> reduce_abs_inequalities([(Abs(3*x - 5) - 7, '<'),\n... (Abs(x + 25) - 13, '>')], x)\n(-2/3 < x) & (x < 4) & (((-oo < x) & (x < -38)) | ((-12 < x) & (x < oo)))\n\n>>> reduce_abs_inequalities([(Abs(x - 4) + Abs(3*x - 5) - 7, '<')], x)\n(1/2 < x) & (x < 4)\n\nSee Also\n========\n\nreduce_abs_inequality",
        "signature": "(exprs, gen)",
        "parameters": {
          "exprs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "gen": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "reduce_abs_inequality": {
        "doc": "Reduce an inequality with nested absolute values.\n\nExamples\n========\n\n>>> from sympy import reduce_abs_inequality, Abs, Symbol\n>>> x = Symbol('x', real=True)\n\n>>> reduce_abs_inequality(Abs(x - 5) - 3, '<', x)\n(2 < x) & (x < 8)\n\n>>> reduce_abs_inequality(Abs(x + 2)*3 - 13, '<', x)\n(-19/3 < x) & (x < 7/3)\n\nSee Also\n========\n\nreduce_abs_inequalities",
        "signature": "(expr, rel, gen)",
        "parameters": {
          "expr": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "rel": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "gen": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "reduce_inequalities": {
        "doc": "Reduce a system of inequalities with rational coefficients.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> from sympy import reduce_inequalities\n\n>>> reduce_inequalities(0 <= x + 3, [])\n(-3 <= x) & (x < oo)\n\n>>> reduce_inequalities(0 <= x + y*2 - 1, [x])\n(x < oo) & (x >= 1 - 2*y)",
        "signature": "(inequalities, symbols=[])",
        "parameters": {
          "inequalities": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbols": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "[]",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "rsolve": {
        "doc": "Solve univariate recurrence with rational coefficients.\n\nGiven `k`-th order linear recurrence `\\operatorname{L} y = f`,\nor equivalently:\n\n.. math:: a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +\n          \\cdots + a_{0}(n) y(n) = f(n)\n\nwhere `a_{i}(n)`, for `i=0, \\ldots, k`, are polynomials or rational\nfunctions in `n`, and `f` is a hypergeometric function or a sum\nof a fixed number of pairwise dissimilar hypergeometric terms in\n`n`, finds all solutions or returns ``None``, if none were found.\n\nInitial conditions can be given as a dictionary in two forms:\n\n    (1) ``{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}``\n    (2) ``{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}``\n\nor as a list ``L`` of values:\n\n    ``L = [v_0, v_1, ..., v_m]``\n\nwhere ``L[i] = v_i``, for `i=0, \\ldots, m`, maps to `y(n_i)`.\n\nExamples\n========\n\nLets consider the following recurrence:\n\n.. math:: (n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +\n          2 n (n + 1) y(n) = 0\n\n>>> from sympy import Function, rsolve\n>>> from sympy.abc import n\n>>> y = Function('y')\n\n>>> f = (n - 1)*y(n + 2) - (n**2 + 3*n - 2)*y(n + 1) + 2*n*(n + 1)*y(n)\n\n>>> rsolve(f, y(n))\n2**n*C0 + C1*factorial(n)\n\n>>> rsolve(f, y(n), {y(0):0, y(1):3})\n3*2**n - 3*factorial(n)\n\nSee Also\n========\n\nrsolve_poly, rsolve_ratio, rsolve_hyper",
        "signature": "(f, y, init=None)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "y": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "init": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "rsolve_hyper": {
        "doc": "Given linear recurrence operator `\\operatorname{L}` of order `k`\nwith polynomial coefficients and inhomogeneous equation\n`\\operatorname{L} y = f` we seek for all hypergeometric solutions\nover field `K` of characteristic zero.\n\nThe inhomogeneous part can be either hypergeometric or a sum\nof a fixed number of pairwise dissimilar hypergeometric terms.\n\nThe algorithm performs three basic steps:\n\n    (1) Group together similar hypergeometric terms in the\n        inhomogeneous part of `\\operatorname{L} y = f`, and find\n        particular solution using Abramov's algorithm.\n\n    (2) Compute generating set of `\\operatorname{L}` and find basis\n        in it, so that all solutions are linearly independent.\n\n    (3) Form final solution with the number of arbitrary\n        constants equal to dimension of basis of `\\operatorname{L}`.\n\nTerm `a(n)` is hypergeometric if it is annihilated by first order\nlinear difference equations with polynomial coefficients or, in\nsimpler words, if consecutive term ratio is a rational function.\n\nThe output of this procedure is a linear combination of fixed\nnumber of hypergeometric terms. However the underlying method\ncan generate larger class of solutions - D'Alembertian terms.\n\nNote also that this method not only computes the kernel of the\ninhomogeneous equation, but also reduces in to a basis so that\nsolutions generated by this procedure are linearly independent\n\nExamples\n========\n\n>>> from sympy.solvers import rsolve_hyper\n>>> from sympy.abc import x\n\n>>> rsolve_hyper([-1, -1, 1], 0, x)\nC0*(1/2 - sqrt(5)/2)**x + C1*(1/2 + sqrt(5)/2)**x\n\n>>> rsolve_hyper([-1, 1], 1 + x, x)\nC0 + x*(x + 1)/2\n\nReferences\n==========\n\n.. [1] M. Petkovsek, Hypergeometric solutions of linear recurrences\n       with polynomial coefficients, J. Symbolic Computation,\n       14 (1992), 243-264.\n\n.. [2] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.",
        "signature": "(coeffs, f, n, **hints)",
        "parameters": {
          "coeffs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "n": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "hints": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "rsolve_poly": {
        "doc": "Given linear recurrence operator `\\operatorname{L}` of order\n`k` with polynomial coefficients and inhomogeneous equation\n`\\operatorname{L} y = f`, where `f` is a polynomial, we seek for\nall polynomial solutions over field `K` of characteristic zero.\n\nThe algorithm performs two basic steps:\n\n    (1) Compute degree `N` of the general polynomial solution.\n    (2) Find all polynomials of degree `N` or less\n        of `\\operatorname{L} y = f`.\n\nThere are two methods for computing the polynomial solutions.\nIf the degree bound is relatively small, i.e. it's smaller than\nor equal to the order of the recurrence, then naive method of\nundetermined coefficients is being used. This gives a system\nof algebraic equations with `N+1` unknowns.\n\nIn the other case, the algorithm performs transformation of the\ninitial equation to an equivalent one for which the system of\nalgebraic equations has only `r` indeterminates. This method is\nquite sophisticated (in comparison with the naive one) and was\ninvented together by Abramov, Bronstein and Petkovsek.\n\nIt is possible to generalize the algorithm implemented here to\nthe case of linear q-difference and differential equations.\n\nLets say that we would like to compute `m`-th Bernoulli polynomial\nup to a constant. For this we can use `b(n+1) - b(n) = m n^{m-1}`\nrecurrence, which has solution `b(n) = B_m + C`. For example:\n\n>>> from sympy import Symbol, rsolve_poly\n>>> n = Symbol('n', integer=True)\n\n>>> rsolve_poly([-1, 1], 4*n**3, n)\nC0 + n**4 - 2*n**3 + n**2\n\nReferences\n==========\n\n.. [1] S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial\n       solutions of linear operator equations, in: T. Levelt, ed.,\n       Proc. ISSAC '95, ACM Press, New York, 1995, 290-296.\n\n.. [2] M. Petkovsek, Hypergeometric solutions of linear recurrences\n       with polynomial coefficients, J. Symbolic Computation,\n       14 (1992), 243-264.\n\n.. [3] M. Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.",
        "signature": "(coeffs, f, n, shift=0, **hints)",
        "parameters": {
          "coeffs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "n": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "shift": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "0",
            "annotation": null
          },
          "hints": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "rsolve_ratio": {
        "doc": "Given linear recurrence operator `\\operatorname{L}` of order `k`\nwith polynomial coefficients and inhomogeneous equation\n`\\operatorname{L} y = f`, where `f` is a polynomial, we seek\nfor all rational solutions over field `K` of characteristic zero.\n\nThis procedure accepts only polynomials, however if you are\ninterested in solving recurrence with rational coefficients\nthen use ``rsolve`` which will pre-process the given equation\nand run this procedure with polynomial arguments.\n\nThe algorithm performs two basic steps:\n\n    (1) Compute polynomial `v(n)` which can be used as universal\n        denominator of any rational solution of equation\n        `\\operatorname{L} y = f`.\n\n    (2) Construct new linear difference equation by substitution\n        `y(n) = u(n)/v(n)` and solve it for `u(n)` finding all its\n        polynomial solutions. Return ``None`` if none were found.\n\nThe algorithm implemented here is a revised version of the original\nAbramov's algorithm, developed in 1989. The new approach is much\nsimpler to implement and has better overall efficiency. This\nmethod can be easily adapted to the q-difference equations case.\n\nBesides finding rational solutions alone, this functions is\nan important part of Hyper algorithm where it is used to find\na particular solution for the inhomogeneous part of a recurrence.\n\nExamples\n========\n\n>>> from sympy.abc import x\n>>> from sympy.solvers.recurr import rsolve_ratio\n>>> rsolve_ratio([-2*x**3 + x**2 + 2*x - 1, 2*x**3 + x**2 - 6*x,\n... - 2*x**3 - 11*x**2 - 18*x - 9, 2*x**3 + 13*x**2 + 22*x + 8], 0, x)\nC0*(2*x - 3)/(2*(x**2 - 1))\n\nReferences\n==========\n\n.. [1] S. A. Abramov, Rational solutions of linear difference\n       and q-difference equations with polynomial coefficients,\n       in: T. Levelt, ed., Proc. ISSAC '95, ACM Press, New York,\n       1995, 285-289\n\nSee Also\n========\n\nrsolve_hyper",
        "signature": "(coeffs, f, n, **hints)",
        "parameters": {
          "coeffs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "n": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "hints": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve": {
        "doc": "Algebraically solves equations and systems of equations.\n\nExplanation\n===========\n\nCurrently supported:\n    - polynomial\n    - transcendental\n    - piecewise combinations of the above\n    - systems of linear and polynomial equations\n    - systems containing relational expressions\n    - systems implied by undetermined coefficients\n\nExamples\n========\n\nThe default output varies according to the input and might\nbe a list (possibly empty), a dictionary, a list of\ndictionaries or tuples, or an expression involving relationals.\nFor specifics regarding different forms of output that may appear, see :ref:`solve_output`.\nLet it suffice here to say that to obtain a uniform output from\n`solve` use ``dict=True`` or ``set=True`` (see below).\n\n    >>> from sympy import solve, Poly, Eq, Matrix, Symbol\n    >>> from sympy.abc import x, y, z, a, b\n\nThe expressions that are passed can be Expr, Equality, or Poly\nclasses (or lists of the same); a Matrix is considered to be a\nlist of all the elements of the matrix:\n\n    >>> solve(x - 3, x)\n    [3]\n    >>> solve(Eq(x, 3), x)\n    [3]\n    >>> solve(Poly(x - 3), x)\n    [3]\n    >>> solve(Matrix([[x, x + y]]), x, y) == solve([x, x + y], x, y)\n    True\n\nIf no symbols are indicated to be of interest and the equation is\nunivariate, a list of values is returned; otherwise, the keys in\na dictionary will indicate which (of all the variables used in\nthe expression(s)) variables and solutions were found:\n\n    >>> solve(x**2 - 4)\n    [-2, 2]\n    >>> solve((x - a)*(y - b))\n    [{a: x}, {b: y}]\n    >>> solve([x - 3, y - 1])\n    {x: 3, y: 1}\n    >>> solve([x - 3, y**2 - 1])\n    [{x: 3, y: -1}, {x: 3, y: 1}]\n\nIf you pass symbols for which solutions are sought, the output will vary\ndepending on the number of symbols you passed, whether you are passing\na list of expressions or not, and whether a linear system was solved.\nUniform output is attained by using ``dict=True`` or ``set=True``.\n\n    >>> #### *** feel free to skip to the stars below *** ####\n    >>> from sympy import TableForm\n    >>> h = [None, ';|;'.join(['e', 's', 'solve(e, s)', 'solve(e, s, dict=True)',\n    ... 'solve(e, s, set=True)']).split(';')]\n    >>> t = []\n    >>> for e, s in [\n    ...         (x - y, y),\n    ...         (x - y, [x, y]),\n    ...         (x**2 - y, [x, y]),\n    ...         ([x - 3, y -1], [x, y]),\n    ...         ]:\n    ...     how = [{}, dict(dict=True), dict(set=True)]\n    ...     res = [solve(e, s, **f) for f in how]\n    ...     t.append([e, '|', s, '|'] + [res[0], '|', res[1], '|', res[2]])\n    ...\n    >>> # ******************************************************* #\n    >>> TableForm(t, headings=h, alignments=\"<\")\n    e              | s      | solve(e, s)  | solve(e, s, dict=True) | solve(e, s, set=True)\n    ---------------------------------------------------------------------------------------\n    x - y          | y      | [x]          | [{y: x}]               | ([y], {(x,)})\n    x - y          | [x, y] | [(y, y)]     | [{x: y}]               | ([x, y], {(y, y)})\n    x**2 - y       | [x, y] | [(x, x**2)]  | [{y: x**2}]            | ([x, y], {(x, x**2)})\n    [x - 3, y - 1] | [x, y] | {x: 3, y: 1} | [{x: 3, y: 1}]         | ([x, y], {(3, 1)})\n\n    * If any equation does not depend on the symbol(s) given, it will be\n      eliminated from the equation set and an answer may be given\n      implicitly in terms of variables that were not of interest:\n\n        >>> solve([x - y, y - 3], x)\n        {x: y}\n\nWhen you pass all but one of the free symbols, an attempt\nis made to find a single solution based on the method of\nundetermined coefficients. If it succeeds, a dictionary of values\nis returned. If you want an algebraic solutions for one\nor more of the symbols, pass the expression to be solved in a list:\n\n    >>> e = a*x + b - 2*x - 3\n    >>> solve(e, [a, b])\n    {a: 2, b: 3}\n    >>> solve([e], [a, b])\n    {a: -b/x + (2*x + 3)/x}\n\nWhen there is no solution for any given symbol which will make all\nexpressions zero, the empty list is returned (or an empty set in\nthe tuple when ``set=True``):\n\n    >>> from sympy import sqrt\n    >>> solve(3, x)\n    []\n    >>> solve(x - 3, y)\n    []\n    >>> solve(sqrt(x) + 1, x, set=True)\n    ([x], set())\n\nWhen an object other than a Symbol is given as a symbol, it is\nisolated algebraically and an implicit solution may be obtained.\nThis is mostly provided as a convenience to save you from replacing\nthe object with a Symbol and solving for that Symbol. It will only\nwork if the specified object can be replaced with a Symbol using the\nsubs method:\n\n    >>> from sympy import exp, Function\n    >>> f = Function('f')\n\n    >>> solve(f(x) - x, f(x))\n    [x]\n    >>> solve(f(x).diff(x) - f(x) - x, f(x).diff(x))\n    [x + f(x)]\n    >>> solve(f(x).diff(x) - f(x) - x, f(x))\n    [-x + Derivative(f(x), x)]\n    >>> solve(x + exp(x)**2, exp(x), set=True)\n    ([exp(x)], {(-sqrt(-x),), (sqrt(-x),)})\n\n    >>> from sympy import Indexed, IndexedBase, Tuple\n    >>> A = IndexedBase('A')\n    >>> eqs = Tuple(A[1] + A[2] - 3, A[1] - A[2] + 1)\n    >>> solve(eqs, eqs.atoms(Indexed))\n    {A[1]: 1, A[2]: 2}\n\n    * To solve for a function within a derivative, use :func:`~.dsolve`.\n\nTo solve for a symbol implicitly, use implicit=True:\n\n    >>> solve(x + exp(x), x)\n    [-LambertW(1)]\n    >>> solve(x + exp(x), x, implicit=True)\n    [-exp(x)]\n\nIt is possible to solve for anything in an expression that can be\nreplaced with a symbol using :obj:`~sympy.core.basic.Basic.subs`:\n\n    >>> solve(x + 2 + sqrt(3), x + 2)\n    [-sqrt(3)]\n    >>> solve((x + 2 + sqrt(3), x + 4 + y), y, x + 2)\n    {y: -2 + sqrt(3), x + 2: -sqrt(3)}\n\n    * Nothing heroic is done in this implicit solving so you may end up\n      with a symbol still in the solution:\n\n        >>> eqs = (x*y + 3*y + sqrt(3), x + 4 + y)\n        >>> solve(eqs, y, x + 2)\n        {y: -sqrt(3)/(x + 3), x + 2: -2*x/(x + 3) - 6/(x + 3) + sqrt(3)/(x + 3)}\n        >>> solve(eqs, y*x, x)\n        {x: -y - 4, x*y: -3*y - sqrt(3)}\n\n    * If you attempt to solve for a number, remember that the number\n      you have obtained does not necessarily mean that the value is\n      equivalent to the expression obtained:\n\n        >>> solve(sqrt(2) - 1, 1)\n        [sqrt(2)]\n        >>> solve(x - y + 1, 1)  # /!\\ -1 is targeted, too\n        [x/(y - 1)]\n        >>> [_.subs(z, -1) for _ in solve((x - y + 1).subs(-1, z), 1)]\n        [-x + y]\n\n**Additional Examples**\n\n``solve()`` with check=True (default) will run through the symbol tags to\neliminate unwanted solutions. If no assumptions are included, all possible\nsolutions will be returned:\n\n    >>> x = Symbol(\"x\")\n    >>> solve(x**2 - 1)\n    [-1, 1]\n\nBy setting the ``positive`` flag, only one solution will be returned:\n\n    >>> pos = Symbol(\"pos\", positive=True)\n    >>> solve(pos**2 - 1)\n    [1]\n\nWhen the solutions are checked, those that make any denominator zero\nare automatically excluded. If you do not want to exclude such solutions,\nthen use the check=False option:\n\n    >>> from sympy import sin, limit\n    >>> solve(sin(x)/x)  # 0 is excluded\n    [pi]\n\nIf ``check=False``, then a solution to the numerator being zero is found\nbut the value of $x = 0$ is a spurious solution since $\\sin(x)/x$ has the well\nknown limit (without discontinuity) of 1 at $x = 0$:\n\n    >>> solve(sin(x)/x, check=False)\n    [0, pi]\n\nIn the following case, however, the limit exists and is equal to the\nvalue of $x = 0$ that is excluded when check=True:\n\n    >>> eq = x**2*(1/x - z**2/x)\n    >>> solve(eq, x)\n    []\n    >>> solve(eq, x, check=False)\n    [0]\n    >>> limit(eq, x, 0, '-')\n    0\n    >>> limit(eq, x, 0, '+')\n    0\n\n**Solving Relationships**\n\nWhen one or more expressions passed to ``solve`` is a relational,\na relational result is returned (and the ``dict`` and ``set`` flags\nare ignored):\n\n    >>> solve(x < 3)\n    (-oo < x) & (x < 3)\n    >>> solve([x < 3, x**2 > 4], x)\n    ((-oo < x) & (x < -2)) | ((2 < x) & (x < 3))\n    >>> solve([x + y - 3, x > 3], x)\n    (3 < x) & (x < oo) & Eq(x, 3 - y)\n\nAlthough checking of assumptions on symbols in relationals\nis not done, setting assumptions will affect how certain\nrelationals might automatically simplify:\n\n    >>> solve(x**2 > 4)\n    ((-oo < x) & (x < -2)) | ((2 < x) & (x < oo))\n\n    >>> r = Symbol('r', real=True)\n    >>> solve(r**2 > 4)\n    (2 < r) | (r < -2)\n\nThere is currently no algorithm in SymPy that allows you to use\nrelationships to resolve more than one variable. So the following\ndoes not determine that ``q < 0`` (and trying to solve for ``r``\nand ``q`` will raise an error):\n\n    >>> from sympy import symbols\n    >>> r, q = symbols('r, q', real=True)\n    >>> solve([r + q - 3, r > 3], r)\n    (3 < r) & Eq(r, 3 - q)\n\nYou can directly call the routine that ``solve`` calls\nwhen it encounters a relational: :func:`~.reduce_inequalities`.\nIt treats Expr like Equality.\n\n    >>> from sympy import reduce_inequalities\n    >>> reduce_inequalities([x**2 - 4])\n    Eq(x, -2) | Eq(x, 2)\n\nIf each relationship contains only one symbol of interest,\nthe expressions can be processed for multiple symbols:\n\n    >>> reduce_inequalities([0 <= x  - 1, y < 3], [x, y])\n    (-oo < y) & (1 <= x) & (x < oo) & (y < 3)\n\nBut an error is raised if any relationship has more than one\nsymbol of interest:\n\n    >>> reduce_inequalities([0 <= x*y  - 1, y < 3], [x, y])\n    Traceback (most recent call last):\n    ...\n    NotImplementedError:\n    inequality has more than one symbol of interest.\n\n**Disabling High-Order Explicit Solutions**\n\nWhen solving polynomial expressions, you might not want explicit solutions\n(which can be quite long). If the expression is univariate, ``CRootOf``\ninstances will be returned instead:\n\n    >>> solve(x**3 - x + 1)\n    [-1/((-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)) -\n    (-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3,\n    -(-1/2 + sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3 -\n    1/((-1/2 + sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)),\n    -(3*sqrt(69)/2 + 27/2)**(1/3)/3 -\n    1/(3*sqrt(69)/2 + 27/2)**(1/3)]\n    >>> solve(x**3 - x + 1, cubics=False)\n    [CRootOf(x**3 - x + 1, 0),\n     CRootOf(x**3 - x + 1, 1),\n     CRootOf(x**3 - x + 1, 2)]\n\nIf the expression is multivariate, no solution might be returned:\n\n    >>> solve(x**3 - x + a, x, cubics=False)\n    []\n\nSometimes solutions will be obtained even when a flag is False because the\nexpression could be factored. In the following example, the equation can\nbe factored as the product of a linear and a quadratic factor so explicit\nsolutions (which did not require solving a cubic expression) are obtained:\n\n    >>> eq = x**3 + 3*x**2 + x - 1\n    >>> solve(eq, cubics=False)\n    [-1, -1 + sqrt(2), -sqrt(2) - 1]\n\n**Solving Equations Involving Radicals**\n\nBecause of SymPy's use of the principle root, some solutions\nto radical equations will be missed unless check=False:\n\n    >>> from sympy import root\n    >>> eq = root(x**3 - 3*x**2, 3) + 1 - x\n    >>> solve(eq)\n    []\n    >>> solve(eq, check=False)\n    [1/3]\n\nIn the above example, there is only a single solution to the\nequation. Other expressions will yield spurious roots which\nmust be checked manually; roots which give a negative argument\nto odd-powered radicals will also need special checking:\n\n    >>> from sympy import real_root, S\n    >>> eq = root(x, 3) - root(x, 5) + S(1)/7\n    >>> solve(eq)  # this gives 2 solutions but misses a 3rd\n    [CRootOf(7*x**5 - 7*x**3 + 1, 1)**15,\n    CRootOf(7*x**5 - 7*x**3 + 1, 2)**15]\n    >>> sol = solve(eq, check=False)\n    >>> [abs(eq.subs(x,i).n(2)) for i in sol]\n    [0.48, 0.e-110, 0.e-110, 0.052, 0.052]\n\nThe first solution is negative so ``real_root`` must be used to see that it\nsatisfies the expression:\n\n    >>> abs(real_root(eq.subs(x, sol[0])).n(2))\n    0.e-110\n\nIf the roots of the equation are not real then more care will be\nnecessary to find the roots, especially for higher order equations.\nConsider the following expression:\n\n    >>> expr = root(x, 3) - root(x, 5)\n\nWe will construct a known value for this expression at x = 3 by selecting\nthe 1-th root for each radical:\n\n    >>> expr1 = root(x, 3, 1) - root(x, 5, 1)\n    >>> v = expr1.subs(x, -3)\n\nThe ``solve`` function is unable to find any exact roots to this equation:\n\n    >>> eq = Eq(expr, v); eq1 = Eq(expr1, v)\n    >>> solve(eq, check=False), solve(eq1, check=False)\n    ([], [])\n\nThe function ``unrad``, however, can be used to get a form of the equation\nfor which numerical roots can be found:\n\n    >>> from sympy.solvers.solvers import unrad\n    >>> from sympy import nroots\n    >>> e, (p, cov) = unrad(eq)\n    >>> pvals = nroots(e)\n    >>> inversion = solve(cov, x)[0]\n    >>> xvals = [inversion.subs(p, i) for i in pvals]\n\nAlthough ``eq`` or ``eq1`` could have been used to find ``xvals``, the\nsolution can only be verified with ``expr1``:\n\n    >>> z = expr - v\n    >>> [xi.n(chop=1e-9) for xi in xvals if abs(z.subs(x, xi).n()) < 1e-9]\n    []\n    >>> z1 = expr1 - v\n    >>> [xi.n(chop=1e-9) for xi in xvals if abs(z1.subs(x, xi).n()) < 1e-9]\n    [-3.0]\n\nParameters\n==========\n\nf :\n    - a single Expr or Poly that must be zero\n    - an Equality\n    - a Relational expression\n    - a Boolean\n    - iterable of one or more of the above\n\nsymbols : (object(s) to solve for) specified as\n    - none given (other non-numeric objects will be used)\n    - single symbol\n    - denested list of symbols\n      (e.g., ``solve(f, x, y)``)\n    - ordered iterable of symbols\n      (e.g., ``solve(f, [x, y])``)\n\nflags :\n    dict=True (default is False)\n        Return list (perhaps empty) of solution mappings.\n    set=True (default is False)\n        Return list of symbols and set of tuple(s) of solution(s).\n    exclude=[] (default)\n        Do not try to solve for any of the free symbols in exclude;\n        if expressions are given, the free symbols in them will\n        be extracted automatically.\n    check=True (default)\n        If False, do not do any testing of solutions. This can be\n        useful if you want to include solutions that make any\n        denominator zero.\n    numerical=True (default)\n        Do a fast numerical check if *f* has only one symbol.\n    minimal=True (default is False)\n        A very fast, minimal testing.\n    warn=True (default is False)\n        Show a warning if ``checksol()`` could not conclude.\n    simplify=True (default)\n        Simplify all but polynomials of order 3 or greater before\n        returning them and (if check is not False) use the\n        general simplify function on the solutions and the\n        expression obtained when they are substituted into the\n        function which should be zero.\n    force=True (default is False)\n        Make positive all symbols without assumptions regarding sign.\n    rational=True (default)\n        Recast Floats as Rational; if this option is not used, the\n        system containing Floats may fail to solve because of issues\n        with polys. If rational=None, Floats will be recast as\n        rationals but the answer will be recast as Floats. If the\n        flag is False then nothing will be done to the Floats.\n    manual=True (default is False)\n        Do not use the polys/matrix method to solve a system of\n        equations, solve them one at a time as you might \"manually.\"\n    implicit=True (default is False)\n        Allows ``solve`` to return a solution for a pattern in terms of\n        other functions that contain that pattern; this is only\n        needed if the pattern is inside of some invertible function\n        like cos, exp, etc.\n    particular=True (default is False)\n        Instructs ``solve`` to try to find a particular solution to\n        a linear system with as many zeros as possible; this is very\n        expensive.\n    quick=True (default is False; ``particular`` must be True)\n        Selects a fast heuristic to find a solution with many zeros\n        whereas a value of False uses the very slow method guaranteed\n        to find the largest number of zeros possible.\n    cubics=True (default)\n        Return explicit solutions when cubic expressions are encountered.\n        When False, quartics and quintics are disabled, too.\n    quartics=True (default)\n        Return explicit solutions when quartic expressions are encountered.\n        When False, quintics are disabled, too.\n    quintics=True (default)\n        Return explicit solutions (if possible) when quintic expressions\n        are encountered.\n\nSee Also\n========\n\nrsolve: For solving recurrence relationships\nsympy.solvers.ode.dsolve: For solving differential equations",
        "signature": "(f, *symbols, **flags)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbols": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          },
          "flags": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve_linear": {
        "doc": "Return a tuple derived from ``f = lhs - rhs`` that is one of\nthe following: ``(0, 1)``, ``(0, 0)``, ``(symbol, solution)``, ``(n, d)``.\n\nExplanation\n===========\n\n``(0, 1)`` meaning that ``f`` is independent of the symbols in *symbols*\nthat are not in *exclude*.\n\n``(0, 0)`` meaning that there is no solution to the equation amongst the\nsymbols given. If the first element of the tuple is not zero, then the\nfunction is guaranteed to be dependent on a symbol in *symbols*.\n\n``(symbol, solution)`` where symbol appears linearly in the numerator of\n``f``, is in *symbols* (if given), and is not in *exclude* (if given). No\nsimplification is done to ``f`` other than a ``mul=True`` expansion, so the\nsolution will correspond strictly to a unique solution.\n\n``(n, d)`` where ``n`` and ``d`` are the numerator and denominator of ``f``\nwhen the numerator was not linear in any symbol of interest; ``n`` will\nnever be a symbol unless a solution for that symbol was found (in which case\nthe second element is the solution, not the denominator).\n\nExamples\n========\n\n>>> from sympy import cancel, Pow\n\n``f`` is independent of the symbols in *symbols* that are not in\n*exclude*:\n\n>>> from sympy import cos, sin, solve_linear\n>>> from sympy.abc import x, y, z\n>>> eq = y*cos(x)**2 + y*sin(x)**2 - y  # = y*(1 - 1) = 0\n>>> solve_linear(eq)\n(0, 1)\n>>> eq = cos(x)**2 + sin(x)**2  # = 1\n>>> solve_linear(eq)\n(0, 1)\n>>> solve_linear(x, exclude=[x])\n(0, 1)\n\nThe variable ``x`` appears as a linear variable in each of the\nfollowing:\n\n>>> solve_linear(x + y**2)\n(x, -y**2)\n>>> solve_linear(1/x - y**2)\n(x, y**(-2))\n\nWhen not linear in ``x`` or ``y`` then the numerator and denominator are\nreturned:\n\n>>> solve_linear(x**2/y**2 - 3)\n(x**2 - 3*y**2, y**2)\n\nIf the numerator of the expression is a symbol, then ``(0, 0)`` is\nreturned if the solution for that symbol would have set any\ndenominator to 0:\n\n>>> eq = 1/(1/x - 2)\n>>> eq.as_numer_denom()\n(x, 1 - 2*x)\n>>> solve_linear(eq)\n(0, 0)\n\nBut automatic rewriting may cause a symbol in the denominator to\nappear in the numerator so a solution will be returned:\n\n>>> (1/x)**-1\nx\n>>> solve_linear((1/x)**-1)\n(x, 0)\n\nUse an unevaluated expression to avoid this:\n\n>>> solve_linear(Pow(1/x, -1, evaluate=False))\n(0, 0)\n\nIf ``x`` is allowed to cancel in the following expression, then it\nappears to be linear in ``x``, but this sort of cancellation is not\ndone by ``solve_linear`` so the solution will always satisfy the\noriginal expression without causing a division by zero error.\n\n>>> eq = x**2*(1/x - z**2/x)\n>>> solve_linear(cancel(eq))\n(x, 0)\n>>> solve_linear(eq)\n(x**2*(1 - z**2), x)\n\nA list of symbols for which a solution is desired may be given:\n\n>>> solve_linear(x + y + z, symbols=[y])\n(y, -x - z)\n\nA list of symbols to ignore may also be given:\n\n>>> solve_linear(x + y + z, exclude=[x])\n(y, -x - z)\n\n(A solution for ``y`` is obtained because it is the first variable\nfrom the canonically sorted list of symbols that had a linear\nsolution.)",
        "signature": "(lhs, rhs=0, symbols=[], exclude=[])",
        "parameters": {
          "lhs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "rhs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "0",
            "annotation": null
          },
          "symbols": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "[]",
            "annotation": null
          },
          "exclude": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "[]",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve_linear_system": {
        "doc": "Solve system of $N$ linear equations with $M$ variables, which means\nboth under- and overdetermined systems are supported.\n\nExplanation\n===========\n\nThe possible number of solutions is zero, one, or infinite. Respectively,\nthis procedure will return None or a dictionary with solutions. In the\ncase of underdetermined systems, all arbitrary parameters are skipped.\nThis may cause a situation in which an empty dictionary is returned.\nIn that case, all symbols can be assigned arbitrary values.\n\nInput to this function is a $N\\times M + 1$ matrix, which means it has\nto be in augmented form. If you prefer to enter $N$ equations and $M$\nunknowns then use ``solve(Neqs, *Msymbols)`` instead. Note: a local\ncopy of the matrix is made by this routine so the matrix that is\npassed will not be modified.\n\nThe algorithm used here is fraction-free Gaussian elimination,\nwhich results, after elimination, in an upper-triangular matrix.\nThen solutions are found using back-substitution. This approach\nis more efficient and compact than the Gauss-Jordan method.\n\nExamples\n========\n\n>>> from sympy import Matrix, solve_linear_system\n>>> from sympy.abc import x, y\n\nSolve the following system::\n\n       x + 4 y ==  2\n    -2 x +   y == 14\n\n>>> system = Matrix(( (1, 4, 2), (-2, 1, 14)))\n>>> solve_linear_system(system, x, y)\n{x: -6, y: 2}\n\nA degenerate system returns an empty dictionary:\n\n>>> system = Matrix(( (0,0,0), (0,0,0) ))\n>>> solve_linear_system(system, x, y)\n{}",
        "signature": "(system, *symbols, **flags)",
        "parameters": {
          "system": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbols": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          },
          "flags": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve_linear_system_LU": {
        "doc": "Solves the augmented matrix system using ``LUsolve`` and returns a\ndictionary in which solutions are keyed to the symbols of *syms* as ordered.\n\nExplanation\n===========\n\nThe matrix must be invertible.\n\nExamples\n========\n\n>>> from sympy import Matrix, solve_linear_system_LU\n>>> from sympy.abc import x, y, z\n\n>>> solve_linear_system_LU(Matrix([\n... [1, 2, 0, 1],\n... [3, 2, 2, 1],\n... [2, 0, 0, 1]]), [x, y, z])\n{x: 1/2, y: 1/4, z: -1/2}\n\nSee Also\n========\n\nLUsolve",
        "signature": "(matrix, syms)",
        "parameters": {
          "matrix": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "syms": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve_poly_inequality": {
        "doc": "Solve a polynomial inequality with rational coefficients.\n\nExamples\n========\n\n>>> from sympy import solve_poly_inequality, Poly\n>>> from sympy.abc import x\n\n>>> solve_poly_inequality(Poly(x, x, domain='ZZ'), '==')\n[{0}]\n\n>>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '!=')\n[Interval.open(-oo, -1), Interval.open(-1, 1), Interval.open(1, oo)]\n\n>>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '==')\n[{-1}, {1}]\n\nSee Also\n========\nsolve_poly_inequalities",
        "signature": "(poly, rel)",
        "parameters": {
          "poly": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "rel": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve_poly_system": {
        "doc": "Return a list of solutions for the system of polynomial equations\nor else None.\n\nParameters\n==========\n\nseq: a list/tuple/set\n    Listing all the equations that are needed to be solved\ngens: generators\n    generators of the equations in seq for which we want the\n    solutions\nstrict: a boolean (default is False)\n    if strict is True, NotImplementedError will be raised if\n    the solution is known to be incomplete (which can occur if\n    not all solutions are expressible in radicals)\nargs: Keyword arguments\n    Special options for solving the equations.\n\n\nReturns\n=======\n\nList[Tuple]\n    a list of tuples with elements being solutions for the\n    symbols in the order they were passed as gens\nNone\n    None is returned when the computed basis contains only the ground.\n\nExamples\n========\n\n>>> from sympy import solve_poly_system\n>>> from sympy.abc import x, y\n\n>>> solve_poly_system([x*y - 2*y, 2*y**2 - x**2], x, y)\n[(0, 0), (2, -sqrt(2)), (2, sqrt(2))]\n\n>>> solve_poly_system([x**5 - x + y**3, y**2 - 1], x, y, strict=True)\nTraceback (most recent call last):\n...\nUnsolvableFactorError",
        "signature": "(seq, *gens, strict=False, **args)",
        "parameters": {
          "seq": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "gens": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          },
          "strict": {
            "kind": "KEYWORD_ONLY",
            "default": "False",
            "annotation": null
          },
          "args": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve_rational_inequalities": {
        "doc": "Solve a system of rational inequalities with rational coefficients.\n\nExamples\n========\n\n>>> from sympy.abc import x\n>>> from sympy import solve_rational_inequalities, Poly\n\n>>> solve_rational_inequalities([[\n... ((Poly(-x + 1), Poly(1, x)), '>='),\n... ((Poly(-x + 1), Poly(1, x)), '<=')]])\n{1}\n\n>>> solve_rational_inequalities([[\n... ((Poly(x), Poly(1, x)), '!='),\n... ((Poly(-x + 1), Poly(1, x)), '>=')]])\nUnion(Interval.open(-oo, 0), Interval.Lopen(0, 1))\n\nSee Also\n========\nsolve_poly_inequality",
        "signature": "(eqs)",
        "parameters": {
          "eqs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve_triangulated": {
        "doc": "Solve a polynomial system using Gianni-Kalkbrenner algorithm.\n\nThe algorithm proceeds by computing one Groebner basis in the ground\ndomain and then by iteratively computing polynomial factorizations in\nappropriately constructed algebraic extensions of the ground domain.\n\nParameters\n==========\n\npolys: a list/tuple/set\n    Listing all the equations that are needed to be solved\ngens: generators\n    generators of the equations in polys for which we want the\n    solutions\nargs: Keyword arguments\n    Special options for solving the equations\n\nReturns\n=======\n\nList[Tuple]\n    A List of tuples. Solutions for symbols that satisfy the\n    equations listed in polys\n\nExamples\n========\n\n>>> from sympy import solve_triangulated\n>>> from sympy.abc import x, y, z\n\n>>> F = [x**2 + y + z - 1, x + y**2 + z - 1, x + y + z**2 - 1]\n\n>>> solve_triangulated(F, x, y, z)\n[(0, 0, 1), (0, 1, 0), (1, 0, 0)]\n\nUsing extension for algebraic solutions.\n\n>>> solve_triangulated(F, x, y, z, extension=True) #doctest: +NORMALIZE_WHITESPACE\n[(0, 0, 1), (0, 1, 0), (1, 0, 0),\n (CRootOf(x**2 + 2*x - 1, 0), CRootOf(x**2 + 2*x - 1, 0), CRootOf(x**2 + 2*x - 1, 0)),\n (CRootOf(x**2 + 2*x - 1, 1), CRootOf(x**2 + 2*x - 1, 1), CRootOf(x**2 + 2*x - 1, 1))]\n\nReferences\n==========\n\n1. Patrizia Gianni, Teo Mora, Algebraic Solution of System of\nPolynomial Equations using Groebner Bases, AAECC-5 on Applied Algebra,\nAlgebraic Algorithms and Error-Correcting Codes, LNCS 356 247--257, 1989",
        "signature": "(polys, *gens, **args)",
        "parameters": {
          "polys": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "gens": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          },
          "args": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve_undetermined_coeffs": {
        "doc": "Solve a system of equations in $k$ parameters that is formed by\nmatching coefficients in variables ``coeffs`` that are on\nfactors dependent on the remaining variables (or those given\nexplicitly by ``syms``.\n\nExplanation\n===========\n\nThe result of this function is a dictionary with symbolic values of those\nparameters with respect to coefficients in $q$ -- empty if there\nis no solution or coefficients do not appear in the equation -- else\nNone (if the system was not recognized). If there is more than one\nsolution, the solutions are passed as a list. The output can be modified using\nthe same semantics as for `solve` since the flags that are passed are sent\ndirectly to `solve` so, for example the flag ``dict=True`` will always return a list\nof solutions as dictionaries.\n\nThis function accepts both Equality and Expr class instances.\nThe solving process is most efficient when symbols are specified\nin addition to parameters to be determined,  but an attempt to\ndetermine them (if absent) will be made. If an expected solution is not\nobtained (and symbols were not specified) try specifying them.\n\nExamples\n========\n\n>>> from sympy import Eq, solve_undetermined_coeffs\n>>> from sympy.abc import a, b, c, h, p, k, x, y\n\n>>> solve_undetermined_coeffs(Eq(a*x + a + b, x/2), [a, b], x)\n{a: 1/2, b: -1/2}\n>>> solve_undetermined_coeffs(a - 2, [a])\n{a: 2}\n\nThe equation can be nonlinear in the symbols:\n\n>>> X, Y, Z = y, x**y, y*x**y\n>>> eq = a*X + b*Y + c*Z - X - 2*Y - 3*Z\n>>> coeffs = a, b, c\n>>> syms = x, y\n>>> solve_undetermined_coeffs(eq, coeffs, syms)\n{a: 1, b: 2, c: 3}\n\nAnd the system can be nonlinear in coefficients, too, but if\nthere is only a single solution, it will be returned as a\ndictionary:\n\n>>> eq = a*x**2 + b*x + c - ((x - h)**2 + 4*p*k)/4/p\n>>> solve_undetermined_coeffs(eq, (h, p, k), x)\n{h: -b/(2*a), k: (4*a*c - b**2)/(4*a), p: 1/(4*a)}\n\nMultiple solutions are always returned in a list:\n\n>>> solve_undetermined_coeffs(a**2*x + b - x, [a, b], x)\n[{a: -1, b: 0}, {a: 1, b: 0}]\n\nUsing flag ``dict=True`` (in keeping with semantics in :func:`~.solve`)\nwill force the result to always be a list with any solutions\nas elements in that list.\n\n>>> solve_undetermined_coeffs(a*x - 2*x, [a], dict=True)\n[{a: 2}]",
        "signature": "(equ, coeffs, *syms, **flags)",
        "parameters": {
          "equ": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "coeffs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "syms": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          },
          "flags": {
            "kind": "VAR_KEYWORD",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solve_univariate_inequality": {
        "doc": "Solves a real univariate inequality.\n\nParameters\n==========\n\nexpr : Relational\n    The target inequality\ngen : Symbol\n    The variable for which the inequality is solved\nrelational : bool\n    A Relational type output is expected or not\ndomain : Set\n    The domain over which the equation is solved\ncontinuous: bool\n    True if expr is known to be continuous over the given domain\n    (and so continuous_domain() does not need to be called on it)\n\nRaises\n======\n\nNotImplementedError\n    The solution of the inequality cannot be determined due to limitation\n    in :func:`sympy.solvers.solveset.solvify`.\n\nNotes\n=====\n\nCurrently, we cannot solve all the inequalities due to limitations in\n:func:`sympy.solvers.solveset.solvify`. Also, the solution returned for trigonometric inequalities\nare restricted in its periodic interval.\n\nSee Also\n========\n\nsympy.solvers.solveset.solvify: solver returning solveset solutions with solve's output API\n\nExamples\n========\n\n>>> from sympy import solve_univariate_inequality, Symbol, sin, Interval, S\n>>> x = Symbol('x')\n\n>>> solve_univariate_inequality(x**2 >= 4, x)\n((2 <= x) & (x < oo)) | ((-oo < x) & (x <= -2))\n\n>>> solve_univariate_inequality(x**2 >= 4, x, relational=False)\nUnion(Interval(-oo, -2), Interval(2, oo))\n\n>>> domain = Interval(0, S.Infinity)\n>>> solve_univariate_inequality(x**2 >= 4, x, False, domain)\nInterval(2, oo)\n\n>>> solve_univariate_inequality(sin(x) > 0, x, relational=False)\nInterval.open(0, pi)",
        "signature": "(expr, gen, relational=True, domain=Reals, continuous=False)",
        "parameters": {
          "expr": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "gen": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "relational": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "True",
            "annotation": null
          },
          "domain": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Reals",
            "annotation": null
          },
          "continuous": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "False",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "solveset": {
        "doc": "Solves a given inequality or equation with set as output\n\nParameters\n==========\n\nf : Expr or a relational.\n    The target equation or inequality\nsymbol : Symbol\n    The variable for which the equation is solved\ndomain : Set\n    The domain over which the equation is solved\n\nReturns\n=======\n\nSet\n    A set of values for `symbol` for which `f` is True or is equal to\n    zero. An :class:`~.EmptySet` is returned if `f` is False or nonzero.\n    A :class:`~.ConditionSet` is returned as unsolved object if algorithms\n    to evaluate complete solution are not yet implemented.\n\n``solveset`` claims to be complete in the solution set that it returns.\n\nRaises\n======\n\nNotImplementedError\n    The algorithms to solve inequalities in complex domain  are\n    not yet implemented.\nValueError\n    The input is not valid.\nRuntimeError\n    It is a bug, please report to the github issue tracker.\n\n\nNotes\n=====\n\nPython interprets 0 and 1 as False and True, respectively, but\nin this function they refer to solutions of an expression. So 0 and 1\nreturn the domain and EmptySet, respectively, while True and False\nreturn the opposite (as they are assumed to be solutions of relational\nexpressions).\n\n\nSee Also\n========\n\nsolveset_real: solver for real domain\nsolveset_complex: solver for complex domain\n\nExamples\n========\n\n>>> from sympy import exp, sin, Symbol, pprint, S, Eq\n>>> from sympy.solvers.solveset import solveset, solveset_real\n\n* The default domain is complex. Not specifying a domain will lead\n  to the solving of the equation in the complex domain (and this\n  is not affected by the assumptions on the symbol):\n\n>>> x = Symbol('x')\n>>> pprint(solveset(exp(x) - 1, x), use_unicode=False)\n{2*n*I*pi | n in Integers}\n\n>>> x = Symbol('x', real=True)\n>>> pprint(solveset(exp(x) - 1, x), use_unicode=False)\n{2*n*I*pi | n in Integers}\n\n* If you want to use ``solveset`` to solve the equation in the\n  real domain, provide a real domain. (Using ``solveset_real``\n  does this automatically.)\n\n>>> R = S.Reals\n>>> x = Symbol('x')\n>>> solveset(exp(x) - 1, x, R)\n{0}\n>>> solveset_real(exp(x) - 1, x)\n{0}\n\nThe solution is unaffected by assumptions on the symbol:\n\n>>> p = Symbol('p', positive=True)\n>>> pprint(solveset(p**2 - 4))\n{-2, 2}\n\nWhen a :class:`~.ConditionSet` is returned, symbols with assumptions that\nwould alter the set are replaced with more generic symbols:\n\n>>> i = Symbol('i', imaginary=True)\n>>> solveset(Eq(i**2 + i*sin(i), 1), i, domain=S.Reals)\nConditionSet(_R, Eq(_R**2 + _R*sin(_R) - 1, 0), Reals)\n\n* Inequalities can be solved over the real domain only. Use of a complex\n  domain leads to a NotImplementedError.\n\n>>> solveset(exp(x) > 1, x, R)\nInterval.open(0, oo)",
        "signature": "(f, symbol=None, domain=Complexes)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          },
          "domain": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Complexes",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "substitution": {
        "doc": "Solves the `system` using substitution method. It is used in\n:func:`~.nonlinsolve`. This will be called from :func:`~.nonlinsolve` when any\nequation(s) is non polynomial equation.\n\nParameters\n==========\n\nsystem : list of equations\n    The target system of equations\nsymbols : list of symbols to be solved.\n    The variable(s) for which the system is solved\nknown_symbols : list of solved symbols\n    Values are known for these variable(s)\nresult : An empty list or list of dict\n    If No symbol values is known then empty list otherwise\n    symbol as keys and corresponding value in dict.\nexclude : Set of expression.\n    Mostly denominator expression(s) of the equations of the system.\n    Final solution should not satisfy these expressions.\nall_symbols : known_symbols + symbols(unsolved).\n\nReturns\n=======\n\nA FiniteSet of ordered tuple of values of `all_symbols` for which the\n`system` has solution. Order of values in the tuple is same as symbols\npresent in the parameter `all_symbols`. If parameter `all_symbols` is None\nthen same as symbols present in the parameter `symbols`.\n\nPlease note that general FiniteSet is unordered, the solution returned\nhere is not simply a FiniteSet of solutions, rather it is a FiniteSet of\nordered tuple, i.e. the first & only argument to FiniteSet is a tuple of\nsolutions, which is ordered, & hence the returned solution is ordered.\n\nAlso note that solution could also have been returned as an ordered tuple,\nFiniteSet is just a wrapper `{}` around the tuple. It has no other\nsignificance except for the fact it is just used to maintain a consistent\noutput format throughout the solveset.\n\nRaises\n======\n\nValueError\n    The input is not valid.\n    The symbols are not given.\nAttributeError\n    The input symbols are not :class:`~.Symbol` type.\n\nExamples\n========\n\n>>> from sympy import symbols, substitution\n>>> x, y = symbols('x, y', real=True)\n>>> substitution([x + y], [x], [{y: 1}], [y], set([]), [x, y])\n{(-1, 1)}\n\n* When you want a soln not satisfying $x + 1 = 0$\n\n>>> substitution([x + y], [x], [{y: 1}], [y], set([x + 1]), [y, x])\nEmptySet\n>>> substitution([x + y], [x], [{y: 1}], [y], set([x - 1]), [y, x])\n{(1, -1)}\n>>> substitution([x + y - 1, y - x**2 + 5], [x, y])\n{(-3, 4), (2, -1)}\n\n* Returns both real and complex solution\n\n>>> x, y, z = symbols('x, y, z')\n>>> from sympy import exp, sin\n>>> substitution([exp(x) - sin(y), y**2 - 4], [x, y])\n{(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),\n (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}\n\n>>> eqs = [z**2 + exp(2*x) - sin(y), -3 + exp(-y)]\n>>> substitution(eqs, [y, z])\n{(-log(3), -sqrt(-exp(2*x) - sin(log(3)))),\n (-log(3), sqrt(-exp(2*x) - sin(log(3)))),\n (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),\n  ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),\n (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),\n  ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers))}",
        "signature": "(system, symbols, result=[{}], known_symbols=[], exclude=[], all_symbols=None)",
        "parameters": {
          "system": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbols": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "result": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "[{}]",
            "annotation": null
          },
          "known_symbols": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "[]",
            "annotation": null
          },
          "exclude": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "[]",
            "annotation": null
          },
          "all_symbols": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      }
    },
    "constants": {}
  },
  "sympy.calculus": {
    "classes": {
      "AccumBounds": {
        "full_name": "sympy.calculus.AccumBounds",
        "bases": [
          "Expr"
        ],
        "doc": "An accumulation bounds.\n\n# Note AccumulationBounds has an alias: AccumBounds\n\nAccumulationBounds represent an interval `[a, b]`, which is always closed\nat the ends. Here `a` and `b` can be any value from extended real numbers.\n\nThe intended meaning of AccummulationBounds is to give an approximate\nlocation of the accumulation points of a real function at a limit point.\n\nLet `a` and `b` be reals such that `a \\le b`.\n\n`\\left\\langle a, b\\right\\rangle = \\{x \\in \\mathbb{R} \\mid a \\le x \\le b\\}`\n\n`\\left\\langle -\\infty, b\\right\\rangle = \\{x \\in \\mathbb{R} \\mid x \\le b\\} \\cup \\{-\\infty, \\infty\\}`\n\n`\\left\\langle a, \\infty \\right\\rangle = \\{x \\in \\mathbb{R} \\mid a \\le x\\} \\cup \\{-\\infty, \\infty\\}`\n\n`\\left\\langle -\\infty, \\infty \\right\\rangle = \\mathbb{R} \\cup \\{-\\infty, \\infty\\}`\n\n``oo`` and ``-oo`` are added to the second and third definition respectively,\nsince if either ``-oo`` or ``oo`` is an argument, then the other one should\nbe included (though not as an end point). This is forced, since we have,\nfor example, ``1/AccumBounds(0, 1) = AccumBounds(1, oo)``, and the limit at\n`0` is not one-sided. As `x` tends to `0-`, then `1/x \\rightarrow -\\infty`, so `-\\infty`\nshould be interpreted as belonging to ``AccumBounds(1, oo)`` though it need\nnot appear explicitly.\n\nIn many cases it suffices to know that the limit set is bounded.\nHowever, in some other cases more exact information could be useful.\nFor example, all accumulation values of `\\cos(x) + 1` are non-negative.\n(``AccumBounds(-1, 1) + 1 = AccumBounds(0, 2)``)\n\nA AccumulationBounds object is defined to be real AccumulationBounds,\nif its end points are finite reals.\n\nLet `X`, `Y` be real AccumulationBounds, then their sum, difference,\nproduct are defined to be the following sets:\n\n`X + Y = \\{ x+y \\mid x \\in X \\cap y \\in Y\\}`\n\n`X - Y = \\{ x-y \\mid x \\in X \\cap y \\in Y\\}`\n\n`X \\times Y = \\{ x \\times y \\mid x \\in X \\cap y \\in Y\\}`\n\nWhen an AccumBounds is raised to a negative power, if 0 is contained\nbetween the bounds then an infinite range is returned, otherwise if an\nendpoint is 0 then a semi-infinite range with consistent sign will be returned.\n\nAccumBounds in expressions behave a lot like Intervals but the\nsemantics are not necessarily the same. Division (or exponentiation\nto a negative integer power) could be handled with *intervals* by\nreturning a union of the results obtained after splitting the\nbounds between negatives and positives, but that is not done with\nAccumBounds. In addition, bounds are assumed to be independent of\neach other; if the same bound is used in more than one place in an\nexpression, the result may not be the supremum or infimum of the\nexpression (see below). Finally, when a boundary is ``1``,\nexponentiation to the power of ``oo`` yields ``oo``, neither\n``1`` nor ``nan``.\n\nExamples\n========\n\n>>> from sympy import AccumBounds, sin, exp, log, pi, E, S, oo\n>>> from sympy.abc import x\n\n>>> AccumBounds(0, 1) + AccumBounds(1, 2)\nAccumBounds(1, 3)\n\n>>> AccumBounds(0, 1) - AccumBounds(0, 2)\nAccumBounds(-2, 1)\n\n>>> AccumBounds(-2, 3)*AccumBounds(-1, 1)\nAccumBounds(-3, 3)\n\n>>> AccumBounds(1, 2)*AccumBounds(3, 5)\nAccumBounds(3, 10)\n\nThe exponentiation of AccumulationBounds is defined\nas follows:\n\nIf 0 does not belong to `X` or `n > 0` then\n\n`X^n = \\{ x^n \\mid x \\in X\\}`\n\n>>> AccumBounds(1, 4)**(S(1)/2)\nAccumBounds(1, 2)\n\notherwise, an infinite or semi-infinite result is obtained:\n\n>>> 1/AccumBounds(-1, 1)\nAccumBounds(-oo, oo)\n>>> 1/AccumBounds(0, 2)\nAccumBounds(1/2, oo)\n>>> 1/AccumBounds(-oo, 0)\nAccumBounds(-oo, 0)\n\nA boundary of 1 will always generate all nonnegatives:\n\n>>> AccumBounds(1, 2)**oo\nAccumBounds(0, oo)\n>>> AccumBounds(0, 1)**oo\nAccumBounds(0, oo)\n\nIf the exponent is itself an AccumulationBounds or is not an\ninteger then unevaluated results will be returned unless the base\nvalues are positive:\n\n>>> AccumBounds(2, 3)**AccumBounds(-1, 2)\nAccumBounds(1/3, 9)\n>>> AccumBounds(-2, 3)**AccumBounds(-1, 2)\nAccumBounds(-2, 3)**AccumBounds(-1, 2)\n\n>>> AccumBounds(-2, -1)**(S(1)/2)\nsqrt(AccumBounds(-2, -1))\n\nNote: `\\left\\langle a, b\\right\\rangle^2` is not same as `\\left\\langle a, b\\right\\rangle \\times \\left\\langle a, b\\right\\rangle`\n\n>>> AccumBounds(-1, 1)**2\nAccumBounds(0, 1)\n\n>>> AccumBounds(1, 3) < 4\nTrue\n\n>>> AccumBounds(1, 3) < -1\nFalse\n\nSome elementary functions can also take AccumulationBounds as input.\nA function `f` evaluated for some real AccumulationBounds `\\left\\langle a, b \\right\\rangle`\nis defined as `f(\\left\\langle a, b\\right\\rangle) = \\{ f(x) \\mid a \\le x \\le b \\}`\n\n>>> sin(AccumBounds(pi/6, pi/3))\nAccumBounds(1/2, sqrt(3)/2)\n\n>>> exp(AccumBounds(0, 1))\nAccumBounds(1, E)\n\n>>> log(AccumBounds(1, E))\nAccumBounds(0, 1)\n\nSome symbol in an expression can be substituted for a AccumulationBounds\nobject. But it does not necessarily evaluate the AccumulationBounds for\nthat expression.\n\nThe same expression can be evaluated to different values depending upon\nthe form it is used for substitution since each instance of an\nAccumulationBounds is considered independent. For example:\n\n>>> (x**2 + 2*x + 1).subs(x, AccumBounds(-1, 1))\nAccumBounds(-1, 4)\n\n>>> ((x + 1)**2).subs(x, AccumBounds(-1, 1))\nAccumBounds(0, 4)\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Interval_arithmetic\n\n.. [2] https://fab.cba.mit.edu/classes/S62.12/docs/Hickey_interval.pdf\n\nNotes\n=====\n\nDo not use ``AccumulationBounds`` for floating point interval arithmetic\ncalculations, use ``mpmath.iv`` instead.",
        "methods": {
          "adjoint": {
            "doc": "",
            "signature": "(self)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "apart": {
            "doc": "See the apart function in sympy.polys",
            "signature": "(self, x=None, **args)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "None",
                "annotation": null
              },
              "args": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "args_cnc": {
            "doc": "Return [commutative factors, non-commutative factors] of self.\n\nExplanation\n===========\n\nself is treated as a Mul and the ordering of the factors is maintained.\nIf ``cset`` is True the commutative factors will be returned in a set.\nIf there were repeated factors (as may happen with an unevaluated Mul)\nthen an error will be raised unless it is explicitly suppressed by\nsetting ``warn`` to False.\n\nNote: -1 is always separated from a Number unless split_1 is False.\n\nExamples\n========\n\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []]\n\nThe arg is always treated as a Mul:\n\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []]",
            "signature": "(self, cset=False, warn=True, split_1=True)",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "cset": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              },
              "warn": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              },
              "split_1": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "True",
                "annotation": null
              }
            },
            "return_annotation": null
          },
          "as_base_exp": {
            "doc": "",
            "signature": "(self) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_Add": {
            "doc": "Efficiently extract the coefficient of a summation.",
            "signature": "(self, rational=False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": null
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_Mul": {
            "doc": "Efficiently extract the coefficient of a product.",
            "signature": "(self, rational: 'bool' = False) -> \"tuple['Number', Expr]\"",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "rational": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": "False",
                "annotation": "bool"
              }
            },
            "return_annotation": "tuple['Number', Expr]"
          },
          "as_coeff_add": {
            "doc": "Return the tuple (c, args) where self is written as an Add, ``a``.\n\nc should be a Rational added to any terms of the Add that are\nindependent of deps.\n\nargs should be a tuple of all other terms of ``a``; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is an Add or not but\nyou want to treat self as an Add or if you want to process the\nindividual arguments of the tail of self as an Add.\n\n- if you know self is an Add and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail.\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ())",
            "signature": "(self, *deps) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coeff_exponent": {
            "doc": "``c*x**e -> c,e`` where x can be any symbolic expression.\n        ",
            "signature": "(self, x) -> 'tuple[Expr, Expr]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "x": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, Expr]"
          },
          "as_coeff_mul": {
            "doc": "Return the tuple (c, args) where self is written as a Mul, ``m``.\n\nc should be a Rational multiplied by any factors of the Mul that are\nindependent of deps.\n\nargs should be a tuple of all other factors of m; args is empty\nif self is a Number or if self is independent of deps (when given).\n\nThis should be used when you do not know if self is a Mul or not but\nyou want to treat self as a Mul or if you want to process the\nindividual arguments of the tail of self as a Mul.\n\n- if you know self is a Mul and want only the head, use self.args[0];\n- if you do not want to process the arguments of the tail but need the\n  tail then use self.as_two_terms() which gives the head and tail;\n- if you want to split self into an independent and dependent parts\n  use ``self.as_independent(*deps)``\n\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ())",
            "signature": "(self, *deps, **kwargs) -> 'tuple[Expr, tuple[Expr, ...]]'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "deps": {
                "kind": "VAR_POSITIONAL",
                "default": null,
                "annotation": null
              },
              "kwargs": {
                "kind": "VAR_KEYWORD",
                "default": null,
                "annotation": null
              }
            },
            "return_annotation": "tuple[Expr, tuple[Expr, ...]]"
          },
          "as_coefficient": {
            "doc": "Extracts symbolic coefficient at the given expression. In\nother words, this functions separates 'self' into the product\nof 'expr' and 'expr'-free coefficient. If such separation\nis not possible it will return None.\n\nExamples\n========\n\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x\n\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E)\n\nTwo terms have E in them so a sum is returned. (If one were\ndesiring the coefficient of the term exactly matching E then\nthe constant from the returned expression could be selected.\nOr, for greater precision, a method of Poly can be used to\nindicate the desired term from which the coefficient is\ndesired.)\n\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2\n\nSince the following cannot be written as a product containing\nE as a factor, None is returned. (If the coefficient ``2*x`` is\ndesired then the ``coeff`` method should be used.)\n\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x\n\n>>> (E*(x + 1) + x).as_coefficient(E)\n\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I)\n\nSee Also\n========\n\ncoeff: return sum of terms have a given factor\nas_coeff_Add: separate the additive constant from an expression\nas_coeff_Mul: separate the multiplicative constant from an expression\nas_independent: separate x-dependent terms/factors from others\nsympy.polys.polytools.Poly.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\nsympy.polys.polytools.Poly.nth: like coeff_monomial but powers of monomial terms are used",
            "signature": "(self, expr: 'Expr') -> 'Expr | None'",
            "parameters": {
              "self": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": null
              },
              "expr": {
                "kind": "POSITIONAL_OR_KEYWORD",
                "default": null,
                "annotation": "Expr"
              }
            },
            "return_annotation": "Expr | None"
          }
        },
        "properties": {}
      }
    },
    "functions": {
      "apply_finite_diff": {
        "doc": "Calculates the finite difference approximation of\nthe derivative of requested order at ``x0`` from points\nprovided in ``x_list`` and ``y_list``.\n\nParameters\n==========\n\norder: int\n    order of derivative to approximate. 0 corresponds to interpolation.\nx_list: sequence\n    Sequence of (unique) values for the independent variable.\ny_list: sequence\n    The function value at corresponding values for the independent\n    variable in x_list.\nx0: Number or Symbol\n    At what value of the independent variable the derivative should be\n    evaluated. Defaults to 0.\n\nReturns\n=======\n\nsympy.core.add.Add or sympy.core.numbers.Number\n    The finite difference expression approximating the requested\n    derivative order at ``x0``.\n\nExamples\n========\n\n>>> from sympy import apply_finite_diff\n>>> cube = lambda arg: (1.0*arg)**3\n>>> xlist = range(-3,3+1)\n>>> apply_finite_diff(2, xlist, map(cube, xlist), 2) - 12 # doctest: +SKIP\n-3.55271367880050e-15\n\nwe see that the example above only contain rounding errors.\napply_finite_diff can also be used on more abstract objects:\n\n>>> from sympy import IndexedBase, Idx\n>>> x, y = map(IndexedBase, 'xy')\n>>> i = Idx('i')\n>>> x_list, y_list = zip(*[(x[i+j], y[i+j]) for j in range(-1,2)])\n>>> apply_finite_diff(1, x_list, y_list, x[i])\n((x[i + 1] - x[i])/(-x[i - 1] + x[i]) - 1)*y[i]/(x[i + 1] - x[i]) -\n(x[i + 1] - x[i])*y[i - 1]/((x[i + 1] - x[i - 1])*(-x[i - 1] + x[i])) +\n(-x[i - 1] + x[i])*y[i + 1]/((x[i + 1] - x[i - 1])*(x[i + 1] - x[i]))\n\nNotes\n=====\n\nOrder = 0 corresponds to interpolation.\nOnly supply so many points you think makes sense\nto around x0 when extracting the derivative (the function\nneed to be well behaved within that region). Also beware\nof Runge's phenomenon.\n\nSee also\n========\n\nsympy.calculus.finite_diff.finite_diff_weights\n\nReferences\n==========\n\nFortran 90 implementation with Python interface for numerics: finitediff_\n\n.. _finitediff: https://github.com/bjodah/finitediff",
        "signature": "(order, x_list, y_list, x0=0)",
        "parameters": {
          "order": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "x_list": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "y_list": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "x0": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "0",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "differentiate_finite": {
        "doc": "Differentiate expr and replace Derivatives with finite differences.\n\nParameters\n==========\n\nexpr : expression\n\\*symbols : differentiate with respect to symbols\npoints: sequence, coefficient or undefined function, optional\n    see ``Derivative.as_finite_difference``\nx0: number or Symbol, optional\n    see ``Derivative.as_finite_difference``\nwrt: Symbol, optional\n    see ``Derivative.as_finite_difference``\n\nExamples\n========\n\n>>> from sympy import sin, Function, differentiate_finite\n>>> from sympy.abc import x, y, h\n>>> f, g = Function('f'), Function('g')\n>>> differentiate_finite(f(x)*g(x), x, points=[x-h, x+h])\n-f(-h + x)*g(-h + x)/(2*h) + f(h + x)*g(h + x)/(2*h)\n\n``differentiate_finite`` works on any expression, including the expressions\nwith embedded derivatives:\n\n>>> differentiate_finite(f(x) + sin(x), x, 2)\n-2*f(x) + f(x - 1) + f(x + 1) - 2*sin(x) + sin(x - 1) + sin(x + 1)\n>>> differentiate_finite(f(x, y), x, y)\nf(x - 1/2, y - 1/2) - f(x - 1/2, y + 1/2) - f(x + 1/2, y - 1/2) + f(x + 1/2, y + 1/2)\n>>> differentiate_finite(f(x)*g(x).diff(x), x)\n(-g(x) + g(x + 1))*f(x + 1/2) - (g(x) - g(x - 1))*f(x - 1/2)\n\nTo make finite difference with non-constant discretization step use\nundefined functions:\n\n>>> dx = Function('dx')\n>>> differentiate_finite(f(x)*g(x).diff(x), points=dx(x))\n-(-g(x - dx(x)/2 - dx(x - dx(x)/2)/2)/dx(x - dx(x)/2) +\ng(x - dx(x)/2 + dx(x - dx(x)/2)/2)/dx(x - dx(x)/2))*f(x - dx(x)/2)/dx(x) +\n(-g(x + dx(x)/2 - dx(x + dx(x)/2)/2)/dx(x + dx(x)/2) +\ng(x + dx(x)/2 + dx(x + dx(x)/2)/2)/dx(x + dx(x)/2))*f(x + dx(x)/2)/dx(x)",
        "signature": "(expr, *symbols, points=1, x0=None, wrt=None, evaluate=False)",
        "parameters": {
          "expr": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbols": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          },
          "points": {
            "kind": "KEYWORD_ONLY",
            "default": "1",
            "annotation": null
          },
          "x0": {
            "kind": "KEYWORD_ONLY",
            "default": "None",
            "annotation": null
          },
          "wrt": {
            "kind": "KEYWORD_ONLY",
            "default": "None",
            "annotation": null
          },
          "evaluate": {
            "kind": "KEYWORD_ONLY",
            "default": "False",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "euler_equations": {
        "doc": "Find the Euler-Lagrange equations [1]_ for a given Lagrangian.\n\nParameters\n==========\n\nL : Expr\n    The Lagrangian that should be a function of the functions listed\n    in the second argument and their derivatives.\n\n    For example, in the case of two functions $f(x,y)$, $g(x,y)$ and\n    two independent variables $x$, $y$ the Lagrangian has the form:\n\n        .. math:: L\\left(f(x,y),g(x,y),\\frac{\\partial f(x,y)}{\\partial x},\n                  \\frac{\\partial f(x,y)}{\\partial y},\n                  \\frac{\\partial g(x,y)}{\\partial x},\n                  \\frac{\\partial g(x,y)}{\\partial y},x,y\\right)\n\n    In many cases it is not necessary to provide anything, except the\n    Lagrangian, it will be auto-detected (and an error raised if this\n    cannot be done).\n\nfuncs : Function or an iterable of Functions\n    The functions that the Lagrangian depends on. The Euler equations\n    are differential equations for each of these functions.\n\nvars : Symbol or an iterable of Symbols\n    The Symbols that are the independent variables of the functions.\n\nReturns\n=======\n\neqns : list of Eq\n    The list of differential equations, one for each function.\n\nExamples\n========\n\n>>> from sympy import euler_equations, Symbol, Function\n>>> x = Function('x')\n>>> t = Symbol('t')\n>>> L = (x(t).diff(t))**2/2 - x(t)**2/2\n>>> euler_equations(L, x(t), t)\n[Eq(-x(t) - Derivative(x(t), (t, 2)), 0)]\n>>> u = Function('u')\n>>> x = Symbol('x')\n>>> L = (u(t, x).diff(t))**2/2 - (u(t, x).diff(x))**2/2\n>>> euler_equations(L, u(t, x), [t, x])\n[Eq(-Derivative(u(t, x), (t, 2)) + Derivative(u(t, x), (x, 2)), 0)]\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Lagrange_equation",
        "signature": "(L, funcs=(), vars=())",
        "parameters": {
          "L": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "funcs": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "()",
            "annotation": null
          },
          "vars": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "()",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "finite_diff_weights": {
        "doc": "Calculates the finite difference weights for an arbitrarily spaced\none-dimensional grid (``x_list``) for derivatives at ``x0`` of order\n0, 1, ..., up to ``order`` using a recursive formula. Order of accuracy\nis at least ``len(x_list) - order``, if ``x_list`` is defined correctly.\n\nParameters\n==========\n\norder: int\n    Up to what derivative order weights should be calculated.\n    0 corresponds to interpolation.\nx_list: sequence\n    Sequence of (unique) values for the independent variable.\n    It is useful (but not necessary) to order ``x_list`` from\n    nearest to furthest from ``x0``; see examples below.\nx0: Number or Symbol\n    Root or value of the independent variable for which the finite\n    difference weights should be generated. Default is ``S.One``.\n\nReturns\n=======\n\nlist\n    A list of sublists, each corresponding to coefficients for\n    increasing derivative order, and each containing lists of\n    coefficients for increasing subsets of x_list.\n\nExamples\n========\n\n>>> from sympy import finite_diff_weights, S\n>>> res = finite_diff_weights(1, [-S(1)/2, S(1)/2, S(3)/2, S(5)/2], 0)\n>>> res\n[[[1, 0, 0, 0],\n  [1/2, 1/2, 0, 0],\n  [3/8, 3/4, -1/8, 0],\n  [5/16, 15/16, -5/16, 1/16]],\n [[0, 0, 0, 0],\n  [-1, 1, 0, 0],\n  [-1, 1, 0, 0],\n  [-23/24, 7/8, 1/8, -1/24]]]\n>>> res[0][-1]  # FD weights for 0th derivative, using full x_list\n[5/16, 15/16, -5/16, 1/16]\n>>> res[1][-1]  # FD weights for 1st derivative\n[-23/24, 7/8, 1/8, -1/24]\n>>> res[1][-2]  # FD weights for 1st derivative, using x_list[:-1]\n[-1, 1, 0, 0]\n>>> res[1][-1][0]  # FD weight for 1st deriv. for x_list[0]\n-23/24\n>>> res[1][-1][1]  # FD weight for 1st deriv. for x_list[1], etc.\n7/8\n\nEach sublist contains the most accurate formula at the end.\nNote, that in the above example ``res[1][1]`` is the same as ``res[1][2]``.\nSince res[1][2] has an order of accuracy of\n``len(x_list[:3]) - order = 3 - 1 = 2``, the same is true for ``res[1][1]``!\n\n>>> res = finite_diff_weights(1, [S(0), S(1), -S(1), S(2), -S(2)], 0)[1]\n>>> res\n[[0, 0, 0, 0, 0],\n [-1, 1, 0, 0, 0],\n [0, 1/2, -1/2, 0, 0],\n [-1/2, 1, -1/3, -1/6, 0],\n [0, 2/3, -2/3, -1/12, 1/12]]\n>>> res[0]  # no approximation possible, using x_list[0] only\n[0, 0, 0, 0, 0]\n>>> res[1]  # classic forward step approximation\n[-1, 1, 0, 0, 0]\n>>> res[2]  # classic centered approximation\n[0, 1/2, -1/2, 0, 0]\n>>> res[3:]  # higher order approximations\n[[-1/2, 1, -1/3, -1/6, 0], [0, 2/3, -2/3, -1/12, 1/12]]\n\nLet us compare this to a differently defined ``x_list``. Pay attention to\n``foo[i][k]`` corresponding to the gridpoint defined by ``x_list[k]``.\n\n>>> foo = finite_diff_weights(1, [-S(2), -S(1), S(0), S(1), S(2)], 0)[1]\n>>> foo\n[[0, 0, 0, 0, 0],\n [-1, 1, 0, 0, 0],\n [1/2, -2, 3/2, 0, 0],\n [1/6, -1, 1/2, 1/3, 0],\n [1/12, -2/3, 0, 2/3, -1/12]]\n>>> foo[1]  # not the same and of lower accuracy as res[1]!\n[-1, 1, 0, 0, 0]\n>>> foo[2]  # classic double backward step approximation\n[1/2, -2, 3/2, 0, 0]\n>>> foo[4]  # the same as res[4]\n[1/12, -2/3, 0, 2/3, -1/12]\n\nNote that, unless you plan on using approximations based on subsets of\n``x_list``, the order of gridpoints does not matter.\n\nThe capability to generate weights at arbitrary points can be\nused e.g. to minimize Runge's phenomenon by using Chebyshev nodes:\n\n>>> from sympy import cos, symbols, pi, simplify\n>>> N, (h, x) = 4, symbols('h x')\n>>> x_list = [x+h*cos(i*pi/(N)) for i in range(N,-1,-1)] # chebyshev nodes\n>>> print(x_list)\n[-h + x, -sqrt(2)*h/2 + x, x, sqrt(2)*h/2 + x, h + x]\n>>> mycoeffs = finite_diff_weights(1, x_list, 0)[1][4]\n>>> [simplify(c) for c in  mycoeffs] #doctest: +NORMALIZE_WHITESPACE\n[(h**3/2 + h**2*x - 3*h*x**2 - 4*x**3)/h**4,\n(-sqrt(2)*h**3 - 4*h**2*x + 3*sqrt(2)*h*x**2 + 8*x**3)/h**4,\n(6*h**2*x - 8*x**3)/h**4,\n(sqrt(2)*h**3 - 4*h**2*x - 3*sqrt(2)*h*x**2 + 8*x**3)/h**4,\n(-h**3/2 + h**2*x + 3*h*x**2 - 4*x**3)/h**4]\n\nNotes\n=====\n\nIf weights for a finite difference approximation of 3rd order\nderivative is wanted, weights for 0th, 1st and 2nd order are\ncalculated \"for free\", so are formulae using subsets of ``x_list``.\nThis is something one can take advantage of to save computational cost.\nBe aware that one should define ``x_list`` from nearest to furthest from\n``x0``. If not, subsets of ``x_list`` will yield poorer approximations,\nwhich might not grand an order of accuracy of ``len(x_list) - order``.\n\nSee also\n========\n\nsympy.calculus.finite_diff.apply_finite_diff\n\nReferences\n==========\n\n.. [1] Generation of Finite Difference Formulas on Arbitrarily Spaced\n        Grids, Bengt Fornberg; Mathematics of computation; 51; 184;\n        (1988); 699-706; doi:10.1090/S0025-5718-1988-0935077-0",
        "signature": "(order, x_list, x0=1)",
        "parameters": {
          "order": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "x_list": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "x0": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "1",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "is_convex": {
        "doc": "Determines the  convexity of the function passed in the argument.\n\nParameters\n==========\n\nf : :py:class:`~.Expr`\n    The concerned function.\nsyms : Tuple of :py:class:`~.Symbol`\n    The variables with respect to which the convexity is to be determined.\ndomain : :py:class:`~.Interval`, optional\n    The domain over which the convexity of the function has to be checked.\n    If unspecified, S.Reals will be the default domain.\n\nReturns\n=======\n\nbool\n    The method returns ``True`` if the function is convex otherwise it\n    returns ``False``.\n\nRaises\n======\n\nNotImplementedError\n    The check for the convexity of multivariate functions is not implemented yet.\n\nNotes\n=====\n\nTo determine concavity of a function pass `-f` as the concerned function.\nTo determine logarithmic convexity of a function pass `\\log(f)` as\nconcerned function.\nTo determine logarithmic concavity of a function pass `-\\log(f)` as\nconcerned function.\n\nCurrently, convexity check of multivariate functions is not handled.\n\nExamples\n========\n\n>>> from sympy import is_convex, symbols, exp, oo, Interval\n>>> x = symbols('x')\n>>> is_convex(exp(x), x)\nTrue\n>>> is_convex(x**3, x, domain = Interval(-1, oo))\nFalse\n>>> is_convex(1/x**2, x, domain=Interval.open(0, oo))\nTrue\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Convex_function\n.. [2] http://www.ifp.illinois.edu/~angelia/L3_convfunc.pdf\n.. [3] https://en.wikipedia.org/wiki/Logarithmically_convex_function\n.. [4] https://en.wikipedia.org/wiki/Logarithmically_concave_function\n.. [5] https://en.wikipedia.org/wiki/Concave_function",
        "signature": "(f, *syms, domain=Reals)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "syms": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          },
          "domain": {
            "kind": "KEYWORD_ONLY",
            "default": "Reals",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "is_decreasing": {
        "doc": "Return whether the function is decreasing in the given interval.\n\nParameters\n==========\n\nexpression : Expr\n    The target function which is being checked.\ninterval : Set, optional\n    The range of values in which we are testing (defaults to set of\n    all real numbers).\nsymbol : Symbol, optional\n    The symbol present in expression which gets varied over the given range.\n\nReturns\n=======\n\nBoolean\n    True if ``expression`` is decreasing (either strictly decreasing or\n    constant) in the given ``interval``, False otherwise.\n\nExamples\n========\n\n>>> from sympy import is_decreasing\n>>> from sympy.abc import x, y\n>>> from sympy import S, Interval, oo\n>>> is_decreasing(1/(x**2 - 3*x), Interval.open(S(3)/2, 3))\nTrue\n>>> is_decreasing(1/(x**2 - 3*x), Interval.open(1.5, 3))\nTrue\n>>> is_decreasing(1/(x**2 - 3*x), Interval.Lopen(3, oo))\nTrue\n>>> is_decreasing(1/(x**2 - 3*x), Interval.Ropen(-oo, S(3)/2))\nFalse\n>>> is_decreasing(1/(x**2 - 3*x), Interval.Ropen(-oo, 1.5))\nFalse\n>>> is_decreasing(-x**2, Interval(-oo, 0))\nFalse\n>>> is_decreasing(-x**2 + y, Interval(-oo, 0), x)\nFalse",
        "signature": "(expression, interval=Reals, symbol=None)",
        "parameters": {
          "expression": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "interval": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Reals",
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "is_increasing": {
        "doc": "Return whether the function is increasing in the given interval.\n\nParameters\n==========\n\nexpression : Expr\n    The target function which is being checked.\ninterval : Set, optional\n    The range of values in which we are testing (defaults to set of\n    all real numbers).\nsymbol : Symbol, optional\n    The symbol present in expression which gets varied over the given range.\n\nReturns\n=======\n\nBoolean\n    True if ``expression`` is increasing (either strictly increasing or\n    constant) in the given ``interval``, False otherwise.\n\nExamples\n========\n\n>>> from sympy import is_increasing\n>>> from sympy.abc import x, y\n>>> from sympy import S, Interval, oo\n>>> is_increasing(x**3 - 3*x**2 + 4*x, S.Reals)\nTrue\n>>> is_increasing(-x**2, Interval(-oo, 0))\nTrue\n>>> is_increasing(-x**2, Interval(0, oo))\nFalse\n>>> is_increasing(4*x**3 - 6*x**2 - 72*x + 30, Interval(-2, 3))\nFalse\n>>> is_increasing(x**2 + y, Interval(1, 2), x)\nTrue",
        "signature": "(expression, interval=Reals, symbol=None)",
        "parameters": {
          "expression": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "interval": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Reals",
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "is_monotonic": {
        "doc": "Return whether the function is monotonic in the given interval.\n\nParameters\n==========\n\nexpression : Expr\n    The target function which is being checked.\ninterval : Set, optional\n    The range of values in which we are testing (defaults to set of\n    all real numbers).\nsymbol : Symbol, optional\n    The symbol present in expression which gets varied over the given range.\n\nReturns\n=======\n\nBoolean\n    True if ``expression`` is monotonic in the given ``interval``,\n    False otherwise.\n\nRaises\n======\n\nNotImplementedError\n    Monotonicity check has not been implemented for the queried function.\n\nExamples\n========\n\n>>> from sympy import is_monotonic\n>>> from sympy.abc import x, y\n>>> from sympy import S, Interval, oo\n>>> is_monotonic(1/(x**2 - 3*x), Interval.open(S(3)/2, 3))\nTrue\n>>> is_monotonic(1/(x**2 - 3*x), Interval.open(1.5, 3))\nTrue\n>>> is_monotonic(1/(x**2 - 3*x), Interval.Lopen(3, oo))\nTrue\n>>> is_monotonic(x**3 - 3*x**2 + 4*x, S.Reals)\nTrue\n>>> is_monotonic(-x**2, S.Reals)\nFalse\n>>> is_monotonic(x**2 + y + 1, Interval(1, 2), x)\nTrue",
        "signature": "(expression, interval=Reals, symbol=None)",
        "parameters": {
          "expression": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "interval": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Reals",
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "is_strictly_decreasing": {
        "doc": "Return whether the function is strictly decreasing in the given interval.\n\nParameters\n==========\n\nexpression : Expr\n    The target function which is being checked.\ninterval : Set, optional\n    The range of values in which we are testing (defaults to set of\n    all real numbers).\nsymbol : Symbol, optional\n    The symbol present in expression which gets varied over the given range.\n\nReturns\n=======\n\nBoolean\n    True if ``expression`` is strictly decreasing in the given ``interval``,\n    False otherwise.\n\nExamples\n========\n\n>>> from sympy import is_strictly_decreasing\n>>> from sympy.abc import x, y\n>>> from sympy import S, Interval, oo\n>>> is_strictly_decreasing(1/(x**2 - 3*x), Interval.Lopen(3, oo))\nTrue\n>>> is_strictly_decreasing(1/(x**2 - 3*x), Interval.Ropen(-oo, S(3)/2))\nFalse\n>>> is_strictly_decreasing(1/(x**2 - 3*x), Interval.Ropen(-oo, 1.5))\nFalse\n>>> is_strictly_decreasing(-x**2, Interval(-oo, 0))\nFalse\n>>> is_strictly_decreasing(-x**2 + y, Interval(-oo, 0), x)\nFalse",
        "signature": "(expression, interval=Reals, symbol=None)",
        "parameters": {
          "expression": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "interval": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Reals",
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "is_strictly_increasing": {
        "doc": "Return whether the function is strictly increasing in the given interval.\n\nParameters\n==========\n\nexpression : Expr\n    The target function which is being checked.\ninterval : Set, optional\n    The range of values in which we are testing (defaults to set of\n    all real numbers).\nsymbol : Symbol, optional\n    The symbol present in expression which gets varied over the given range.\n\nReturns\n=======\n\nBoolean\n    True if ``expression`` is strictly increasing in the given ``interval``,\n    False otherwise.\n\nExamples\n========\n\n>>> from sympy import is_strictly_increasing\n>>> from sympy.abc import x, y\n>>> from sympy import Interval, oo\n>>> is_strictly_increasing(4*x**3 - 6*x**2 - 72*x + 30, Interval.Ropen(-oo, -2))\nTrue\n>>> is_strictly_increasing(4*x**3 - 6*x**2 - 72*x + 30, Interval.Lopen(3, oo))\nTrue\n>>> is_strictly_increasing(4*x**3 - 6*x**2 - 72*x + 30, Interval.open(-2, 3))\nFalse\n>>> is_strictly_increasing(-x**2, Interval(0, oo))\nFalse\n>>> is_strictly_increasing(-x**2 + y, Interval(-oo, 0), x)\nFalse",
        "signature": "(expression, interval=Reals, symbol=None)",
        "parameters": {
          "expression": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "interval": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Reals",
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "maximum": {
        "doc": "Returns the maximum value of a function in the given domain.\n\nParameters\n==========\n\nf : :py:class:`~.Expr`\n    The concerned function.\nsymbol : :py:class:`~.Symbol`\n    The variable for maximum value needs to be determined.\ndomain : :py:class:`~.Interval`\n    The domain over which the maximum have to be checked.\n    If unspecified, then the global maximum is returned.\n\nReturns\n=======\n\nnumber\n    Maximum value of the function in given domain.\n\nExamples\n========\n\n>>> from sympy import Interval, Symbol, S, sin, cos, pi, maximum\n>>> x = Symbol('x')\n\n>>> f = -x**2 + 2*x + 5\n>>> maximum(f, x, S.Reals)\n6\n\n>>> maximum(sin(x), x, Interval(-pi, pi/4))\nsqrt(2)/2\n\n>>> maximum(sin(x)*cos(x), x)\n1/2",
        "signature": "(f, symbol, domain=Reals)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "domain": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Reals",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "minimum": {
        "doc": "Returns the minimum value of a function in the given domain.\n\nParameters\n==========\n\nf : :py:class:`~.Expr`\n    The concerned function.\nsymbol : :py:class:`~.Symbol`\n    The variable for minimum value needs to be determined.\ndomain : :py:class:`~.Interval`\n    The domain over which the minimum have to be checked.\n    If unspecified, then the global minimum is returned.\n\nReturns\n=======\n\nnumber\n    Minimum value of the function in the given domain.\n\nExamples\n========\n\n>>> from sympy import Interval, Symbol, S, sin, cos, minimum\n>>> x = Symbol('x')\n\n>>> f = x**2 + 2*x + 5\n>>> minimum(f, x, S.Reals)\n4\n\n>>> minimum(sin(x), x, Interval(2, 3))\nsin(3)\n\n>>> minimum(sin(x)*cos(x), x)\n-1/2",
        "signature": "(f, symbol, domain=Reals)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "domain": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Reals",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "not_empty_in": {
        "doc": "Finds the domain of the functions in ``finset_intersection`` in which the\n``finite_set`` is not-empty.\n\nParameters\n==========\n\nfinset_intersection : Intersection of FiniteSet\n    The unevaluated intersection of FiniteSet containing\n    real-valued functions with Union of Sets\nsyms : Tuple of symbols\n    Symbol for which domain is to be found\n\nRaises\n======\n\nNotImplementedError\n    The algorithms to find the non-emptiness of the given FiniteSet are\n    not yet implemented.\nValueError\n    The input is not valid.\nRuntimeError\n    It is a bug, please report it to the github issue tracker\n    (https://github.com/sympy/sympy/issues).\n\nExamples\n========\n\n>>> from sympy import FiniteSet, Interval, not_empty_in, oo\n>>> from sympy.abc import x\n>>> not_empty_in(FiniteSet(x/2).intersect(Interval(0, 1)), x)\nInterval(0, 2)\n>>> not_empty_in(FiniteSet(x, x**2).intersect(Interval(1, 2)), x)\nUnion(Interval(1, 2), Interval(-sqrt(2), -1))\n>>> not_empty_in(FiniteSet(x**2/(x + 2)).intersect(Interval(1, oo)), x)\nUnion(Interval.Lopen(-2, -1), Interval(2, oo))",
        "signature": "(finset_intersection, *syms)",
        "parameters": {
          "finset_intersection": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "syms": {
            "kind": "VAR_POSITIONAL",
            "default": null,
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "periodicity": {
        "doc": "Tests the given function for periodicity in the given symbol.\n\nParameters\n==========\n\nf : :py:class:`~.Expr`\n    The concerned function.\nsymbol : :py:class:`~.Symbol`\n    The variable for which the period is to be determined.\ncheck : bool, optional\n    The flag to verify whether the value being returned is a period or not.\n\nReturns\n=======\n\nperiod\n    The period of the function is returned.\n    ``None`` is returned when the function is aperiodic or has a complex period.\n    The value of $0$ is returned as the period of a constant function.\n\nRaises\n======\n\nNotImplementedError\n    The value of the period computed cannot be verified.\n\n\nNotes\n=====\n\nCurrently, we do not support functions with a complex period.\nThe period of functions having complex periodic values such\nas ``exp``, ``sinh`` is evaluated to ``None``.\n\nThe value returned might not be the \"fundamental\" period of the given\nfunction i.e. it may not be the smallest periodic value of the function.\n\nThe verification of the period through the ``check`` flag is not reliable\ndue to internal simplification of the given expression. Hence, it is set\nto ``False`` by default.\n\nExamples\n========\n>>> from sympy import periodicity, Symbol, sin, cos, tan, exp\n>>> x = Symbol('x')\n>>> f = sin(x) + sin(2*x) + sin(3*x)\n>>> periodicity(f, x)\n2*pi\n>>> periodicity(sin(x)*cos(x), x)\npi\n>>> periodicity(exp(tan(2*x) - 1), x)\npi/2\n>>> periodicity(sin(4*x)**cos(2*x), x)\npi\n>>> periodicity(exp(x), x)",
        "signature": "(f, symbol, check=False)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "check": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "False",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "singularities": {
        "doc": "Find singularities of a given function.\n\nParameters\n==========\n\nexpression : Expr\n    The target function in which singularities need to be found.\nsymbol : Symbol\n    The symbol over the values of which the singularity in\n    expression in being searched for.\n\nReturns\n=======\n\nSet\n    A set of values for ``symbol`` for which ``expression`` has a\n    singularity. An ``EmptySet`` is returned if ``expression`` has no\n    singularities for any given value of ``Symbol``.\n\nRaises\n======\n\nNotImplementedError\n    Methods for determining the singularities of this function have\n    not been developed.\n\nNotes\n=====\n\nThis function does not find non-isolated singularities\nnor does it find branch points of the expression.\n\nCurrently supported functions are:\n    - univariate continuous (real or complex) functions\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Mathematical_singularity\n\nExamples\n========\n\n>>> from sympy import singularities, Symbol, log\n>>> x = Symbol('x', real=True)\n>>> y = Symbol('y', real=False)\n>>> singularities(x**2 + x + 1, x)\nEmptySet\n>>> singularities(1/(x + 1), x)\n{-1}\n>>> singularities(1/(y**2 + 1), y)\n{-I, I}\n>>> singularities(1/(y**3 + 1), y)\n{-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2}\n>>> singularities(log(x), x)\n{0}",
        "signature": "(expression, symbol, domain=None)",
        "parameters": {
          "expression": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "domain": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "None",
            "annotation": null
          }
        },
        "return_annotation": null
      },
      "stationary_points": {
        "doc": "Returns the stationary points of a function (where derivative of the\nfunction is 0) in the given domain.\n\nParameters\n==========\n\nf : :py:class:`~.Expr`\n    The concerned function.\nsymbol : :py:class:`~.Symbol`\n    The variable for which the stationary points are to be determined.\ndomain : :py:class:`~.Interval`\n    The domain over which the stationary points have to be checked.\n    If unspecified, ``S.Reals`` will be the default domain.\n\nReturns\n=======\n\nSet\n    A set of stationary points for the function. If there are no\n    stationary point, an :py:class:`~.EmptySet` is returned.\n\nExamples\n========\n\n>>> from sympy import Interval, Symbol, S, sin, pi, pprint, stationary_points\n>>> x = Symbol('x')\n\n>>> stationary_points(1/x, x, S.Reals)\nEmptySet\n\n>>> pprint(stationary_points(sin(x), x), use_unicode=False)\n          pi                              3*pi\n{2*n*pi + -- | n in Integers} U {2*n*pi + ---- | n in Integers}\n          2                                2\n\n>>> stationary_points(sin(x),x, Interval(0, 4*pi))\n{pi/2, 3*pi/2, 5*pi/2, 7*pi/2}",
        "signature": "(f, symbol, domain=Reals)",
        "parameters": {
          "f": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "symbol": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": null,
            "annotation": null
          },
          "domain": {
            "kind": "POSITIONAL_OR_KEYWORD",
            "default": "Reals",
            "annotation": null
          }
        },
        "return_annotation": null
      }
    },
    "constants": {}
  }
}