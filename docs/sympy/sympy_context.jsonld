{
  "@context": {
    "@vocab": "https://schema.org/",
    "sympy": "https://sympy.org/",
    "widget": "https://widgets.sympy.org/",
    "SoftwareApplication": "https://schema.org/SoftwareApplication",
    "ComputationalWidget": "widget:ComputationalWidget",
    "MathematicalFunction": "widget:MathematicalFunction"
  },
  "@graph": [
    {
      "@type": "SoftwareApplication",
      "@id": "sympy:sympy.core",
      "name": "sympy.core",
      "applicationCategory": "Mathematical Software",
      "classes": [
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Add",
          "name": "Add",
          "description": "Expression representing addition operation for algebraic group.\n\n.. deprecated:: 1.7\n\n   Using arguments that aren't subclasses of :class:`~.Expr` in core\n   operators (:class:`~.Mul`, :class:`~.Add`, and :class:`~.Pow`) is\n   deprecated. See :ref:`non-expr-args-deprecated` for details.\n\nEvery argument of ``Add()`` must be ``Expr``. Infix operator ``+``\non most scalar objects in SymPy calls this class.\n\nAnother use of ``Add()`` is to represent the structure of abstract\naddition so that its arguments can be substituted to return different\nclass. Refer to examples section for this.\n\n``Add()`` evaluates the argument unless ``evaluate=False`` is passed.\nThe evaluation logic includes:\n\n1. Flattening\n    ``Add(x, Add(y, z))`` -> ``Add(x, y, z)``\n\n2. Identity removing\n    ``Add(x, 0, y)`` -> ``Add(x, y)``\n\n3. Coefficient collecting by ``.as_coeff_Mul()``\n    ``Add(x, 2*x)`` -> ``Mul(3, x)``\n\n4. Term sorting\n    ``Add(y, x, 2)`` -> ``Add(2, x, y)``\n\nIf no argument is passed, identity element 0 is returned. If single\nelement is passed, that element is returned.\n\nNote that ``Add(*args)`` is more efficient than ``sum(args)`` because\nit flattens the arguments. ``sum(a, b, c, ...)`` recursively adds the\narguments as ``a + (b + (c + ...))``, which has quadratic complexity.\nOn the other hand, ``Add(a, b, c, d)`` does not assume nested\nstructure, making the complexity linear.\n\nSince addition is group operation, every argument should have the\nsame :obj:`sympy.core.kind.Kind()`.\n\nExamples\n========\n\n>>> from sympy import Add, I\n>>> from sympy.abc import x, y\n>>> Add(x, 1)\nx + 1\n>>> Add(x, x)\n2*x\n>>> 2*x**2 + 3*x + I*y + 2*y + 2*x/5 + 1.0*y + 1\n2*x**2 + 17*x/5 + 3.0*y + I*y + 1\n\nIf ``evaluate=False`` is passed, result is not evaluated.\n\n>>> Add(1, 2, evaluate=False)\n1 + 2\n>>> Add(x, x, evaluate=False)\nx + x\n\n``Add()`` also represents the general structure of addition operation.\n\n>>> from sympy import MatrixSymbol\n>>> A,B = MatrixSymbol('A', 2,2), MatrixSymbol('B', 2,2)\n>>> expr = Add(x,y).subs({x:A, y:B})\n>>> expr\nA + B\n>>> type(expr)\n<class 'sympy.matrices.expressions.matadd.MatAdd'>\n\nNote that the printers do not display in args order.\n\n>>> Add(x, 1)\nx + 1\n>>> Add(x, 1).args\n(1, x)\n\nSee Also\n========\n\nMatAdd",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Add.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.AlgebraicNumber",
          "name": "AlgebraicNumber",
          "description": "Class for representing algebraic numbers in SymPy.\n\nSymbolically, an instance of this class represents an element\n$\\alpha \\in \\mathbb{Q}(\\theta) \\hookrightarrow \\mathbb{C}$. That is, the\nalgebraic number $\\alpha$ is represented as an element of a particular\nnumber field $\\mathbb{Q}(\\theta)$, with a particular embedding of this\nfield into the complex numbers.\n\nFormally, the primitive element $\\theta$ is given by two data points: (1)\nits minimal polynomial (which defines $\\mathbb{Q}(\\theta)$), and (2) a\nparticular complex number that is a root of this polynomial (which defines\nthe embedding $\\mathbb{Q}(\\theta) \\hookrightarrow \\mathbb{C}$). Finally,\nthe algebraic number $\\alpha$ which we represent is then given by the\ncoefficients of a polynomial in $\\theta$.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AlgebraicNumber.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Atom",
          "name": "Atom",
          "description": "A parent class for atomic things. An atom is an expression with no subexpressions.\n\nExamples\n========\n\nSymbol, Number, Rational, Integer, ...\nBut not: Add, Mul, Pow, ...",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.as_content_primitive",
              "name": "as_content_primitive"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.as_dummy",
              "name": "as_dummy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.atoms",
              "name": "atoms"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.class_key",
              "name": "class_key"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.compare",
              "name": "compare"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.copy",
              "name": "copy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.could_extract_minus_sign",
              "name": "could_extract_minus_sign"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.count",
              "name": "count"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.count_ops",
              "name": "count_ops"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Atom.doit",
              "name": "doit"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.AtomicExpr",
          "name": "AtomicExpr",
          "description": "A parent class for object which are both atoms and Exprs.\n\nFor example: Symbol, Number, Rational, Integer, ...\nBut not: Add, Mul, Pow, ...",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.AtomicExpr.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Basic",
          "name": "Basic",
          "description": "Base class for all SymPy objects.\n\nNotes and conventions\n=====================\n\n1) Always use ``.args``, when accessing parameters of some instance:\n\n>>> from sympy import cot\n>>> from sympy.abc import x, y\n\n>>> cot(x).args\n(x,)\n\n>>> cot(x).args[0]\nx\n\n>>> (x*y).args\n(x, y)\n\n>>> (x*y).args[1]\ny\n\n\n2) Never use internal methods or variables (the ones prefixed with ``_``):\n\n>>> cot(x)._args    # do not use this, use cot(x).args instead\n(x,)\n\n\n3)  By \"SymPy object\" we mean something that can be returned by\n    ``sympify``.  But not all objects one encounters using SymPy are\n    subclasses of Basic.  For example, mutable objects are not:\n\n    >>> from sympy import Basic, Matrix, sympify\n    >>> A = Matrix([[1, 2], [3, 4]]).as_mutable()\n    >>> isinstance(A, Basic)\n    False\n\n    >>> B = sympify(A)\n    >>> isinstance(B, Basic)\n    True",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.as_content_primitive",
              "name": "as_content_primitive"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.as_dummy",
              "name": "as_dummy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.atoms",
              "name": "atoms"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.class_key",
              "name": "class_key"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.compare",
              "name": "compare"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.copy",
              "name": "copy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.could_extract_minus_sign",
              "name": "could_extract_minus_sign"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.count",
              "name": "count"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.count_ops",
              "name": "count_ops"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Basic.doit",
              "name": "doit"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Derivative",
          "name": "Derivative",
          "description": "Carries out differentiation of the given expression with respect to symbols.\n\nExamples\n========\n\n>>> from sympy import Derivative, Function, symbols, Subs\n>>> from sympy.abc import x, y\n>>> f, g = symbols('f g', cls=Function)\n\n>>> Derivative(x**2, x, evaluate=True)\n2*x\n\nDenesting of derivatives retains the ordering of variables:\n\n    >>> Derivative(Derivative(f(x, y), y), x)\n    Derivative(f(x, y), y, x)\n\nContiguously identical symbols are merged into a tuple giving\nthe symbol and the count:\n\n    >>> Derivative(f(x), x, x, y, x)\n    Derivative(f(x), (x, 2), y, x)\n\nIf the derivative cannot be performed, and evaluate is True, the\norder of the variables of differentiation will be made canonical:\n\n    >>> Derivative(f(x, y), y, x, evaluate=True)\n    Derivative(f(x, y), x, y)\n\nDerivatives with respect to undefined functions can be calculated:\n\n    >>> Derivative(f(x)**2, f(x), evaluate=True)\n    2*f(x)\n\nSuch derivatives will show up when the chain rule is used to\nevaluate a derivative:\n\n    >>> f(g(x)).diff(x)\n    Derivative(f(g(x)), g(x))*Derivative(g(x), x)\n\nSubstitution is used to represent derivatives of functions with\narguments that are not symbols or functions:\n\n    >>> f(2*x + 3).diff(x) == 2*Subs(f(y).diff(y), y, 2*x + 3)\n    True\n\nNotes\n=====\n\nSimplification of high-order derivatives:\n\nBecause there can be a significant amount of simplification that can be\ndone when multiple differentiations are performed, results will be\nautomatically simplified in a fairly conservative fashion unless the\nkeyword ``simplify`` is set to False.\n\n    >>> from sympy import sqrt, diff, Function, symbols\n    >>> from sympy.abc import x, y, z\n    >>> f, g = symbols('f,g', cls=Function)\n\n    >>> e = sqrt((x + 1)**2 + x)\n    >>> diff(e, (x, 5), simplify=False).count_ops()\n    136\n    >>> diff(e, (x, 5)).count_ops()\n    30\n\nOrdering of variables:\n\nIf evaluate is set to True and the expression cannot be evaluated, the\nlist of differentiation symbols will be sorted, that is, the expression is\nassumed to have continuous derivatives up to the order asked.\n\nDerivative wrt non-Symbols:\n\nFor the most part, one may not differentiate wrt non-symbols.\nFor example, we do not allow differentiation wrt `x*y` because\nthere are multiple ways of structurally defining where x*y appears\nin an expression: a very strict definition would make\n(x*y*z).diff(x*y) == 0. Derivatives wrt defined functions (like\ncos(x)) are not allowed, either:\n\n    >>> (x*y*z).diff(x*y)\n    Traceback (most recent call last):\n    ...\n    ValueError: Can't calculate derivative wrt x*y.\n\nTo make it easier to work with variational calculus, however,\nderivatives wrt AppliedUndef and Derivatives are allowed.\nFor example, in the Euler-Lagrange method one may write\nF(t, u, v) where u = f(t) and v = f'(t). These variables can be\nwritten explicitly as functions of time::\n\n    >>> from sympy.abc import t\n    >>> F = Function('F')\n    >>> U = f(t)\n    >>> V = U.diff(t)\n\nThe derivative wrt f(t) can be obtained directly:\n\n    >>> direct = F(t, U, V).diff(U)\n\nWhen differentiation wrt a non-Symbol is attempted, the non-Symbol\nis temporarily converted to a Symbol while the differentiation\nis performed and the same answer is obtained:\n\n    >>> indirect = F(t, U, V).subs(U, x).diff(x).subs(x, U)\n    >>> assert direct == indirect\n\nThe implication of this non-symbol replacement is that all\nfunctions are treated as independent of other functions and the\nsymbols are independent of the functions that contain them::\n\n    >>> x.diff(f(x))\n    0\n    >>> g(x).diff(f(x))\n    0\n\nIt also means that derivatives are assumed to depend only\non the variables of differentiation, not on anything contained\nwithin the expression being differentiated::\n\n    >>> F = f(x)\n    >>> Fx = F.diff(x)\n    >>> Fx.diff(F)  # derivative depends on x, not F\n    0\n    >>> Fxx = Fx.diff(x)\n    >>> Fxx.diff(Fx)  # derivative depends on x, not Fx\n    0\n\nThe last example can be made explicit by showing the replacement\nof Fx in Fxx with y:\n\n    >>> Fxx.subs(Fx, y)\n    Derivative(y, x)\n\n    Since that in itself will evaluate to zero, differentiating\n    wrt Fx will also be zero:\n\n    >>> _.doit()\n    0\n\nReplacing undefined functions with concrete expressions\n\nOne must be careful to replace undefined functions with expressions\nthat contain variables consistent with the function definition and\nthe variables of differentiation or else insconsistent result will\nbe obtained. Consider the following example:\n\n>>> eq = f(x)*g(y)\n>>> eq.subs(f(x), x*y).diff(x, y).doit()\ny*Derivative(g(y), y) + g(y)\n>>> eq.diff(x, y).subs(f(x), x*y).doit()\ny*Derivative(g(y), y)\n\nThe results differ because `f(x)` was replaced with an expression\nthat involved both variables of differentiation. In the abstract\ncase, differentiation of `f(x)` by `y` is 0; in the concrete case,\nthe presence of `y` made that derivative nonvanishing and produced\nthe extra `g(y)` term.\n\nDefining differentiation for an object\n\nAn object must define ._eval_derivative(symbol) method that returns\nthe differentiation result. This function only needs to consider the\nnon-trivial case where expr contains symbol and it should call the diff()\nmethod internally (not _eval_derivative); Derivative should be the only\none to call _eval_derivative.\n\nAny class can allow derivatives to be taken with respect to\nitself (while indicating its scalar nature). See the\ndocstring of Expr._diff_wrt.\n\nSee Also\n========\n_sort_variable_count",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Derivative.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Dict",
          "name": "Dict",
          "description": "Wrapper around the builtin dict object.\n\nExplanation\n===========\n\nThe Dict is a subclass of Basic, so that it works well in the\nSymPy framework.  Because it is immutable, it may be included\nin sets, but its values must all be given at instantiation and\ncannot be changed afterwards.  Otherwise it behaves identically\nto the Python dict.\n\nExamples\n========\n\n>>> from sympy import Dict, Symbol\n\n>>> D = Dict({1: 'one', 2: 'two'})\n>>> for key in D:\n...    if key == 1:\n...        print('%s %s' % (key, D[key]))\n1 one\n\nThe args are sympified so the 1 and 2 are Integers and the values\nare Symbols. Queries automatically sympify args so the following work:\n\n>>> 1 in D\nTrue\n>>> D.has(Symbol('one')) # searches keys and values\nTrue\n>>> 'one' in D # not in the keys\nFalse\n>>> D[1]\none",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.as_content_primitive",
              "name": "as_content_primitive"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.as_dummy",
              "name": "as_dummy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.atoms",
              "name": "atoms"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.class_key",
              "name": "class_key"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.compare",
              "name": "compare"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.copy",
              "name": "copy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.could_extract_minus_sign",
              "name": "could_extract_minus_sign"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.count",
              "name": "count"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.count_ops",
              "name": "count_ops"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dict.doit",
              "name": "doit"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Dummy",
          "name": "Dummy",
          "description": "Dummy symbols are each unique, even if they have the same name:\n\nExamples\n========\n\n>>> from sympy import Dummy\n>>> Dummy(\"x\") == Dummy(\"x\")\nFalse\n\nIf a name is not supplied then a string value of an internal count will be\nused. This is useful when a temporary variable is needed and the name\nof the variable used in the expression is not important.\n\n>>> Dummy() #doctest: +SKIP\n_Dummy_10",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Dummy.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Eq",
          "name": "Eq",
          "description": "An equal relation between two objects.\n\nExplanation\n===========\n\nRepresents that two objects are equal.  If they can be easily shown\nto be definitively equal (or unequal), this will reduce to True (or\nFalse).  Otherwise, the relation is maintained as an unevaluated\nEquality object.  Use the ``simplify`` function on this object for\nmore nontrivial evaluation of the equality relation.\n\nAs usual, the keyword argument ``evaluate=False`` can be used to\nprevent any evaluation.\n\nExamples\n========\n\n>>> from sympy import Eq, simplify, exp, cos\n>>> from sympy.abc import x, y\n>>> Eq(y, x + x**2)\nEq(y, x**2 + x)\n>>> Eq(2, 5)\nFalse\n>>> Eq(2, 5, evaluate=False)\nEq(2, 5)\n>>> _.doit()\nFalse\n>>> Eq(exp(x), exp(x).rewrite(cos))\nEq(exp(x), sinh(x) + cosh(x))\n>>> simplify(_)\nTrue\n\nSee Also\n========\n\nsympy.logic.boolalg.Equivalent : for representing equality between two\n    boolean expressions\n\nNotes\n=====\n\nPython treats 1 and True (and 0 and False) as being equal; SymPy\ndoes not. And integer will always compare as unequal to a Boolean:\n\n>>> Eq(True, 1), True == 1\n(False, True)\n\nThis class is not the same as the == operator.  The == operator tests\nfor exact structural equality between two expressions; this class\ncompares expressions mathematically.\n\nIf either object defines an ``_eval_Eq`` method, it can be used in place of\nthe default algorithm.  If ``lhs._eval_Eq(rhs)`` or ``rhs._eval_Eq(lhs)``\nreturns anything other than None, that return value will be substituted for\nthe Equality.  If None is returned by ``_eval_Eq``, an Equality object will\nbe created as usual.\n\nSince this object is already an expression, it does not respond to\nthe method ``as_expr`` if one tries to create `x - y` from ``Eq(x, y)``.\nIf ``eq = Eq(x, y)`` then write `eq.lhs - eq.rhs` to get ``x - y``.\n\n.. deprecated:: 1.5\n\n   ``Eq(expr)`` with a single argument is a shorthand for ``Eq(expr, 0)``,\n   but this behavior is deprecated and will be removed in a future version\n   of SymPy.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.as_content_primitive",
              "name": "as_content_primitive"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.as_dummy",
              "name": "as_dummy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.as_poly",
              "name": "as_poly"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.as_set",
              "name": "as_set"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.atoms",
              "name": "atoms"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.class_key",
              "name": "class_key"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.compare",
              "name": "compare"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.copy",
              "name": "copy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.could_extract_minus_sign",
              "name": "could_extract_minus_sign"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Eq.count",
              "name": "count"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Equality",
          "name": "Equality",
          "description": "An equal relation between two objects.\n\nExplanation\n===========\n\nRepresents that two objects are equal.  If they can be easily shown\nto be definitively equal (or unequal), this will reduce to True (or\nFalse).  Otherwise, the relation is maintained as an unevaluated\nEquality object.  Use the ``simplify`` function on this object for\nmore nontrivial evaluation of the equality relation.\n\nAs usual, the keyword argument ``evaluate=False`` can be used to\nprevent any evaluation.\n\nExamples\n========\n\n>>> from sympy import Eq, simplify, exp, cos\n>>> from sympy.abc import x, y\n>>> Eq(y, x + x**2)\nEq(y, x**2 + x)\n>>> Eq(2, 5)\nFalse\n>>> Eq(2, 5, evaluate=False)\nEq(2, 5)\n>>> _.doit()\nFalse\n>>> Eq(exp(x), exp(x).rewrite(cos))\nEq(exp(x), sinh(x) + cosh(x))\n>>> simplify(_)\nTrue\n\nSee Also\n========\n\nsympy.logic.boolalg.Equivalent : for representing equality between two\n    boolean expressions\n\nNotes\n=====\n\nPython treats 1 and True (and 0 and False) as being equal; SymPy\ndoes not. And integer will always compare as unequal to a Boolean:\n\n>>> Eq(True, 1), True == 1\n(False, True)\n\nThis class is not the same as the == operator.  The == operator tests\nfor exact structural equality between two expressions; this class\ncompares expressions mathematically.\n\nIf either object defines an ``_eval_Eq`` method, it can be used in place of\nthe default algorithm.  If ``lhs._eval_Eq(rhs)`` or ``rhs._eval_Eq(lhs)``\nreturns anything other than None, that return value will be substituted for\nthe Equality.  If None is returned by ``_eval_Eq``, an Equality object will\nbe created as usual.\n\nSince this object is already an expression, it does not respond to\nthe method ``as_expr`` if one tries to create `x - y` from ``Eq(x, y)``.\nIf ``eq = Eq(x, y)`` then write `eq.lhs - eq.rhs` to get ``x - y``.\n\n.. deprecated:: 1.5\n\n   ``Eq(expr)`` with a single argument is a shorthand for ``Eq(expr, 0)``,\n   but this behavior is deprecated and will be removed in a future version\n   of SymPy.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.as_content_primitive",
              "name": "as_content_primitive"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.as_dummy",
              "name": "as_dummy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.as_poly",
              "name": "as_poly"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.as_set",
              "name": "as_set"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.atoms",
              "name": "atoms"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.class_key",
              "name": "class_key"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.compare",
              "name": "compare"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.copy",
              "name": "copy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.could_extract_minus_sign",
              "name": "could_extract_minus_sign"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Equality.count",
              "name": "count"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Expr",
          "name": "Expr",
          "description": "Base class for algebraic expressions.\n\nExplanation\n===========\n\nEverything that requires arithmetic operations to be defined\nshould subclass this class, instead of Basic (which should be\nused only for argument storage and expression manipulation, i.e.\npattern matching, substitutions, etc).\n\nIf you want to override the comparisons of expressions:\nShould use _eval_is_ge for inequality, or _eval_is_eq, with multiple dispatch.\n_eval_is_ge return true if x >= y, false if x < y, and None if the two types\nare not comparable or the comparison is indeterminate\n\nSee Also\n========\n\nsympy.core.basic.Basic",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Expr.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Float",
          "name": "Float",
          "description": "Represent a floating-point number of arbitrary precision.\n\nExamples\n========\n\n>>> from sympy import Float\n>>> Float(3.5)\n3.50000000000000\n>>> Float(3)\n3.00000000000000\n\nCreating Floats from strings (and Python ``int`` and ``long``\ntypes) will give a minimum precision of 15 digits, but the\nprecision will automatically increase to capture all digits\nentered.\n\n>>> Float(1)\n1.00000000000000\n>>> Float(10**20)\n100000000000000000000.\n>>> Float('1e20')\n100000000000000000000.\n\nHowever, *floating-point* numbers (Python ``float`` types) retain\nonly 15 digits of precision:\n\n>>> Float(1e20)\n1.00000000000000e+20\n>>> Float(1.23456789123456789)\n1.23456789123457\n\nIt may be preferable to enter high-precision decimal numbers\nas strings:\n\n>>> Float('1.23456789123456789')\n1.23456789123456789\n\nThe desired number of digits can also be specified:\n\n>>> Float('1e-3', 3)\n0.00100\n>>> Float(100, 4)\n100.0\n\nFloat can automatically count significant figures if a null string\nis sent for the precision; spaces or underscores are also allowed. (Auto-\ncounting is only allowed for strings, ints and longs).\n\n>>> Float('123 456 789.123_456', '')\n123456789.123456\n>>> Float('12e-3', '')\n0.012\n>>> Float(3, '')\n3.\n\nIf a number is written in scientific notation, only the digits before the\nexponent are considered significant if a decimal appears, otherwise the\n\"e\" signifies only how to move the decimal:\n\n>>> Float('60.e2', '')  # 2 digits significant\n6.0e+3\n>>> Float('60e2', '')  # 4 digits significant\n6000.\n>>> Float('600e-2', '')  # 3 digits significant\n6.00\n\nNotes\n=====\n\nFloats are inexact by their nature unless their value is a binary-exact\nvalue.\n\n>>> approx, exact = Float(.1, 1), Float(.125, 1)\n\nFor calculation purposes, evalf needs to be able to change the precision\nbut this will not increase the accuracy of the inexact value. The\nfollowing is the most accurate 5-digit approximation of a value of 0.1\nthat had only 1 digit of precision:\n\n>>> approx.evalf(5)\n0.099609\n\nBy contrast, 0.125 is exact in binary (as it is in base 10) and so it\ncan be passed to Float or evalf to obtain an arbitrary precision with\nmatching accuracy:\n\n>>> Float(exact, 5)\n0.12500\n>>> exact.evalf(20)\n0.12500000000000000000\n\nTrying to make a high-precision Float from a float is not disallowed,\nbut one must keep in mind that the *underlying float* (not the apparent\ndecimal value) is being obtained with high precision. For example, 0.3\ndoes not have a finite binary representation. The closest rational is\nthe fraction 5404319552844595/2**54. So if you try to obtain a Float of\n0.3 to 20 digits of precision you will not see the same thing as 0.3\nfollowed by 19 zeros:\n\n>>> Float(0.3, 20)\n0.29999999999999998890\n\nIf you want a 20-digit value of the decimal 0.3 (not the floating point\napproximation of 0.3) you should send the 0.3 as a string. The underlying\nrepresentation is still binary but a higher precision than Python's float\nis used:\n\n>>> Float('0.3', 20)\n0.30000000000000000000\n\nAlthough you can increase the precision of an existing Float using Float\nit will not increase the accuracy -- the underlying value is not changed:\n\n>>> def show(f): # binary rep of Float\n...     from sympy import Mul, Pow\n...     s, m, e, b = f._mpf_\n...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)\n...     print('%s at prec=%s' % (v, f._prec))\n...\n>>> t = Float('0.3', 3)\n>>> show(t)\n4915/2**14 at prec=13\n>>> show(Float(t, 20)) # higher prec, not higher accuracy\n4915/2**14 at prec=70\n>>> show(Float(t, 2)) # lower prec\n307/2**10 at prec=10\n\nThe same thing happens when evalf is used on a Float:\n\n>>> show(t.evalf(20))\n4915/2**14 at prec=70\n>>> show(t.evalf(2))\n307/2**10 at prec=10\n\nFinally, Floats can be instantiated with an mpf tuple (n, c, p) to\nproduce the number (-1)**n*c*2**p:\n\n>>> n, c, p = 1, 5, 0\n>>> (-1)**n*c*2**p\n-5\n>>> Float((1, 5, 0))\n-5.00000000000000\n\nAn actual mpf tuple also contains the number of bits in c as the last\nelement of the tuple:\n\n>>> _._mpf_\n(1, 5, 0, 3)\n\nThis is not needed for instantiation and is not the same thing as the\nprecision. The mpf tuple and the precision are two separate quantities\nthat Float tracks.\n\nIn SymPy, a Float is a number that can be computed with arbitrary\nprecision. Although floating point 'inf' and 'nan' are not such\nnumbers, Float can create these numbers:\n\n>>> Float('-inf')\n-oo\n>>> _.is_Float\nFalse\n\nZero in Float only has a single value. Values are not separate for\npositive and negative zeroes.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Float.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Function",
          "name": "Function",
          "description": "Base class for applied mathematical functions.\n\nIt also serves as a constructor for undefined function classes.\n\nSee the :ref:`custom-functions` guide for details on how to subclass\n``Function`` and what methods can be defined.\n\nExamples\n========\n\n**Undefined Functions**\n\nTo create an undefined function, pass a string of the function name to\n``Function``.\n\n>>> from sympy import Function, Symbol\n>>> x = Symbol('x')\n>>> f = Function('f')\n>>> g = Function('g')(x)\n>>> f\nf\n>>> f(x)\nf(x)\n>>> g\ng(x)\n>>> f(x).diff(x)\nDerivative(f(x), x)\n>>> g.diff(x)\nDerivative(g(x), x)\n\nAssumptions can be passed to ``Function`` the same as with a\n:class:`~.Symbol`. Alternatively, you can use a ``Symbol`` with\nassumptions for the function name and the function will inherit the name\nand assumptions associated with the ``Symbol``:\n\n>>> f_real = Function('f', real=True)\n>>> f_real(x).is_real\nTrue\n>>> f_real_inherit = Function(Symbol('f', real=True))\n>>> f_real_inherit(x).is_real\nTrue\n\nNote that assumptions on a function are unrelated to the assumptions on\nthe variables it is called on. If you want to add a relationship, subclass\n``Function`` and define custom assumptions handler methods. See the\n:ref:`custom-functions-assumptions` section of the :ref:`custom-functions`\nguide for more details.\n\n**Custom Function Subclasses**\n\nThe :ref:`custom-functions` guide has several\n:ref:`custom-functions-complete-examples` of how to subclass ``Function``\nto create a custom function.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Function.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.FunctionClass",
          "name": "FunctionClass",
          "description": "Base class for function classes. FunctionClass is a subclass of type.\n\nUse Function('<function name>' [ , signature ]) to create\nundefined function classes.",
          "methods": []
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Ge",
          "name": "Ge",
          "description": "Class representations of inequalities.\n\nExplanation\n===========\n\nThe ``*Than`` classes represent inequal relationships, where the left-hand\nside is generally bigger or smaller than the right-hand side.  For example,\nthe GreaterThan class represents an inequal relationship where the\nleft-hand side is at least as big as the right side, if not bigger.  In\nmathematical notation:\n\nlhs $\\ge$ rhs\n\nIn total, there are four ``*Than`` classes, to represent the four\ninequalities:\n\n+-----------------+--------+\n|Class Name       | Symbol |\n+=================+========+\n|GreaterThan      | ``>=`` |\n+-----------------+--------+\n|LessThan         | ``<=`` |\n+-----------------+--------+\n|StrictGreaterThan| ``>``  |\n+-----------------+--------+\n|StrictLessThan   | ``<``  |\n+-----------------+--------+\n\nAll classes take two arguments, lhs and rhs.\n\n+----------------------------+-----------------+\n|Signature Example           | Math Equivalent |\n+============================+=================+\n|GreaterThan(lhs, rhs)       |   lhs $\\ge$ rhs |\n+----------------------------+-----------------+\n|LessThan(lhs, rhs)          |   lhs $\\le$ rhs |\n+----------------------------+-----------------+\n|StrictGreaterThan(lhs, rhs) |   lhs $>$ rhs   |\n+----------------------------+-----------------+\n|StrictLessThan(lhs, rhs)    |   lhs $<$ rhs   |\n+----------------------------+-----------------+\n\nIn addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality\nobjects also have the .lts and .gts properties, which represent the \"less\nthan side\" and \"greater than side\" of the operator.  Use of .lts and .gts\nin an algorithm rather than .lhs and .rhs as an assumption of inequality\ndirection will make more explicit the intent of a certain section of code,\nand will make it similarly more robust to client code changes:\n\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational\n\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x'\n\nExamples\n========\n\nOne generally does not instantiate these classes directly, but uses various\nconvenience methods:\n\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2\n\nAnother option is to use the Python inequality operators (``>=``, ``>``,\n``<=``, ``<``) directly.  Their main advantage over the ``Ge``, ``Gt``,\n``Le``, and ``Lt`` counterparts, is that one can write a more\n\"mathematical looking\" statement rather than littering the math with\noddball function calls.  However there are certain (minor) caveats of\nwhich to be aware (search for 'gotcha', below).\n\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue\n\nHowever, it is also perfectly valid to instantiate a ``*Than`` class less\nsuccinctly and less conveniently:\n\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1\n\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1\n\nNotes\n=====\n\nThere are a couple of \"gotchas\" to be aware of when using Python's\noperators.\n\nThe first is that what your write is not always what you get:\n\n    >>> 1 < x\n    x > 1\n\n    Due to the order that Python parses a statement, it may\n    not immediately find two objects comparable.  When ``1 < x``\n    is evaluated, Python recognizes that the number 1 is a native\n    number and that x is *not*.  Because a native Python number does\n    not know how to compare itself with a SymPy object\n    Python will try the reflective operation, ``x > 1`` and that is the\n    form that gets evaluated, hence returned.\n\n    If the order of the statement is important (for visual output to\n    the console, perhaps), one can work around this annoyance in a\n    couple ways:\n\n    (1) \"sympify\" the literal before comparison\n\n    >>> S(1) < x\n    1 < x\n\n    (2) use one of the wrappers or less succinct methods described\n    above\n\n    >>> Lt(1, x)\n    1 < x\n    >>> Relational(1, x, \"<\")\n    1 < x\n\nThe second gotcha involves writing equality tests between relationals\nwhen one or both sides of the test involve a literal relational:\n\n    >>> e = x < 1; e\n    x < 1\n    >>> e == e  # neither side is a literal\n    True\n    >>> e == x < 1  # expecting True, too\n    False\n    >>> e != x < 1  # expecting False\n    x < 1\n    >>> x < 1 != x < 1  # expecting False or the same thing as before\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n    The solution for this case is to wrap literal relationals in\n    parentheses:\n\n    >>> e == (x < 1)\n    True\n    >>> e != (x < 1)\n    False\n    >>> (x < 1) != (x < 1)\n    False\n\nThe third gotcha involves chained inequalities not involving\n``==`` or ``!=``. Occasionally, one may be tempted to write:\n\n    >>> e = x < y < z\n    Traceback (most recent call last):\n    ...\n    TypeError: symbolic boolean expression has no truth value.\n\n    Due to an implementation detail or decision of Python [1]_,\n    there is no way for SymPy to create a chained inequality with\n    that syntax so one must use And:\n\n    >>> e = And(x < y, y < z)\n    >>> type( e )\n    And\n    >>> e\n    (x < y) & (y < z)\n\n    Although this can also be done with the '&' operator, it cannot\n    be done with the 'and' operarator:\n\n    >>> (x < y) & (y < z)\n    (x < y) & (y < z)\n    >>> (x < y) and (y < z)\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n.. [1] This implementation detail is that Python provides no reliable\n   method to determine that a chained inequality is being built.\n   Chained comparison operators are evaluated pairwise, using \"and\"\n   logic (see\n   https://docs.python.org/3/reference/expressions.html#not-in). This\n   is done in an efficient way, so that each object being compared\n   is only evaluated once and the comparison can short-circuit. For\n   example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2\n   > 3)``. The ``and`` operator coerces each side into a bool,\n   returning the object itself when it short-circuits. The bool of\n   the --Than operators will raise TypeError on purpose, because\n   SymPy cannot determine the mathematical ordering of symbolic\n   expressions. Thus, if we were to compute ``x > y > z``, with\n   ``x``, ``y``, and ``z`` being Symbols, Python converts the\n   statement (roughly) into these steps:\n\n    (1) x > y > z\n    (2) (x > y) and (y > z)\n    (3) (GreaterThanObject) and (y > z)\n    (4) (GreaterThanObject.__bool__()) and (y > z)\n    (5) TypeError\n\n   Because of the ``and`` added at step 2, the statement gets turned into a\n   weak ternary statement, and the first object's ``__bool__`` method will\n   raise TypeError.  Thus, creating a chained inequality is not possible.\n\n       In Python, there is no way to override the ``and`` operator, or to\n       control how it short circuits, so it is impossible to make something\n       like ``x > y > z`` work.  There was a PEP to change this,\n       :pep:`335`, but it was officially closed in March, 2012.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.as_content_primitive",
              "name": "as_content_primitive"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.as_dummy",
              "name": "as_dummy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.as_set",
              "name": "as_set"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.atoms",
              "name": "atoms"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.class_key",
              "name": "class_key"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.compare",
              "name": "compare"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.copy",
              "name": "copy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.could_extract_minus_sign",
              "name": "could_extract_minus_sign"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.count",
              "name": "count"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Ge.count_ops",
              "name": "count_ops"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.GreaterThan",
          "name": "GreaterThan",
          "description": "Class representations of inequalities.\n\nExplanation\n===========\n\nThe ``*Than`` classes represent inequal relationships, where the left-hand\nside is generally bigger or smaller than the right-hand side.  For example,\nthe GreaterThan class represents an inequal relationship where the\nleft-hand side is at least as big as the right side, if not bigger.  In\nmathematical notation:\n\nlhs $\\ge$ rhs\n\nIn total, there are four ``*Than`` classes, to represent the four\ninequalities:\n\n+-----------------+--------+\n|Class Name       | Symbol |\n+=================+========+\n|GreaterThan      | ``>=`` |\n+-----------------+--------+\n|LessThan         | ``<=`` |\n+-----------------+--------+\n|StrictGreaterThan| ``>``  |\n+-----------------+--------+\n|StrictLessThan   | ``<``  |\n+-----------------+--------+\n\nAll classes take two arguments, lhs and rhs.\n\n+----------------------------+-----------------+\n|Signature Example           | Math Equivalent |\n+============================+=================+\n|GreaterThan(lhs, rhs)       |   lhs $\\ge$ rhs |\n+----------------------------+-----------------+\n|LessThan(lhs, rhs)          |   lhs $\\le$ rhs |\n+----------------------------+-----------------+\n|StrictGreaterThan(lhs, rhs) |   lhs $>$ rhs   |\n+----------------------------+-----------------+\n|StrictLessThan(lhs, rhs)    |   lhs $<$ rhs   |\n+----------------------------+-----------------+\n\nIn addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality\nobjects also have the .lts and .gts properties, which represent the \"less\nthan side\" and \"greater than side\" of the operator.  Use of .lts and .gts\nin an algorithm rather than .lhs and .rhs as an assumption of inequality\ndirection will make more explicit the intent of a certain section of code,\nand will make it similarly more robust to client code changes:\n\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational\n\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x'\n\nExamples\n========\n\nOne generally does not instantiate these classes directly, but uses various\nconvenience methods:\n\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2\n\nAnother option is to use the Python inequality operators (``>=``, ``>``,\n``<=``, ``<``) directly.  Their main advantage over the ``Ge``, ``Gt``,\n``Le``, and ``Lt`` counterparts, is that one can write a more\n\"mathematical looking\" statement rather than littering the math with\noddball function calls.  However there are certain (minor) caveats of\nwhich to be aware (search for 'gotcha', below).\n\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue\n\nHowever, it is also perfectly valid to instantiate a ``*Than`` class less\nsuccinctly and less conveniently:\n\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1\n\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1\n\nNotes\n=====\n\nThere are a couple of \"gotchas\" to be aware of when using Python's\noperators.\n\nThe first is that what your write is not always what you get:\n\n    >>> 1 < x\n    x > 1\n\n    Due to the order that Python parses a statement, it may\n    not immediately find two objects comparable.  When ``1 < x``\n    is evaluated, Python recognizes that the number 1 is a native\n    number and that x is *not*.  Because a native Python number does\n    not know how to compare itself with a SymPy object\n    Python will try the reflective operation, ``x > 1`` and that is the\n    form that gets evaluated, hence returned.\n\n    If the order of the statement is important (for visual output to\n    the console, perhaps), one can work around this annoyance in a\n    couple ways:\n\n    (1) \"sympify\" the literal before comparison\n\n    >>> S(1) < x\n    1 < x\n\n    (2) use one of the wrappers or less succinct methods described\n    above\n\n    >>> Lt(1, x)\n    1 < x\n    >>> Relational(1, x, \"<\")\n    1 < x\n\nThe second gotcha involves writing equality tests between relationals\nwhen one or both sides of the test involve a literal relational:\n\n    >>> e = x < 1; e\n    x < 1\n    >>> e == e  # neither side is a literal\n    True\n    >>> e == x < 1  # expecting True, too\n    False\n    >>> e != x < 1  # expecting False\n    x < 1\n    >>> x < 1 != x < 1  # expecting False or the same thing as before\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n    The solution for this case is to wrap literal relationals in\n    parentheses:\n\n    >>> e == (x < 1)\n    True\n    >>> e != (x < 1)\n    False\n    >>> (x < 1) != (x < 1)\n    False\n\nThe third gotcha involves chained inequalities not involving\n``==`` or ``!=``. Occasionally, one may be tempted to write:\n\n    >>> e = x < y < z\n    Traceback (most recent call last):\n    ...\n    TypeError: symbolic boolean expression has no truth value.\n\n    Due to an implementation detail or decision of Python [1]_,\n    there is no way for SymPy to create a chained inequality with\n    that syntax so one must use And:\n\n    >>> e = And(x < y, y < z)\n    >>> type( e )\n    And\n    >>> e\n    (x < y) & (y < z)\n\n    Although this can also be done with the '&' operator, it cannot\n    be done with the 'and' operarator:\n\n    >>> (x < y) & (y < z)\n    (x < y) & (y < z)\n    >>> (x < y) and (y < z)\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n.. [1] This implementation detail is that Python provides no reliable\n   method to determine that a chained inequality is being built.\n   Chained comparison operators are evaluated pairwise, using \"and\"\n   logic (see\n   https://docs.python.org/3/reference/expressions.html#not-in). This\n   is done in an efficient way, so that each object being compared\n   is only evaluated once and the comparison can short-circuit. For\n   example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2\n   > 3)``. The ``and`` operator coerces each side into a bool,\n   returning the object itself when it short-circuits. The bool of\n   the --Than operators will raise TypeError on purpose, because\n   SymPy cannot determine the mathematical ordering of symbolic\n   expressions. Thus, if we were to compute ``x > y > z``, with\n   ``x``, ``y``, and ``z`` being Symbols, Python converts the\n   statement (roughly) into these steps:\n\n    (1) x > y > z\n    (2) (x > y) and (y > z)\n    (3) (GreaterThanObject) and (y > z)\n    (4) (GreaterThanObject.__bool__()) and (y > z)\n    (5) TypeError\n\n   Because of the ``and`` added at step 2, the statement gets turned into a\n   weak ternary statement, and the first object's ``__bool__`` method will\n   raise TypeError.  Thus, creating a chained inequality is not possible.\n\n       In Python, there is no way to override the ``and`` operator, or to\n       control how it short circuits, so it is impossible to make something\n       like ``x > y > z`` work.  There was a PEP to change this,\n       :pep:`335`, but it was officially closed in March, 2012.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.as_content_primitive",
              "name": "as_content_primitive"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.as_dummy",
              "name": "as_dummy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.as_set",
              "name": "as_set"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.atoms",
              "name": "atoms"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.class_key",
              "name": "class_key"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.compare",
              "name": "compare"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.copy",
              "name": "copy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.could_extract_minus_sign",
              "name": "could_extract_minus_sign"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.count",
              "name": "count"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.GreaterThan.count_ops",
              "name": "count_ops"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Gt",
          "name": "Gt",
          "description": "Class representations of inequalities.\n\nExplanation\n===========\n\nThe ``*Than`` classes represent inequal relationships, where the left-hand\nside is generally bigger or smaller than the right-hand side.  For example,\nthe GreaterThan class represents an inequal relationship where the\nleft-hand side is at least as big as the right side, if not bigger.  In\nmathematical notation:\n\nlhs $\\ge$ rhs\n\nIn total, there are four ``*Than`` classes, to represent the four\ninequalities:\n\n+-----------------+--------+\n|Class Name       | Symbol |\n+=================+========+\n|GreaterThan      | ``>=`` |\n+-----------------+--------+\n|LessThan         | ``<=`` |\n+-----------------+--------+\n|StrictGreaterThan| ``>``  |\n+-----------------+--------+\n|StrictLessThan   | ``<``  |\n+-----------------+--------+\n\nAll classes take two arguments, lhs and rhs.\n\n+----------------------------+-----------------+\n|Signature Example           | Math Equivalent |\n+============================+=================+\n|GreaterThan(lhs, rhs)       |   lhs $\\ge$ rhs |\n+----------------------------+-----------------+\n|LessThan(lhs, rhs)          |   lhs $\\le$ rhs |\n+----------------------------+-----------------+\n|StrictGreaterThan(lhs, rhs) |   lhs $>$ rhs   |\n+----------------------------+-----------------+\n|StrictLessThan(lhs, rhs)    |   lhs $<$ rhs   |\n+----------------------------+-----------------+\n\nIn addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality\nobjects also have the .lts and .gts properties, which represent the \"less\nthan side\" and \"greater than side\" of the operator.  Use of .lts and .gts\nin an algorithm rather than .lhs and .rhs as an assumption of inequality\ndirection will make more explicit the intent of a certain section of code,\nand will make it similarly more robust to client code changes:\n\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational\n\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x'\n\nExamples\n========\n\nOne generally does not instantiate these classes directly, but uses various\nconvenience methods:\n\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2\n\nAnother option is to use the Python inequality operators (``>=``, ``>``,\n``<=``, ``<``) directly.  Their main advantage over the ``Ge``, ``Gt``,\n``Le``, and ``Lt`` counterparts, is that one can write a more\n\"mathematical looking\" statement rather than littering the math with\noddball function calls.  However there are certain (minor) caveats of\nwhich to be aware (search for 'gotcha', below).\n\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue\n\nHowever, it is also perfectly valid to instantiate a ``*Than`` class less\nsuccinctly and less conveniently:\n\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1\n\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1\n\nNotes\n=====\n\nThere are a couple of \"gotchas\" to be aware of when using Python's\noperators.\n\nThe first is that what your write is not always what you get:\n\n    >>> 1 < x\n    x > 1\n\n    Due to the order that Python parses a statement, it may\n    not immediately find two objects comparable.  When ``1 < x``\n    is evaluated, Python recognizes that the number 1 is a native\n    number and that x is *not*.  Because a native Python number does\n    not know how to compare itself with a SymPy object\n    Python will try the reflective operation, ``x > 1`` and that is the\n    form that gets evaluated, hence returned.\n\n    If the order of the statement is important (for visual output to\n    the console, perhaps), one can work around this annoyance in a\n    couple ways:\n\n    (1) \"sympify\" the literal before comparison\n\n    >>> S(1) < x\n    1 < x\n\n    (2) use one of the wrappers or less succinct methods described\n    above\n\n    >>> Lt(1, x)\n    1 < x\n    >>> Relational(1, x, \"<\")\n    1 < x\n\nThe second gotcha involves writing equality tests between relationals\nwhen one or both sides of the test involve a literal relational:\n\n    >>> e = x < 1; e\n    x < 1\n    >>> e == e  # neither side is a literal\n    True\n    >>> e == x < 1  # expecting True, too\n    False\n    >>> e != x < 1  # expecting False\n    x < 1\n    >>> x < 1 != x < 1  # expecting False or the same thing as before\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n    The solution for this case is to wrap literal relationals in\n    parentheses:\n\n    >>> e == (x < 1)\n    True\n    >>> e != (x < 1)\n    False\n    >>> (x < 1) != (x < 1)\n    False\n\nThe third gotcha involves chained inequalities not involving\n``==`` or ``!=``. Occasionally, one may be tempted to write:\n\n    >>> e = x < y < z\n    Traceback (most recent call last):\n    ...\n    TypeError: symbolic boolean expression has no truth value.\n\n    Due to an implementation detail or decision of Python [1]_,\n    there is no way for SymPy to create a chained inequality with\n    that syntax so one must use And:\n\n    >>> e = And(x < y, y < z)\n    >>> type( e )\n    And\n    >>> e\n    (x < y) & (y < z)\n\n    Although this can also be done with the '&' operator, it cannot\n    be done with the 'and' operarator:\n\n    >>> (x < y) & (y < z)\n    (x < y) & (y < z)\n    >>> (x < y) and (y < z)\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n.. [1] This implementation detail is that Python provides no reliable\n   method to determine that a chained inequality is being built.\n   Chained comparison operators are evaluated pairwise, using \"and\"\n   logic (see\n   https://docs.python.org/3/reference/expressions.html#not-in). This\n   is done in an efficient way, so that each object being compared\n   is only evaluated once and the comparison can short-circuit. For\n   example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2\n   > 3)``. The ``and`` operator coerces each side into a bool,\n   returning the object itself when it short-circuits. The bool of\n   the --Than operators will raise TypeError on purpose, because\n   SymPy cannot determine the mathematical ordering of symbolic\n   expressions. Thus, if we were to compute ``x > y > z``, with\n   ``x``, ``y``, and ``z`` being Symbols, Python converts the\n   statement (roughly) into these steps:\n\n    (1) x > y > z\n    (2) (x > y) and (y > z)\n    (3) (GreaterThanObject) and (y > z)\n    (4) (GreaterThanObject.__bool__()) and (y > z)\n    (5) TypeError\n\n   Because of the ``and`` added at step 2, the statement gets turned into a\n   weak ternary statement, and the first object's ``__bool__`` method will\n   raise TypeError.  Thus, creating a chained inequality is not possible.\n\n       In Python, there is no way to override the ``and`` operator, or to\n       control how it short circuits, so it is impossible to make something\n       like ``x > y > z`` work.  There was a PEP to change this,\n       :pep:`335`, but it was officially closed in March, 2012.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.as_content_primitive",
              "name": "as_content_primitive"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.as_dummy",
              "name": "as_dummy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.as_set",
              "name": "as_set"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.atoms",
              "name": "atoms"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.class_key",
              "name": "class_key"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.compare",
              "name": "compare"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.copy",
              "name": "copy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.could_extract_minus_sign",
              "name": "could_extract_minus_sign"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.count",
              "name": "count"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Gt.count_ops",
              "name": "count_ops"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Integer",
          "name": "Integer",
          "description": "Represents integer numbers of any size.\n\nExamples\n========\n\n>>> from sympy import Integer\n>>> Integer(3)\n3\n\nIf a float or a rational is passed to Integer, the fractional part\nwill be discarded; the effect is of rounding toward zero.\n\n>>> Integer(3.8)\n3\n>>> Integer(-3.8)\n-3\n\nA string is acceptable input if it can be parsed as an integer:\n\n>>> Integer(\"9\" * 20)\n99999999999999999999\n\nIt is rarely needed to explicitly instantiate an Integer, because\nPython integers are automatically converted to Integer when they\nare used in SymPy expressions.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Integer.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Lambda",
          "name": "Lambda",
          "description": "Lambda(x, expr) represents a lambda function similar to Python's\n'lambda x: expr'. A function of several variables is written as\nLambda((x, y, ...), expr).\n\nExamples\n========\n\nA simple example:\n\n>>> from sympy import Lambda\n>>> from sympy.abc import x\n>>> f = Lambda(x, x**2)\n>>> f(4)\n16\n\nFor multivariate functions, use:\n\n>>> from sympy.abc import y, z, t\n>>> f2 = Lambda((x, y, z, t), x + y**z + t**z)\n>>> f2(1, 2, 3, 4)\n73\n\nIt is also possible to unpack tuple arguments:\n\n>>> f = Lambda(((x, y), z), x + y + z)\n>>> f((1, 2), 3)\n6\n\nA handy shortcut for lots of arguments:\n\n>>> p = x, y, z\n>>> f = Lambda(p, x + y*z)\n>>> f(*p)\nx + y*z",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Lambda.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.core.Le",
          "name": "Le",
          "description": "Class representations of inequalities.\n\nExplanation\n===========\n\nThe ``*Than`` classes represent inequal relationships, where the left-hand\nside is generally bigger or smaller than the right-hand side.  For example,\nthe GreaterThan class represents an inequal relationship where the\nleft-hand side is at least as big as the right side, if not bigger.  In\nmathematical notation:\n\nlhs $\\ge$ rhs\n\nIn total, there are four ``*Than`` classes, to represent the four\ninequalities:\n\n+-----------------+--------+\n|Class Name       | Symbol |\n+=================+========+\n|GreaterThan      | ``>=`` |\n+-----------------+--------+\n|LessThan         | ``<=`` |\n+-----------------+--------+\n|StrictGreaterThan| ``>``  |\n+-----------------+--------+\n|StrictLessThan   | ``<``  |\n+-----------------+--------+\n\nAll classes take two arguments, lhs and rhs.\n\n+----------------------------+-----------------+\n|Signature Example           | Math Equivalent |\n+============================+=================+\n|GreaterThan(lhs, rhs)       |   lhs $\\ge$ rhs |\n+----------------------------+-----------------+\n|LessThan(lhs, rhs)          |   lhs $\\le$ rhs |\n+----------------------------+-----------------+\n|StrictGreaterThan(lhs, rhs) |   lhs $>$ rhs   |\n+----------------------------+-----------------+\n|StrictLessThan(lhs, rhs)    |   lhs $<$ rhs   |\n+----------------------------+-----------------+\n\nIn addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality\nobjects also have the .lts and .gts properties, which represent the \"less\nthan side\" and \"greater than side\" of the operator.  Use of .lts and .gts\nin an algorithm rather than .lhs and .rhs as an assumption of inequality\ndirection will make more explicit the intent of a certain section of code,\nand will make it similarly more robust to client code changes:\n\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational\n\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x'\n\nExamples\n========\n\nOne generally does not instantiate these classes directly, but uses various\nconvenience methods:\n\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2\n\nAnother option is to use the Python inequality operators (``>=``, ``>``,\n``<=``, ``<``) directly.  Their main advantage over the ``Ge``, ``Gt``,\n``Le``, and ``Lt`` counterparts, is that one can write a more\n\"mathematical looking\" statement rather than littering the math with\noddball function calls.  However there are certain (minor) caveats of\nwhich to be aware (search for 'gotcha', below).\n\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue\n\nHowever, it is also perfectly valid to instantiate a ``*Than`` class less\nsuccinctly and less conveniently:\n\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1\n\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1\n\nNotes\n=====\n\nThere are a couple of \"gotchas\" to be aware of when using Python's\noperators.\n\nThe first is that what your write is not always what you get:\n\n    >>> 1 < x\n    x > 1\n\n    Due to the order that Python parses a statement, it may\n    not immediately find two objects comparable.  When ``1 < x``\n    is evaluated, Python recognizes that the number 1 is a native\n    number and that x is *not*.  Because a native Python number does\n    not know how to compare itself with a SymPy object\n    Python will try the reflective operation, ``x > 1`` and that is the\n    form that gets evaluated, hence returned.\n\n    If the order of the statement is important (for visual output to\n    the console, perhaps), one can work around this annoyance in a\n    couple ways:\n\n    (1) \"sympify\" the literal before comparison\n\n    >>> S(1) < x\n    1 < x\n\n    (2) use one of the wrappers or less succinct methods described\n    above\n\n    >>> Lt(1, x)\n    1 < x\n    >>> Relational(1, x, \"<\")\n    1 < x\n\nThe second gotcha involves writing equality tests between relationals\nwhen one or both sides of the test involve a literal relational:\n\n    >>> e = x < 1; e\n    x < 1\n    >>> e == e  # neither side is a literal\n    True\n    >>> e == x < 1  # expecting True, too\n    False\n    >>> e != x < 1  # expecting False\n    x < 1\n    >>> x < 1 != x < 1  # expecting False or the same thing as before\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n    The solution for this case is to wrap literal relationals in\n    parentheses:\n\n    >>> e == (x < 1)\n    True\n    >>> e != (x < 1)\n    False\n    >>> (x < 1) != (x < 1)\n    False\n\nThe third gotcha involves chained inequalities not involving\n``==`` or ``!=``. Occasionally, one may be tempted to write:\n\n    >>> e = x < y < z\n    Traceback (most recent call last):\n    ...\n    TypeError: symbolic boolean expression has no truth value.\n\n    Due to an implementation detail or decision of Python [1]_,\n    there is no way for SymPy to create a chained inequality with\n    that syntax so one must use And:\n\n    >>> e = And(x < y, y < z)\n    >>> type( e )\n    And\n    >>> e\n    (x < y) & (y < z)\n\n    Although this can also be done with the '&' operator, it cannot\n    be done with the 'and' operarator:\n\n    >>> (x < y) & (y < z)\n    (x < y) & (y < z)\n    >>> (x < y) and (y < z)\n    Traceback (most recent call last):\n    ...\n    TypeError: cannot determine truth value of Relational\n\n.. [1] This implementation detail is that Python provides no reliable\n   method to determine that a chained inequality is being built.\n   Chained comparison operators are evaluated pairwise, using \"and\"\n   logic (see\n   https://docs.python.org/3/reference/expressions.html#not-in). This\n   is done in an efficient way, so that each object being compared\n   is only evaluated once and the comparison can short-circuit. For\n   example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2\n   > 3)``. The ``and`` operator coerces each side into a bool,\n   returning the object itself when it short-circuits. The bool of\n   the --Than operators will raise TypeError on purpose, because\n   SymPy cannot determine the mathematical ordering of symbolic\n   expressions. Thus, if we were to compute ``x > y > z``, with\n   ``x``, ``y``, and ``z`` being Symbols, Python converts the\n   statement (roughly) into these steps:\n\n    (1) x > y > z\n    (2) (x > y) and (y > z)\n    (3) (GreaterThanObject) and (y > z)\n    (4) (GreaterThanObject.__bool__()) and (y > z)\n    (5) TypeError\n\n   Because of the ``and`` added at step 2, the statement gets turned into a\n   weak ternary statement, and the first object's ``__bool__`` method will\n   raise TypeError.  Thus, creating a chained inequality is not possible.\n\n       In Python, there is no way to override the ``and`` operator, or to\n       control how it short circuits, so it is impossible to make something\n       like ``x > y > z`` work.  There was a PEP to change this,\n       :pep:`335`, but it was officially closed in March, 2012.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.as_content_primitive",
              "name": "as_content_primitive"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.as_dummy",
              "name": "as_dummy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.as_set",
              "name": "as_set"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.atoms",
              "name": "atoms"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.class_key",
              "name": "class_key"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.compare",
              "name": "compare"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.copy",
              "name": "copy"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.could_extract_minus_sign",
              "name": "could_extract_minus_sign"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.count",
              "name": "count"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.core.Le.count_ops",
              "name": "count_ops"
            }
          ]
        }
      ]
    },
    {
      "@type": "SoftwareApplication",
      "@id": "sympy:sympy.functions",
      "name": "sympy.functions",
      "applicationCategory": "Mathematical Software",
      "classes": [
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Abs",
          "name": "Abs",
          "description": "Return the absolute value of the argument.\n\nExplanation\n===========\n\nThis is an extension of the built-in function ``abs()`` to accept symbolic\nvalues.  If you pass a SymPy expression to the built-in ``abs()``, it will\npass it automatically to ``Abs()``.\n\nExamples\n========\n\n>>> from sympy import Abs, Symbol, S, I\n>>> Abs(-1)\n1\n>>> x = Symbol('x', real=True)\n>>> Abs(-x)\nAbs(x)\n>>> Abs(x**2)\nx**2\n>>> abs(-x) # The Python built-in\nAbs(x)\n>>> Abs(3*x + 2*I)\nsqrt(9*x**2 + 4)\n>>> Abs(8*I)\n8\n\nNote that the Python built-in will return either an Expr or int depending on\nthe argument::\n\n    >>> type(abs(-1))\n    <... 'int'>\n    >>> type(abs(S.NegativeOne))\n    <class 'sympy.core.numbers.One'>\n\nAbs will always return a SymPy object.\n\nParameters\n==========\n\narg : Expr\n    Real or complex expression.\n\nReturns\n=======\n\nexpr : Expr\n    Absolute value returned can be an expression or integer depending on\n    input arg.\n\nSee Also\n========\n\nsign, conjugate",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Abs.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Chi",
          "name": "Chi",
          "description": "Cosh integral.\n\nExplanation\n===========\n\nThis function is defined for positive $x$ by\n\n.. math:: \\operatorname{Chi}(x) = \\gamma + \\log{x}\n                     + \\int_0^x \\frac{\\cosh{t} - 1}{t} \\mathrm{d}t,\n\nwhere $\\gamma$ is the Euler-Mascheroni constant.\n\nWe have\n\n.. math:: \\operatorname{Chi}(z) = \\operatorname{Ci}\\left(e^{i \\pi/2}z\\right)\n                     - i\\frac{\\pi}{2},\n\nwhich holds for all polar $z$ and thus provides an analytic\ncontinuation to the Riemann surface of the logarithm.\nBy lifting to the principal branch we obtain an analytic function on the\ncut complex plane.\n\nExamples\n========\n\n>>> from sympy import Chi\n>>> from sympy.abc import z\n\nThe $\\cosh$ integral is a primitive of $\\cosh(z)/z$:\n\n>>> Chi(z).diff(z)\ncosh(z)/z\n\nIt has a logarithmic branch point at the origin:\n\n>>> from sympy import exp_polar, I, pi\n>>> Chi(z*exp_polar(2*I*pi))\nChi(z) + 2*I*pi\n\nThe $\\cosh$ integral behaves somewhat like ordinary $\\cosh$ under\nmultiplication by $i$:\n\n>>> from sympy import polar_lift\n>>> Chi(polar_lift(I)*z)\nCi(z) + I*pi/2\n>>> Chi(polar_lift(-1)*z)\nChi(z) + I*pi\n\nIt can also be expressed in terms of exponential integrals:\n\n>>> from sympy import expint\n>>> Chi(z).rewrite(expint)\n-expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2\n\nSee Also\n========\n\nSi: Sine integral.\nCi: Cosine integral.\nShi: Hyperbolic sine integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Trigonometric_integral",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Chi.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Ci",
          "name": "Ci",
          "description": "Cosine integral.\n\nExplanation\n===========\n\nThis function is defined for positive $x$ by\n\n.. math:: \\operatorname{Ci}(x) = \\gamma + \\log{x}\n                     + \\int_0^x \\frac{\\cos{t} - 1}{t} \\mathrm{d}t\n       = -\\int_x^\\infty \\frac{\\cos{t}}{t} \\mathrm{d}t,\n\nwhere $\\gamma$ is the Euler-Mascheroni constant.\n\nWe have\n\n.. math:: \\operatorname{Ci}(z) =\n    -\\frac{\\operatorname{E}_1\\left(e^{i\\pi/2} z\\right)\n           + \\operatorname{E}_1\\left(e^{-i \\pi/2} z\\right)}{2}\n\nwhich holds for all polar $z$ and thus provides an analytic\ncontinuation to the Riemann surface of the logarithm.\n\nThe formula also holds as stated\nfor $z \\in \\mathbb{C}$ with $\\Re(z) > 0$.\nBy lifting to the principal branch, we obtain an analytic function on the\ncut complex plane.\n\nExamples\n========\n\n>>> from sympy import Ci\n>>> from sympy.abc import z\n\nThe cosine integral is a primitive of $\\cos(z)/z$:\n\n>>> Ci(z).diff(z)\ncos(z)/z\n\nIt has a logarithmic branch point at the origin:\n\n>>> from sympy import exp_polar, I, pi\n>>> Ci(z*exp_polar(2*I*pi))\nCi(z) + 2*I*pi\n\nThe cosine integral behaves somewhat like ordinary $\\cos$ under\nmultiplication by $i$:\n\n>>> from sympy import polar_lift\n>>> Ci(polar_lift(I)*z)\nChi(z) + I*pi/2\n>>> Ci(polar_lift(-1)*z)\nCi(z) + I*pi\n\nIt can also be expressed in terms of exponential integrals:\n\n>>> from sympy import expint\n>>> Ci(z).rewrite(expint)\n-expint(1, z*exp_polar(-I*pi/2))/2 - expint(1, z*exp_polar(I*pi/2))/2\n\nSee Also\n========\n\nSi: Sine integral.\nShi: Hyperbolic sine integral.\nChi: Hyperbolic cosine integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Trigonometric_integral",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ci.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.DiracDelta",
          "name": "DiracDelta",
          "description": "The DiracDelta function and its derivatives.\n\nExplanation\n===========\n\nDiracDelta is not an ordinary function. It can be rigorously defined either\nas a distribution or as a measure.\n\nDiracDelta only makes sense in definite integrals, and in particular,\nintegrals of the form ``Integral(f(x)*DiracDelta(x - x0), (x, a, b))``,\nwhere it equals ``f(x0)`` if ``a <= x0 <= b`` and ``0`` otherwise. Formally,\nDiracDelta acts in some ways like a function that is ``0`` everywhere except\nat ``0``, but in many ways it also does not. It can often be useful to treat\nDiracDelta in formal ways, building up and manipulating expressions with\ndelta functions (which may eventually be integrated), but care must be taken\nto not treat it as a real function. SymPy's ``oo`` is similar. It only\ntruly makes sense formally in certain contexts (such as integration limits),\nbut SymPy allows its use everywhere, and it tries to be consistent with\noperations on it (like ``1/oo``), but it is easy to get into trouble and get\nwrong results if ``oo`` is treated too much like a number. Similarly, if\nDiracDelta is treated too much like a function, it is easy to get wrong or\nnonsensical results.\n\nDiracDelta function has the following properties:\n\n1) $\\frac{d}{d x} \\theta(x) = \\delta(x)$\n2) $\\int_{-\\infty}^\\infty \\delta(x - a)f(x)\\, dx = f(a)$ and $\\int_{a-\n   \\epsilon}^{a+\\epsilon} \\delta(x - a)f(x)\\, dx = f(a)$\n3) $\\delta(x) = 0$ for all $x \\neq 0$\n4) $\\delta(g(x)) = \\sum_i \\frac{\\delta(x - x_i)}{\\|g'(x_i)\\|}$ where $x_i$\n   are the roots of $g$\n5) $\\delta(-x) = \\delta(x)$\n\nDerivatives of ``k``-th order of DiracDelta have the following properties:\n\n6) $\\delta(x, k) = 0$ for all $x \\neq 0$\n7) $\\delta(-x, k) = -\\delta(x, k)$ for odd $k$\n8) $\\delta(-x, k) = \\delta(x, k)$ for even $k$\n\nExamples\n========\n\n>>> from sympy import DiracDelta, diff, pi\n>>> from sympy.abc import x, y\n\n>>> DiracDelta(x)\nDiracDelta(x)\n>>> DiracDelta(1)\n0\n>>> DiracDelta(-1)\n0\n>>> DiracDelta(pi)\n0\n>>> DiracDelta(x - 4).subs(x, 4)\nDiracDelta(0)\n>>> diff(DiracDelta(x))\nDiracDelta(x, 1)\n>>> diff(DiracDelta(x - 1), x, 2)\nDiracDelta(x - 1, 2)\n>>> diff(DiracDelta(x**2 - 1), x, 2)\n2*(2*x**2*DiracDelta(x**2 - 1, 2) + DiracDelta(x**2 - 1, 1))\n>>> DiracDelta(3*x).is_simple(x)\nTrue\n>>> DiracDelta(x**2).is_simple(x)\nFalse\n>>> DiracDelta((x**2 - 1)*y).expand(diracdelta=True, wrt=x)\nDiracDelta(x - 1)/(2*Abs(y)) + DiracDelta(x + 1)/(2*Abs(y))\n\nSee Also\n========\n\nHeaviside\nsympy.simplify.simplify.simplify, is_simple\nsympy.functions.special.tensor_functions.KroneckerDelta\n\nReferences\n==========\n\n.. [1] https://mathworld.wolfram.com/DeltaFunction.html",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.DiracDelta.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Ei",
          "name": "Ei",
          "description": "The classical exponential integral.\n\nExplanation\n===========\n\nFor use in SymPy, this function is defined as\n\n.. math:: \\operatorname{Ei}(x) = \\sum_{n=1}^\\infty \\frac{x^n}{n\\, n!}\n                                 + \\log(x) + \\gamma,\n\nwhere $\\gamma$ is the Euler-Mascheroni constant.\n\nIf $x$ is a polar number, this defines an analytic function on the\nRiemann surface of the logarithm. Otherwise this defines an analytic\nfunction in the cut plane $\\mathbb{C} \\setminus (-\\infty, 0]$.\n\n**Background**\n\nThe name exponential integral comes from the following statement:\n\n.. math:: \\operatorname{Ei}(x) = \\int_{-\\infty}^x \\frac{e^t}{t} \\mathrm{d}t\n\nIf the integral is interpreted as a Cauchy principal value, this statement\nholds for $x > 0$ and $\\operatorname{Ei}(x)$ as defined above.\n\nExamples\n========\n\n>>> from sympy import Ei, polar_lift, exp_polar, I, pi\n>>> from sympy.abc import x\n\n>>> Ei(-1)\nEi(-1)\n\nThis yields a real value:\n\n>>> Ei(-1).n(chop=True)\n-0.219383934395520\n\nOn the other hand the analytic continuation is not real:\n\n>>> Ei(polar_lift(-1)).n(chop=True)\n-0.21938393439552 + 3.14159265358979*I\n\nThe exponential integral has a logarithmic branch point at the origin:\n\n>>> Ei(x*exp_polar(2*I*pi))\nEi(x) + 2*I*pi\n\nDifferentiation is supported:\n\n>>> Ei(x).diff(x)\nexp(x)/x\n\nThe exponential integral is related to many other special functions.\nFor example:\n\n>>> from sympy import expint, Shi\n>>> Ei(x).rewrite(expint)\n-expint(1, x*exp_polar(I*pi)) - I*pi\n>>> Ei(x).rewrite(Shi)\nChi(x) + Shi(x)\n\nSee Also\n========\n\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\nSi: Sine integral.\nCi: Cosine integral.\nShi: Hyperbolic sine integral.\nChi: Hyperbolic cosine integral.\nuppergamma: Upper incomplete gamma function.\n\nReferences\n==========\n\n.. [1] https://dlmf.nist.gov/6.6\n.. [2] https://en.wikipedia.org/wiki/Exponential_integral\n.. [3] Abramowitz & Stegun, section 5: https://web.archive.org/web/20201128173312/http://people.math.sfu.ca/~cbm/aands/page_228.htm",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ei.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.FallingFactorial",
          "name": "FallingFactorial",
          "description": "Falling factorial (related to rising factorial) is a double valued\nfunction arising in concrete mathematics, hypergeometric functions\nand series expansions. It is defined by\n\n.. math:: \\texttt{ff(x, k)} = (x)_k = x \\cdot (x-1) \\cdots (x-k+1)\n\nwhere `x` can be arbitrary expression and `k` is an integer. For\nmore information check \"Concrete mathematics\" by Graham, pp. 66\nor [1]_.\n\nWhen `x` is a `~.Poly` instance of degree $\\ge 1$ with single variable,\n`(x)_k = x(y) \\cdot x(y-1) \\cdots x(y-k+1)`, where `y` is the\nvariable of `x`. This is as described in\n\n>>> from sympy import ff, Poly, Symbol\n>>> from sympy.abc import x\n>>> n = Symbol('n', integer=True)\n\n>>> ff(x, 0)\n1\n>>> ff(5, 5)\n120\n>>> ff(x, 5) == x*(x - 1)*(x - 2)*(x - 3)*(x - 4)\nTrue\n>>> ff(Poly(x**2, x), 2)\nPoly(x**4 - 2*x**3 + x**2, x, domain='ZZ')\n>>> ff(n, n)\nfactorial(n)\n\nRewriting is complicated unless the relationship between\nthe arguments is known, but falling factorial can\nbe rewritten in terms of gamma, factorial and binomial\nand rising factorial.\n\n>>> from sympy import factorial, rf, gamma, binomial, Symbol\n>>> n = Symbol('n', integer=True, positive=True)\n>>> F = ff(n, n - 2)\n>>> for i in (rf, ff, factorial, binomial, gamma):\n...  F.rewrite(i)\n...\nRisingFactorial(3, n - 2)\nFallingFactorial(n, n - 2)\nfactorial(n)/2\nbinomial(n, n - 2)*factorial(n - 2)\ngamma(n + 1)/2\n\nSee Also\n========\n\nfactorial, factorial2, RisingFactorial\n\nReferences\n==========\n\n.. [1] https://mathworld.wolfram.com/FallingFactorial.html\n.. [2] Peter Paule, \"Greatest Factorial Factorization and Symbolic\n       Summation\", Journal of Symbolic Computation, vol. 20, pp. 235-268,\n       1995.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.FallingFactorial.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Heaviside",
          "name": "Heaviside",
          "description": "Heaviside step function.\n\nExplanation\n===========\n\nThe Heaviside step function has the following properties:\n\n1) $\\frac{d}{d x} \\theta(x) = \\delta(x)$\n2) $\\theta(x) = \\begin{cases} 0 & \\text{for}\\: x < 0 \\\\ \\frac{1}{2} &\n   \\text{for}\\: x = 0 \\\\1 & \\text{for}\\: x > 0 \\end{cases}$\n3) $\\frac{d}{d x} \\max(x, 0) = \\theta(x)$\n\nHeaviside(x) is printed as $\\theta(x)$ with the SymPy LaTeX printer.\n\nThe value at 0 is set differently in different fields. SymPy uses 1/2,\nwhich is a convention from electronics and signal processing, and is\nconsistent with solving improper integrals by Fourier transform and\nconvolution.\n\nTo specify a different value of Heaviside at ``x=0``, a second argument\ncan be given. Using ``Heaviside(x, nan)`` gives an expression that will\nevaluate to nan for x=0.\n\n.. versionchanged:: 1.9 ``Heaviside(0)`` now returns 1/2 (before: undefined)\n\nExamples\n========\n\n>>> from sympy import Heaviside, nan\n>>> from sympy.abc import x\n>>> Heaviside(9)\n1\n>>> Heaviside(-9)\n0\n>>> Heaviside(0)\n1/2\n>>> Heaviside(0, nan)\nnan\n>>> (Heaviside(x) + 1).replace(Heaviside(x), Heaviside(x, 1))\nHeaviside(x, 1) + 1\n\nSee Also\n========\n\nDiracDelta\n\nReferences\n==========\n\n.. [1] https://mathworld.wolfram.com/HeavisideStepFunction.html\n.. [2] https://dlmf.nist.gov/1.16#iv",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Heaviside.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.KroneckerDelta",
          "name": "KroneckerDelta",
          "description": "The discrete, or Kronecker, delta function.\n\nExplanation\n===========\n\nA function that takes in two integers $i$ and $j$. It returns $0$ if $i$\nand $j$ are not equal, or it returns $1$ if $i$ and $j$ are equal.\n\nExamples\n========\n\nAn example with integer indices:\n\n    >>> from sympy import KroneckerDelta\n    >>> KroneckerDelta(1, 2)\n    0\n    >>> KroneckerDelta(3, 3)\n    1\n\nSymbolic indices:\n\n    >>> from sympy.abc import i, j, k\n    >>> KroneckerDelta(i, j)\n    KroneckerDelta(i, j)\n    >>> KroneckerDelta(i, i)\n    1\n    >>> KroneckerDelta(i, i + 1)\n    0\n    >>> KroneckerDelta(i, i + 1 + k)\n    KroneckerDelta(i, i + k + 1)\n\nParameters\n==========\n\ni : Number, Symbol\n    The first index of the delta function.\nj : Number, Symbol\n    The second index of the delta function.\n\nSee Also\n========\n\neval\nDiracDelta\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Kronecker_delta",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.KroneckerDelta.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.LambertW",
          "name": "LambertW",
          "description": "The Lambert W function $W(z)$ is defined as the inverse\nfunction of $w \\exp(w)$ [1]_.\n\nExplanation\n===========\n\nIn other words, the value of $W(z)$ is such that $z = W(z) \\exp(W(z))$\nfor any complex number $z$.  The Lambert W function is a multivalued\nfunction with infinitely many branches $W_k(z)$, indexed by\n$k \\in \\mathbb{Z}$.  Each branch gives a different solution $w$\nof the equation $z = w \\exp(w)$.\n\nThe Lambert W function has two partially real branches: the\nprincipal branch ($k = 0$) is real for real $z > -1/e$, and the\n$k = -1$ branch is real for $-1/e < z < 0$. All branches except\n$k = 0$ have a logarithmic singularity at $z = 0$.\n\nExamples\n========\n\n>>> from sympy import LambertW\n>>> LambertW(1.2)\n0.635564016364870\n>>> LambertW(1.2, -1).n()\n-1.34747534407696 - 4.41624341514535*I\n>>> LambertW(-1).is_real\nFalse\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Lambert_W_function",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LambertW.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.LeviCivita",
          "name": "LeviCivita",
          "description": "Represent the Levi-Civita symbol.\n\nExplanation\n===========\n\nFor even permutations of indices it returns 1, for odd permutations -1, and\nfor everything else (a repeated index) it returns 0.\n\nThus it represents an alternating pseudotensor.\n\nExamples\n========\n\n>>> from sympy import LeviCivita\n>>> from sympy.abc import i, j, k\n>>> LeviCivita(1, 2, 3)\n1\n>>> LeviCivita(1, 3, 2)\n-1\n>>> LeviCivita(1, 2, 2)\n0\n>>> LeviCivita(i, j, k)\nLeviCivita(i, j, k)\n>>> LeviCivita(i, j, i)\n0\n\nSee Also\n========\n\nEijk",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.LeviCivita.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Li",
          "name": "Li",
          "description": "The offset logarithmic integral.\n\nExplanation\n===========\n\nFor use in SymPy, this function is defined as\n\n.. math:: \\operatorname{Li}(x) = \\operatorname{li}(x) - \\operatorname{li}(2)\n\nExamples\n========\n\n>>> from sympy import Li\n>>> from sympy.abc import z\n\nThe following special value is known:\n\n>>> Li(2)\n0\n\nDifferentiation with respect to $z$ is supported:\n\n>>> from sympy import diff\n>>> diff(Li(z), z)\n1/log(z)\n\nThe shifted logarithmic integral can be written in terms of $li(z)$:\n\n>>> from sympy import li\n>>> Li(z).rewrite(li)\nli(z) - li(2)\n\nWe can numerically evaluate the logarithmic integral to arbitrary precision\non the whole complex plane (except the singular points):\n\n>>> Li(2).evalf(30)\n0\n\n>>> Li(4).evalf(30)\n1.92242131492155809316615998938\n\nSee Also\n========\n\nli: Logarithmic integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nSi: Sine integral.\nCi: Cosine integral.\nShi: Hyperbolic sine integral.\nChi: Hyperbolic cosine integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Logarithmic_integral\n.. [2] https://mathworld.wolfram.com/LogarithmicIntegral.html\n.. [3] https://dlmf.nist.gov/6",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Li.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Max",
          "name": "Max",
          "description": "Return, if possible, the maximum value of the list.\n\nWhen number of arguments is equal one, then\nreturn this argument.\n\nWhen number of arguments is equal two, then\nreturn, if possible, the value from (a, b) that is $\\ge$ the other.\n\nIn common case, when the length of list greater than 2, the task\nis more complicated. Return only the arguments, which are greater\nthan others, if it is possible to determine directional relation.\n\nIf is not possible to determine such a relation, return a partially\nevaluated result.\n\nAssumptions are used to make the decision too.\n\nAlso, only comparable arguments are permitted.\n\nIt is named ``Max`` and not ``max`` to avoid conflicts\nwith the built-in function ``max``.\n\n\nExamples\n========\n\n>>> from sympy import Max, Symbol, oo\n>>> from sympy.abc import x, y, z\n>>> p = Symbol('p', positive=True)\n>>> n = Symbol('n', negative=True)\n\n>>> Max(x, -2)\nMax(-2, x)\n>>> Max(x, -2).subs(x, 3)\n3\n>>> Max(p, -2)\np\n>>> Max(x, y)\nMax(x, y)\n>>> Max(x, y) == Max(y, x)\nTrue\n>>> Max(x, Max(y, z))\nMax(x, y, z)\n>>> Max(n, 8, p, 7, -oo)\nMax(8, p)\n>>> Max (1, x, oo)\noo\n\n* Algorithm\n\nThe task can be considered as searching of supremums in the\ndirected complete partial orders [1]_.\n\nThe source values are sequentially allocated by the isolated subsets\nin which supremums are searched and result as Max arguments.\n\nIf the resulted supremum is single, then it is returned.\n\nThe isolated subsets are the sets of values which are only the comparable\nwith each other in the current set. E.g. natural numbers are comparable with\neach other, but not comparable with the `x` symbol. Another example: the\nsymbol `x` with negative assumption is comparable with a natural number.\n\nAlso there are \"least\" elements, which are comparable with all others,\nand have a zero property (maximum or minimum for all elements).\nFor example, in case of $\\infty$, the allocation operation is terminated\nand only this value is returned.\n\nAssumption:\n   - if $A > B > C$ then $A > C$\n   - if $A = B$ then $B$ can be removed\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Directed_complete_partial_order\n.. [2] https://en.wikipedia.org/wiki/Lattice_%28order%29\n\nSee Also\n========\n\nMin : find minimum values",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Max.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Min",
          "name": "Min",
          "description": "Return, if possible, the minimum value of the list.\nIt is named ``Min`` and not ``min`` to avoid conflicts\nwith the built-in function ``min``.\n\nExamples\n========\n\n>>> from sympy import Min, Symbol, oo\n>>> from sympy.abc import x, y\n>>> p = Symbol('p', positive=True)\n>>> n = Symbol('n', negative=True)\n\n>>> Min(x, -2)\nMin(-2, x)\n>>> Min(x, -2).subs(x, 3)\n-2\n>>> Min(p, -3)\n-3\n>>> Min(x, y)\nMin(x, y)\n>>> Min(n, 8, p, -7, p, oo)\nMin(-7, n)\n\nSee Also\n========\n\nMax : find maximum values",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Min.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Piecewise",
          "name": "Piecewise",
          "description": "Represents a piecewise function.\n\nUsage:\n\n  Piecewise( (expr,cond), (expr,cond), ... )\n    - Each argument is a 2-tuple defining an expression and condition\n    - The conds are evaluated in turn returning the first that is True.\n      If any of the evaluated conds are not explicitly False,\n      e.g. ``x < 1``, the function is returned in symbolic form.\n    - If the function is evaluated at a place where all conditions are False,\n      nan will be returned.\n    - Pairs where the cond is explicitly False, will be removed and no pair\n      appearing after a True condition will ever be retained. If a single\n      pair with a True condition remains, it will be returned, even when\n      evaluation is False.\n\nExamples\n========\n\n>>> from sympy import Piecewise, log, piecewise_fold\n>>> from sympy.abc import x, y\n>>> f = x**2\n>>> g = log(x)\n>>> p = Piecewise((0, x < -1), (f, x <= 1), (g, True))\n>>> p.subs(x,1)\n1\n>>> p.subs(x,5)\nlog(5)\n\nBooleans can contain Piecewise elements:\n\n>>> cond = (x < y).subs(x, Piecewise((2, x < 0), (3, True))); cond\nPiecewise((2, x < 0), (3, True)) < y\n\nThe folded version of this results in a Piecewise whose\nexpressions are Booleans:\n\n>>> folded_cond = piecewise_fold(cond); folded_cond\nPiecewise((2 < y, x < 0), (3 < y, True))\n\nWhen a Boolean containing Piecewise (like cond) or a Piecewise\nwith Boolean expressions (like folded_cond) is used as a condition,\nit is converted to an equivalent :class:`~.ITE` object:\n\n>>> Piecewise((1, folded_cond))\nPiecewise((1, ITE(x < 0, y > 2, y > 3)))\n\nWhen a condition is an ``ITE``, it will be converted to a simplified\nBoolean expression:\n\n>>> piecewise_fold(_)\nPiecewise((1, ((x >= 0) | (y > 2)) & ((y > 3) | (x < 0))))\n\nSee Also\n========\n\npiecewise_fold\npiecewise_exclusive\nITE",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Piecewise.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Rem",
          "name": "Rem",
          "description": "Returns the remainder when ``p`` is divided by ``q`` where ``p`` is finite\nand ``q`` is not equal to zero. The result, ``p - int(p/q)*q``, has the same sign\nas the divisor.\n\nParameters\n==========\n\np : Expr\n    Dividend.\n\nq : Expr\n    Divisor.\n\nNotes\n=====\n\n``Rem`` corresponds to the ``%`` operator in C.\n\nExamples\n========\n\n>>> from sympy.abc import x, y\n>>> from sympy import Rem\n>>> Rem(x**3, y)\nRem(x**3, y)\n>>> Rem(x**3, y).subs({x: -5, y: 3})\n-2\n\nSee Also\n========\n\nMod",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Rem.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.RisingFactorial",
          "name": "RisingFactorial",
          "description": "Rising factorial (also called Pochhammer symbol [1]_) is a double valued\nfunction arising in concrete mathematics, hypergeometric functions\nand series expansions. It is defined by:\n\n.. math:: \\texttt{rf(y, k)} = (x)^k = x \\cdot (x+1) \\cdots (x+k-1)\n\nwhere `x` can be arbitrary expression and `k` is an integer. For\nmore information check \"Concrete mathematics\" by Graham, pp. 66\nor visit https://mathworld.wolfram.com/RisingFactorial.html page.\n\nWhen `x` is a `~.Poly` instance of degree $\\ge 1$ with a single variable,\n`(x)^k = x(y) \\cdot x(y+1) \\cdots x(y+k-1)`, where `y` is the\nvariable of `x`. This is as described in [2]_.\n\nExamples\n========\n\n>>> from sympy import rf, Poly\n>>> from sympy.abc import x\n>>> rf(x, 0)\n1\n>>> rf(1, 5)\n120\n>>> rf(x, 5) == x*(1 + x)*(2 + x)*(3 + x)*(4 + x)\nTrue\n>>> rf(Poly(x**3, x), 2)\nPoly(x**6 + 3*x**5 + 3*x**4 + x**3, x, domain='ZZ')\n\nRewriting is complicated unless the relationship between\nthe arguments is known, but rising factorial can\nbe rewritten in terms of gamma, factorial, binomial,\nand falling factorial.\n\n>>> from sympy import Symbol, factorial, ff, binomial, gamma\n>>> n = Symbol('n', integer=True, positive=True)\n>>> R = rf(n, n + 2)\n>>> for i in (rf, ff, factorial, binomial, gamma):\n...  R.rewrite(i)\n...\nRisingFactorial(n, n + 2)\nFallingFactorial(2*n + 1, n + 2)\nfactorial(2*n + 1)/factorial(n - 1)\nbinomial(2*n + 1, n + 2)*factorial(n + 2)\ngamma(2*n + 2)/gamma(n)\n\nSee Also\n========\n\nfactorial, factorial2, FallingFactorial\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Pochhammer_symbol\n.. [2] Peter Paule, \"Greatest Factorial Factorization and Symbolic\n       Summation\", Journal of Symbolic Computation, vol. 20, pp. 235-268,\n       1995.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.RisingFactorial.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Shi",
          "name": "Shi",
          "description": "Sinh integral.\n\nExplanation\n===========\n\nThis function is defined by\n\n.. math:: \\operatorname{Shi}(z) = \\int_0^z \\frac{\\sinh{t}}{t} \\mathrm{d}t.\n\nIt is an entire function.\n\nExamples\n========\n\n>>> from sympy import Shi\n>>> from sympy.abc import z\n\nThe Sinh integral is a primitive of $\\sinh(z)/z$:\n\n>>> Shi(z).diff(z)\nsinh(z)/z\n\nIt is unbranched:\n\n>>> from sympy import exp_polar, I, pi\n>>> Shi(z*exp_polar(2*I*pi))\nShi(z)\n\nThe $\\sinh$ integral behaves much like ordinary $\\sinh$ under\nmultiplication by $i$:\n\n>>> Shi(I*z)\nI*Si(z)\n>>> Shi(-z)\n-Shi(z)\n\nIt can also be expressed in terms of exponential integrals, but beware\nthat the latter is branched:\n\n>>> from sympy import expint\n>>> Shi(z).rewrite(expint)\nexpint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2\n\nSee Also\n========\n\nSi: Sine integral.\nCi: Cosine integral.\nChi: Hyperbolic cosine integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Trigonometric_integral",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Shi.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Si",
          "name": "Si",
          "description": "Sine integral.\n\nExplanation\n===========\n\nThis function is defined by\n\n.. math:: \\operatorname{Si}(z) = \\int_0^z \\frac{\\sin{t}}{t} \\mathrm{d}t.\n\nIt is an entire function.\n\nExamples\n========\n\n>>> from sympy import Si\n>>> from sympy.abc import z\n\nThe sine integral is an antiderivative of $sin(z)/z$:\n\n>>> Si(z).diff(z)\nsin(z)/z\n\nIt is unbranched:\n\n>>> from sympy import exp_polar, I, pi\n>>> Si(z*exp_polar(2*I*pi))\nSi(z)\n\nSine integral behaves much like ordinary sine under multiplication by ``I``:\n\n>>> Si(I*z)\nI*Shi(z)\n>>> Si(-z)\n-Si(z)\n\nIt can also be expressed in terms of exponential integrals, but beware\nthat the latter is branched:\n\n>>> from sympy import expint\n>>> Si(z).rewrite(expint)\n-I*(-expint(1, z*exp_polar(-I*pi/2))/2 +\n     expint(1, z*exp_polar(I*pi/2))/2) + pi/2\n\nIt can be rewritten in the form of sinc function (by definition):\n\n>>> from sympy import sinc\n>>> Si(z).rewrite(sinc)\nIntegral(sinc(_t), (_t, 0, z))\n\nSee Also\n========\n\nCi: Cosine integral.\nShi: Hyperbolic sine integral.\nChi: Hyperbolic cosine integral.\nEi: Exponential integral.\nexpint: Generalised exponential integral.\nsinc: unnormalized sinc function\nE1: Special case of the generalised exponential integral.\nli: Logarithmic integral.\nLi: Offset logarithmic integral.\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Trigonometric_integral",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Si.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.SingularityFunction",
          "name": "SingularityFunction",
          "description": "Singularity functions are a class of discontinuous functions.\n\nExplanation\n===========\n\nSingularity functions take a variable, an offset, and an exponent as\narguments. These functions are represented using Macaulay brackets as:\n\nSingularityFunction(x, a, n) := <x - a>^n\n\nThe singularity function will automatically evaluate to\n``Derivative(DiracDelta(x - a), x, -n - 1)`` if ``n < 0``\nand ``(x - a)**n*Heaviside(x - a, 1)`` if ``n >= 0``.\n\nExamples\n========\n\n>>> from sympy import SingularityFunction, diff, Piecewise, DiracDelta, Heaviside, Symbol\n>>> from sympy.abc import x, a, n\n>>> SingularityFunction(x, a, n)\nSingularityFunction(x, a, n)\n>>> y = Symbol('y', positive=True)\n>>> n = Symbol('n', nonnegative=True)\n>>> SingularityFunction(y, -10, n)\n(y + 10)**n\n>>> y = Symbol('y', negative=True)\n>>> SingularityFunction(y, 10, n)\n0\n>>> SingularityFunction(x, 4, -1).subs(x, 4)\noo\n>>> SingularityFunction(x, 10, -2).subs(x, 10)\noo\n>>> SingularityFunction(4, 1, 5)\n243\n>>> diff(SingularityFunction(x, 1, 5) + SingularityFunction(x, 1, 4), x)\n4*SingularityFunction(x, 1, 3) + 5*SingularityFunction(x, 1, 4)\n>>> diff(SingularityFunction(x, 4, 0), x, 2)\nSingularityFunction(x, 4, -2)\n>>> SingularityFunction(x, 4, 5).rewrite(Piecewise)\nPiecewise(((x - 4)**5, x >= 4), (0, True))\n>>> expr = SingularityFunction(x, a, n)\n>>> y = Symbol('y', positive=True)\n>>> n = Symbol('n', nonnegative=True)\n>>> expr.subs({x: y, a: -10, n: n})\n(y + 10)**n\n\nThe methods ``rewrite(DiracDelta)``, ``rewrite(Heaviside)``, and\n``rewrite('HeavisideDiracDelta')`` returns the same output. One can use any\nof these methods according to their choice.\n\n>>> expr = SingularityFunction(x, 4, 5) + SingularityFunction(x, -3, -1) - SingularityFunction(x, 0, -2)\n>>> expr.rewrite(Heaviside)\n(x - 4)**5*Heaviside(x - 4, 1) + DiracDelta(x + 3) - DiracDelta(x, 1)\n>>> expr.rewrite(DiracDelta)\n(x - 4)**5*Heaviside(x - 4, 1) + DiracDelta(x + 3) - DiracDelta(x, 1)\n>>> expr.rewrite('HeavisideDiracDelta')\n(x - 4)**5*Heaviside(x - 4, 1) + DiracDelta(x + 3) - DiracDelta(x, 1)\n\nSee Also\n========\n\nDiracDelta, Heaviside\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Singularity_function",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.SingularityFunction.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.functions.Ynm",
          "name": "Ynm",
          "description": "Spherical harmonics defined as\n\n.. math::\n    Y_n^m(\\theta, \\varphi) := \\sqrt{\\frac{(2n+1)(n-m)!}{4\\pi(n+m)!}}\n                              \\exp(i m \\varphi)\n                              \\mathrm{P}_n^m\\left(\\cos(\\theta)\\right)\n\nExplanation\n===========\n\n``Ynm()`` gives the spherical harmonic function of order $n$ and $m$\nin $\\theta$ and $\\varphi$, $Y_n^m(\\theta, \\varphi)$. The four\nparameters are as follows: $n \\geq 0$ an integer and $m$ an integer\nsuch that $-n \\leq m \\leq n$ holds. The two angles are real-valued\nwith $\\theta \\in [0, \\pi]$ and $\\varphi \\in [0, 2\\pi]$.\n\nExamples\n========\n\n>>> from sympy import Ynm, Symbol, simplify\n>>> from sympy.abc import n,m\n>>> theta = Symbol(\"theta\")\n>>> phi = Symbol(\"phi\")\n\n>>> Ynm(n, m, theta, phi)\nYnm(n, m, theta, phi)\n\nSeveral symmetries are known, for the order:\n\n>>> Ynm(n, -m, theta, phi)\n(-1)**m*exp(-2*I*m*phi)*Ynm(n, m, theta, phi)\n\nAs well as for the angles:\n\n>>> Ynm(n, m, -theta, phi)\nYnm(n, m, theta, phi)\n\n>>> Ynm(n, m, theta, -phi)\nexp(-2*I*m*phi)*Ynm(n, m, theta, phi)\n\nFor specific integers $n$ and $m$ we can evaluate the harmonics\nto more useful expressions:\n\n>>> simplify(Ynm(0, 0, theta, phi).expand(func=True))\n1/(2*sqrt(pi))\n\n>>> simplify(Ynm(1, -1, theta, phi).expand(func=True))\nsqrt(6)*exp(-I*phi)*sin(theta)/(4*sqrt(pi))\n\n>>> simplify(Ynm(1, 0, theta, phi).expand(func=True))\nsqrt(3)*cos(theta)/(2*sqrt(pi))\n\n>>> simplify(Ynm(1, 1, theta, phi).expand(func=True))\n-sqrt(6)*exp(I*phi)*sin(theta)/(4*sqrt(pi))\n\n>>> simplify(Ynm(2, -2, theta, phi).expand(func=True))\nsqrt(30)*exp(-2*I*phi)*sin(theta)**2/(8*sqrt(pi))\n\n>>> simplify(Ynm(2, -1, theta, phi).expand(func=True))\nsqrt(30)*exp(-I*phi)*sin(2*theta)/(8*sqrt(pi))\n\n>>> simplify(Ynm(2, 0, theta, phi).expand(func=True))\nsqrt(5)*(3*cos(theta)**2 - 1)/(4*sqrt(pi))\n\n>>> simplify(Ynm(2, 1, theta, phi).expand(func=True))\n-sqrt(30)*exp(I*phi)*sin(2*theta)/(8*sqrt(pi))\n\n>>> simplify(Ynm(2, 2, theta, phi).expand(func=True))\nsqrt(30)*exp(2*I*phi)*sin(theta)**2/(8*sqrt(pi))\n\nWe can differentiate the functions with respect\nto both angles:\n\n>>> from sympy import Ynm, Symbol, diff\n>>> from sympy.abc import n,m\n>>> theta = Symbol(\"theta\")\n>>> phi = Symbol(\"phi\")\n\n>>> diff(Ynm(n, m, theta, phi), theta)\nm*cot(theta)*Ynm(n, m, theta, phi) + sqrt((-m + n)*(m + n + 1))*exp(-I*phi)*Ynm(n, m + 1, theta, phi)\n\n>>> diff(Ynm(n, m, theta, phi), phi)\nI*m*Ynm(n, m, theta, phi)\n\nFurther we can compute the complex conjugation:\n\n>>> from sympy import Ynm, Symbol, conjugate\n>>> from sympy.abc import n,m\n>>> theta = Symbol(\"theta\")\n>>> phi = Symbol(\"phi\")\n\n>>> conjugate(Ynm(n, m, theta, phi))\n(-1)**(2*m)*exp(-2*I*m*phi)*Ynm(n, m, theta, phi)\n\nTo get back the well known expressions in spherical\ncoordinates, we use full expansion:\n\n>>> from sympy import Ynm, Symbol, expand_func\n>>> from sympy.abc import n,m\n>>> theta = Symbol(\"theta\")\n>>> phi = Symbol(\"phi\")\n\n>>> expand_func(Ynm(n, m, theta, phi))\nsqrt((2*n + 1)*factorial(-m + n)/factorial(m + n))*exp(I*m*phi)*assoc_legendre(n, m, cos(theta))/(2*sqrt(pi))\n\nSee Also\n========\n\nYnm_c, Znm\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Spherical_harmonics\n.. [2] https://mathworld.wolfram.com/SphericalHarmonic.html\n.. [3] https://functions.wolfram.com/Polynomials/SphericalHarmonicY/\n.. [4] https://dlmf.nist.gov/14.30",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.functions.Ynm.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        }
      ]
    },
    {
      "@type": "SoftwareApplication",
      "@id": "sympy:sympy.matrices",
      "name": "sympy.matrices",
      "applicationCategory": "Mathematical Software",
      "classes": [
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.Adjoint",
          "name": "Adjoint",
          "description": "The Hermitian adjoint of a matrix expression.\n\nThis is a symbolic object that simply stores its argument without\nevaluating it. To actually compute the adjoint, use the ``adjoint()``\nfunction.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, Adjoint, adjoint\n>>> A = MatrixSymbol('A', 3, 5)\n>>> B = MatrixSymbol('B', 5, 3)\n>>> Adjoint(A*B)\nAdjoint(A*B)\n>>> adjoint(A*B)\nAdjoint(B)*Adjoint(A)\n>>> adjoint(A*B) == Adjoint(A*B)\nFalse\n>>> adjoint(A*B) == Adjoint(A*B).doit()\nTrue",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Adjoint.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.BlockDiagMatrix",
          "name": "BlockDiagMatrix",
          "description": "A sparse matrix with block matrices along its diagonals\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, BlockDiagMatrix, symbols\n>>> n, m, l = symbols('n m l')\n>>> X = MatrixSymbol('X', n, n)\n>>> Y = MatrixSymbol('Y', m, m)\n>>> BlockDiagMatrix(X, Y)\nMatrix([\n[X, 0],\n[0, Y]])\n\nNotes\n=====\n\nIf you want to get the individual diagonal blocks, use\n:meth:`get_diag_blocks`.\n\nSee Also\n========\n\nsympy.matrices.dense.diag",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.LDUdecomposition",
              "name": "LDUdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.LUdecomposition",
              "name": "LUdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.UDLdecomposition",
              "name": "UDLdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockDiagMatrix.as_coeff_Mul",
              "name": "as_coeff_Mul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.BlockMatrix",
          "name": "BlockMatrix",
          "description": "A BlockMatrix is a Matrix comprised of other matrices.\n\nThe submatrices are stored in a SymPy Matrix object but accessed as part of\na Matrix Expression\n\n>>> from sympy import (MatrixSymbol, BlockMatrix, symbols,\n...     Identity, ZeroMatrix, block_collapse)\n>>> n,m,l = symbols('n m l')\n>>> X = MatrixSymbol('X', n, n)\n>>> Y = MatrixSymbol('Y', m, m)\n>>> Z = MatrixSymbol('Z', n, m)\n>>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])\n>>> print(B)\nMatrix([\n[X, Z],\n[0, Y]])\n\n>>> C = BlockMatrix([[Identity(n), Z]])\n>>> print(C)\nMatrix([[I, Z]])\n\n>>> print(block_collapse(C*B))\nMatrix([[X, Z + Z*Y]])\n\nSome matrices might be comprised of rows of blocks with\nthe matrices in each row having the same height and the\nrows all having the same total number of columns but\nnot having the same number of columns for each matrix\nin each row. In this case, the matrix is not a block\nmatrix and should be instantiated by Matrix.\n\n>>> from sympy import ones, Matrix\n>>> dat = [\n... [ones(3,2), ones(3,3)*2],\n... [ones(2,3)*3, ones(2,2)*4]]\n...\n>>> BlockMatrix(dat)\nTraceback (most recent call last):\n...\nValueError:\nAlthough this matrix is comprised of blocks, the blocks do not fill\nthe matrix in a size-symmetric fashion. To create a full matrix from\nthese arguments, pass them directly to Matrix.\n>>> Matrix(dat)\nMatrix([\n[1, 1, 2, 2, 2],\n[1, 1, 2, 2, 2],\n[1, 1, 2, 2, 2],\n[3, 3, 3, 4, 4],\n[3, 3, 3, 4, 4]])\n\nSee Also\n========\nsympy.matrices.matrixbase.MatrixBase.irregular",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.LDUdecomposition",
              "name": "LDUdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.LUdecomposition",
              "name": "LUdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.UDLdecomposition",
              "name": "UDLdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.BlockMatrix.as_coeff_Mul",
              "name": "as_coeff_Mul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.DeferredVector",
          "name": "DeferredVector",
          "description": "A vector whose components are deferred (e.g. for use with lambdify).\n\nExamples\n========\n\n>>> from sympy import DeferredVector, lambdify\n>>> X = DeferredVector( 'X' )\n>>> X\nX\n>>> expr = (X[0] + 2, X[2] + 3)\n>>> func = lambdify( X, expr)\n>>> func( [1, 2, 3] )\n(3, 6)",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DeferredVector.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.Determinant",
          "name": "Determinant",
          "description": "Matrix Determinant\n\nRepresents the determinant of a matrix expression.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, Determinant, eye\n>>> A = MatrixSymbol('A', 3, 3)\n>>> Determinant(A)\nDeterminant(A)\n>>> Determinant(eye(3)).doit()\n1",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Determinant.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.DiagMatrix",
          "name": "DiagMatrix",
          "description": "Turn a vector into a diagonal matrix.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagMatrix.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.DiagonalMatrix",
          "name": "DiagonalMatrix",
          "description": "DiagonalMatrix(M) will create a matrix expression that\nbehaves as though all off-diagonal elements,\n`M[i, j]` where `i != j`, are zero.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, DiagonalMatrix, Symbol\n>>> n = Symbol('n', integer=True)\n>>> m = Symbol('m', integer=True)\n>>> D = DiagonalMatrix(MatrixSymbol('x', 2, 3))\n>>> D[1, 2]\n0\n>>> D[1, 1]\nx[1, 1]\n\nThe length of the diagonal -- the lesser of the two dimensions of `M` --\nis accessed through the `diagonal_length` property:\n\n>>> D.diagonal_length\n2\n>>> DiagonalMatrix(MatrixSymbol('x', n + 1, n)).diagonal_length\nn\n\nWhen one of the dimensions is symbolic the other will be treated as\nthough it is smaller:\n\n>>> tall = DiagonalMatrix(MatrixSymbol('x', n, 3))\n>>> tall.diagonal_length\n3\n>>> tall[10, 1]\n0\n\nWhen the size of the diagonal is not known, a value of None will\nbe returned:\n\n>>> DiagonalMatrix(MatrixSymbol('x', n, m)).diagonal_length is None\nTrue",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalMatrix.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.DiagonalOf",
          "name": "DiagonalOf",
          "description": "DiagonalOf(M) will create a matrix expression that\nis equivalent to the diagonal of `M`, represented as\na single column matrix.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, DiagonalOf, Symbol\n>>> n = Symbol('n', integer=True)\n>>> m = Symbol('m', integer=True)\n>>> x = MatrixSymbol('x', 2, 3)\n>>> diag = DiagonalOf(x)\n>>> diag.shape\n(2, 1)\n\nThe diagonal can be addressed like a matrix or vector and will\nreturn the corresponding element of the original matrix:\n\n>>> diag[1, 0] == diag[1] == x[1, 1]\nTrue\n\nThe length of the diagonal -- the lesser of the two dimensions of `M` --\nis accessed through the `diagonal_length` property:\n\n>>> diag.diagonal_length\n2\n>>> DiagonalOf(MatrixSymbol('x', n + 1, n)).diagonal_length\nn\n\nWhen only one of the dimensions is symbolic the other will be\ntreated as though it is smaller:\n\n>>> dtall = DiagonalOf(MatrixSymbol('x', n, 3))\n>>> dtall.diagonal_length\n3\n\nWhen the size of the diagonal is not known, a value of None will\nbe returned:\n\n>>> DiagonalOf(MatrixSymbol('x', n, m)).diagonal_length is None\nTrue",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DiagonalOf.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.DotProduct",
          "name": "DotProduct",
          "description": "Dot product of vector matrices\n\nThe input should be two 1 x n or n x 1 matrices. The output represents the\nscalar dotproduct.\n\nThis is similar to using MatrixElement and MatMul, except DotProduct does\nnot require that one vector to be a row vector and the other vector to be\na column vector.\n\n>>> from sympy import MatrixSymbol, DotProduct\n>>> A = MatrixSymbol('A', 1, 3)\n>>> B = MatrixSymbol('B', 1, 3)\n>>> DotProduct(A, B)\nDotProduct(A, B)\n>>> DotProduct(A, B).doit()\nA[0, 0]*B[0, 0] + A[0, 1]*B[0, 1] + A[0, 2]*B[0, 2]",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.DotProduct.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.FunctionMatrix",
          "name": "FunctionMatrix",
          "description": "Represents a matrix using a function (``Lambda``) which gives\noutputs according to the coordinates of each matrix entries.\n\nParameters\n==========\n\nrows : nonnegative integer. Can be symbolic.\n\ncols : nonnegative integer. Can be symbolic.\n\nlamda : Function, Lambda or str\n    If it is a SymPy ``Function`` or ``Lambda`` instance,\n    it should be able to accept two arguments which represents the\n    matrix coordinates.\n\n    If it is a pure string containing Python ``lambda`` semantics,\n    it is interpreted by the SymPy parser and casted into a SymPy\n    ``Lambda`` instance.\n\nExamples\n========\n\nCreating a ``FunctionMatrix`` from ``Lambda``:\n\n>>> from sympy import FunctionMatrix, symbols, Lambda, MatPow\n>>> i, j, n, m = symbols('i,j,n,m')\n>>> FunctionMatrix(n, m, Lambda((i, j), i + j))\nFunctionMatrix(n, m, Lambda((i, j), i + j))\n\nCreating a ``FunctionMatrix`` from a SymPy function:\n\n>>> from sympy import KroneckerDelta\n>>> X = FunctionMatrix(3, 3, KroneckerDelta)\n>>> X.as_explicit()\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n\nCreating a ``FunctionMatrix`` from a SymPy undefined function:\n\n>>> from sympy import Function\n>>> f = Function('f')\n>>> X = FunctionMatrix(3, 3, f)\n>>> X.as_explicit()\nMatrix([\n[f(0, 0), f(0, 1), f(0, 2)],\n[f(1, 0), f(1, 1), f(1, 2)],\n[f(2, 0), f(2, 1), f(2, 2)]])\n\nCreating a ``FunctionMatrix`` from Python ``lambda``:\n\n>>> FunctionMatrix(n, m, 'lambda i, j: i + j')\nFunctionMatrix(n, m, Lambda((i, j), i + j))\n\nExample of lazy evaluation of matrix product:\n\n>>> Y = FunctionMatrix(1000, 1000, Lambda((i, j), i + j))\n>>> isinstance(Y*Y, MatPow) # this is an expression object\nTrue\n>>> (Y**2)[10,10] # So this is evaluated lazily\n342923500\n\nNotes\n=====\n\nThis class provides an alternative way to represent an extremely\ndense matrix with entries in some form of a sequence, in a most\nsparse way.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.FunctionMatrix.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.HadamardPower",
          "name": "HadamardPower",
          "description": "Elementwise power of matrix expressions\n\nParameters\n==========\n\nbase : scalar or matrix\n\nexp : scalar or matrix\n\nNotes\n=====\n\nThere are four definitions for the hadamard power which can be used.\nLet's consider `A, B` as `(m, n)` matrices, and `a, b` as scalars.\n\nMatrix raised to a scalar exponent:\n\n.. math::\n    A^{\\circ b} = \\begin{bmatrix}\n    A_{0, 0}^b   & A_{0, 1}^b   & \\cdots & A_{0, n-1}^b   \\\\\n    A_{1, 0}^b   & A_{1, 1}^b   & \\cdots & A_{1, n-1}^b   \\\\\n    \\vdots       & \\vdots       & \\ddots & \\vdots         \\\\\n    A_{m-1, 0}^b & A_{m-1, 1}^b & \\cdots & A_{m-1, n-1}^b\n    \\end{bmatrix}\n\nScalar raised to a matrix exponent:\n\n.. math::\n    a^{\\circ B} = \\begin{bmatrix}\n    a^{B_{0, 0}}   & a^{B_{0, 1}}   & \\cdots & a^{B_{0, n-1}}   \\\\\n    a^{B_{1, 0}}   & a^{B_{1, 1}}   & \\cdots & a^{B_{1, n-1}}   \\\\\n    \\vdots         & \\vdots         & \\ddots & \\vdots           \\\\\n    a^{B_{m-1, 0}} & a^{B_{m-1, 1}} & \\cdots & a^{B_{m-1, n-1}}\n    \\end{bmatrix}\n\nMatrix raised to a matrix exponent:\n\n.. math::\n    A^{\\circ B} = \\begin{bmatrix}\n    A_{0, 0}^{B_{0, 0}}     & A_{0, 1}^{B_{0, 1}}     &\n    \\cdots & A_{0, n-1}^{B_{0, n-1}}     \\\\\n    A_{1, 0}^{B_{1, 0}}     & A_{1, 1}^{B_{1, 1}}     &\n    \\cdots & A_{1, n-1}^{B_{1, n-1}}     \\\\\n    \\vdots                  & \\vdots                  &\n    \\ddots & \\vdots                      \\\\\n    A_{m-1, 0}^{B_{m-1, 0}} & A_{m-1, 1}^{B_{m-1, 1}} &\n    \\cdots & A_{m-1, n-1}^{B_{m-1, n-1}}\n    \\end{bmatrix}\n\nScalar raised to a scalar exponent:\n\n.. math::\n    a^{\\circ b} = a^b",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardPower.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.HadamardProduct",
          "name": "HadamardProduct",
          "description": "Elementwise product of matrix expressions\n\nExamples\n========\n\nHadamard product for matrix symbols:\n\n>>> from sympy import hadamard_product, HadamardProduct, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 5)\n>>> B = MatrixSymbol('B', 5, 5)\n>>> isinstance(hadamard_product(A, B), HadamardProduct)\nTrue\n\nNotes\n=====\n\nThis is a symbolic object that simply stores its argument without\nevaluating it. To actually compute the product, use the function\n``hadamard_product()`` or ``HadamardProduct.doit``",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.HadamardProduct.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.Identity",
          "name": "Identity",
          "description": "The Matrix Identity I - multiplicative identity\n\nExamples\n========\n\n>>> from sympy import Identity, MatrixSymbol\n>>> A = MatrixSymbol('A', 3, 5)\n>>> I = Identity(3)\n>>> I*A\nA",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Identity.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.ImmutableDenseMatrix",
          "name": "ImmutableDenseMatrix",
          "description": "Create an immutable version of a matrix.\n\nExamples\n========\n\n>>> from sympy import eye, ImmutableMatrix\n>>> ImmutableMatrix(eye(3))\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> _[0, 0] = 42\nTraceback (most recent call last):\n...\nTypeError: Cannot set values of ImmutableDenseMatrix",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.LDLdecomposition",
              "name": "LDLdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.LDLsolve",
              "name": "LDLsolve"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.LUdecomposition",
              "name": "LUdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.LUdecompositionFF",
              "name": "LUdecompositionFF"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.LUdecomposition_Simple",
              "name": "LUdecomposition_Simple"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.LUsolve",
              "name": "LUsolve"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.QRdecomposition",
              "name": "QRdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.QRsolve",
              "name": "QRsolve"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.add",
              "name": "add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableDenseMatrix.adjoint",
              "name": "adjoint"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.ImmutableMatrix",
          "name": "ImmutableMatrix",
          "description": "Create an immutable version of a matrix.\n\nExamples\n========\n\n>>> from sympy import eye, ImmutableMatrix\n>>> ImmutableMatrix(eye(3))\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> _[0, 0] = 42\nTraceback (most recent call last):\n...\nTypeError: Cannot set values of ImmutableDenseMatrix",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.LDLdecomposition",
              "name": "LDLdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.LDLsolve",
              "name": "LDLsolve"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.LUdecomposition",
              "name": "LUdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.LUdecompositionFF",
              "name": "LUdecompositionFF"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.LUdecomposition_Simple",
              "name": "LUdecomposition_Simple"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.LUsolve",
              "name": "LUsolve"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.QRdecomposition",
              "name": "QRdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.QRsolve",
              "name": "QRsolve"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.add",
              "name": "add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableMatrix.adjoint",
              "name": "adjoint"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.ImmutableSparseMatrix",
          "name": "ImmutableSparseMatrix",
          "description": "Create an immutable version of a sparse matrix.\n\nExamples\n========\n\n>>> from sympy import eye, ImmutableSparseMatrix\n>>> ImmutableSparseMatrix(1, 1, {})\nMatrix([[0]])\n>>> ImmutableSparseMatrix(eye(3))\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]])\n>>> _[0, 0] = 42\nTraceback (most recent call last):\n...\nTypeError: Cannot set values of ImmutableSparseMatrix\n>>> _.shape\n(3, 3)",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.LDLdecomposition",
              "name": "LDLdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.LDLsolve",
              "name": "LDLsolve"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.LUdecomposition",
              "name": "LUdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.LUdecompositionFF",
              "name": "LUdecompositionFF"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.LUdecomposition_Simple",
              "name": "LUdecomposition_Simple"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.LUsolve",
              "name": "LUsolve"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.QRdecomposition",
              "name": "QRdecomposition"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.QRsolve",
              "name": "QRsolve"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.add",
              "name": "add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.ImmutableSparseMatrix.adjoint",
              "name": "adjoint"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.Inverse",
          "name": "Inverse",
          "description": "The multiplicative inverse of a matrix expression\n\nThis is a symbolic object that simply stores its argument without\nevaluating it. To actually compute the inverse, use the ``.inverse()``\nmethod of matrices.\n\nExamples\n========\n\n>>> from sympy import MatrixSymbol, Inverse\n>>> A = MatrixSymbol('A', 3, 3)\n>>> B = MatrixSymbol('B', 3, 3)\n>>> Inverse(A)\nA**(-1)\n>>> A.inverse() == Inverse(A)\nTrue\n>>> (A*B).inverse()\nB**(-1)*A**(-1)\n>>> Inverse(A*B)\n(A*B)**(-1)",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.Inverse.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.KroneckerProduct",
          "name": "KroneckerProduct",
          "description": "The Kronecker product of two or more arguments.\n\nThe Kronecker product is a non-commutative product of matrices.\nGiven two matrices of dimension (m, n) and (s, t) it produces a matrix\nof dimension (m s, n t).\n\nThis is a symbolic object that simply stores its argument without\nevaluating it. To actually compute the product, use the function\n``kronecker_product()`` or call the ``.doit()`` or  ``.as_explicit()``\nmethods.\n\n>>> from sympy import KroneckerProduct, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 5)\n>>> B = MatrixSymbol('B', 5, 5)\n>>> isinstance(KroneckerProduct(A, B), KroneckerProduct)\nTrue",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.KroneckerProduct.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.MatAdd",
          "name": "MatAdd",
          "description": "A Sum of Matrix Expressions\n\nMatAdd inherits from and operates like SymPy Add\n\nExamples\n========\n\n>>> from sympy import MatAdd, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 5)\n>>> B = MatrixSymbol('B', 5, 5)\n>>> C = MatrixSymbol('C', 5, 5)\n>>> MatAdd(A, B, C)\nA + B + C",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatAdd.as_coeff_mmul",
              "name": "as_coeff_mmul"
            }
          ]
        },
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.matrices.MatMul",
          "name": "MatMul",
          "description": "A product of matrix expressions\n\nExamples\n========\n\n>>> from sympy import MatMul, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 4)\n>>> B = MatrixSymbol('B', 4, 3)\n>>> C = MatrixSymbol('C', 3, 6)\n>>> MatMul(A, B, C)\nA*B*C",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.applyfunc",
              "name": "applyfunc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.matrices.MatMul.as_coeff_matrices",
              "name": "as_coeff_matrices"
            }
          ]
        }
      ]
    },
    {
      "@type": "SoftwareApplication",
      "@id": "sympy:sympy.solvers",
      "name": "sympy.solvers",
      "applicationCategory": "Mathematical Software",
      "classes": []
    },
    {
      "@type": "SoftwareApplication",
      "@id": "sympy:sympy.calculus",
      "name": "sympy.calculus",
      "applicationCategory": "Mathematical Software",
      "classes": [
        {
          "@type": "ComputationalWidget",
          "@id": "sympy:sympy.calculus.AccumBounds",
          "name": "AccumBounds",
          "description": "An accumulation bounds.\n\n# Note AccumulationBounds has an alias: AccumBounds\n\nAccumulationBounds represent an interval `[a, b]`, which is always closed\nat the ends. Here `a` and `b` can be any value from extended real numbers.\n\nThe intended meaning of AccummulationBounds is to give an approximate\nlocation of the accumulation points of a real function at a limit point.\n\nLet `a` and `b` be reals such that `a \\le b`.\n\n`\\left\\langle a, b\\right\\rangle = \\{x \\in \\mathbb{R} \\mid a \\le x \\le b\\}`\n\n`\\left\\langle -\\infty, b\\right\\rangle = \\{x \\in \\mathbb{R} \\mid x \\le b\\} \\cup \\{-\\infty, \\infty\\}`\n\n`\\left\\langle a, \\infty \\right\\rangle = \\{x \\in \\mathbb{R} \\mid a \\le x\\} \\cup \\{-\\infty, \\infty\\}`\n\n`\\left\\langle -\\infty, \\infty \\right\\rangle = \\mathbb{R} \\cup \\{-\\infty, \\infty\\}`\n\n``oo`` and ``-oo`` are added to the second and third definition respectively,\nsince if either ``-oo`` or ``oo`` is an argument, then the other one should\nbe included (though not as an end point). This is forced, since we have,\nfor example, ``1/AccumBounds(0, 1) = AccumBounds(1, oo)``, and the limit at\n`0` is not one-sided. As `x` tends to `0-`, then `1/x \\rightarrow -\\infty`, so `-\\infty`\nshould be interpreted as belonging to ``AccumBounds(1, oo)`` though it need\nnot appear explicitly.\n\nIn many cases it suffices to know that the limit set is bounded.\nHowever, in some other cases more exact information could be useful.\nFor example, all accumulation values of `\\cos(x) + 1` are non-negative.\n(``AccumBounds(-1, 1) + 1 = AccumBounds(0, 2)``)\n\nA AccumulationBounds object is defined to be real AccumulationBounds,\nif its end points are finite reals.\n\nLet `X`, `Y` be real AccumulationBounds, then their sum, difference,\nproduct are defined to be the following sets:\n\n`X + Y = \\{ x+y \\mid x \\in X \\cap y \\in Y\\}`\n\n`X - Y = \\{ x-y \\mid x \\in X \\cap y \\in Y\\}`\n\n`X \\times Y = \\{ x \\times y \\mid x \\in X \\cap y \\in Y\\}`\n\nWhen an AccumBounds is raised to a negative power, if 0 is contained\nbetween the bounds then an infinite range is returned, otherwise if an\nendpoint is 0 then a semi-infinite range with consistent sign will be returned.\n\nAccumBounds in expressions behave a lot like Intervals but the\nsemantics are not necessarily the same. Division (or exponentiation\nto a negative integer power) could be handled with *intervals* by\nreturning a union of the results obtained after splitting the\nbounds between negatives and positives, but that is not done with\nAccumBounds. In addition, bounds are assumed to be independent of\neach other; if the same bound is used in more than one place in an\nexpression, the result may not be the supremum or infimum of the\nexpression (see below). Finally, when a boundary is ``1``,\nexponentiation to the power of ``oo`` yields ``oo``, neither\n``1`` nor ``nan``.\n\nExamples\n========\n\n>>> from sympy import AccumBounds, sin, exp, log, pi, E, S, oo\n>>> from sympy.abc import x\n\n>>> AccumBounds(0, 1) + AccumBounds(1, 2)\nAccumBounds(1, 3)\n\n>>> AccumBounds(0, 1) - AccumBounds(0, 2)\nAccumBounds(-2, 1)\n\n>>> AccumBounds(-2, 3)*AccumBounds(-1, 1)\nAccumBounds(-3, 3)\n\n>>> AccumBounds(1, 2)*AccumBounds(3, 5)\nAccumBounds(3, 10)\n\nThe exponentiation of AccumulationBounds is defined\nas follows:\n\nIf 0 does not belong to `X` or `n > 0` then\n\n`X^n = \\{ x^n \\mid x \\in X\\}`\n\n>>> AccumBounds(1, 4)**(S(1)/2)\nAccumBounds(1, 2)\n\notherwise, an infinite or semi-infinite result is obtained:\n\n>>> 1/AccumBounds(-1, 1)\nAccumBounds(-oo, oo)\n>>> 1/AccumBounds(0, 2)\nAccumBounds(1/2, oo)\n>>> 1/AccumBounds(-oo, 0)\nAccumBounds(-oo, 0)\n\nA boundary of 1 will always generate all nonnegatives:\n\n>>> AccumBounds(1, 2)**oo\nAccumBounds(0, oo)\n>>> AccumBounds(0, 1)**oo\nAccumBounds(0, oo)\n\nIf the exponent is itself an AccumulationBounds or is not an\ninteger then unevaluated results will be returned unless the base\nvalues are positive:\n\n>>> AccumBounds(2, 3)**AccumBounds(-1, 2)\nAccumBounds(1/3, 9)\n>>> AccumBounds(-2, 3)**AccumBounds(-1, 2)\nAccumBounds(-2, 3)**AccumBounds(-1, 2)\n\n>>> AccumBounds(-2, -1)**(S(1)/2)\nsqrt(AccumBounds(-2, -1))\n\nNote: `\\left\\langle a, b\\right\\rangle^2` is not same as `\\left\\langle a, b\\right\\rangle \\times \\left\\langle a, b\\right\\rangle`\n\n>>> AccumBounds(-1, 1)**2\nAccumBounds(0, 1)\n\n>>> AccumBounds(1, 3) < 4\nTrue\n\n>>> AccumBounds(1, 3) < -1\nFalse\n\nSome elementary functions can also take AccumulationBounds as input.\nA function `f` evaluated for some real AccumulationBounds `\\left\\langle a, b \\right\\rangle`\nis defined as `f(\\left\\langle a, b\\right\\rangle) = \\{ f(x) \\mid a \\le x \\le b \\}`\n\n>>> sin(AccumBounds(pi/6, pi/3))\nAccumBounds(1/2, sqrt(3)/2)\n\n>>> exp(AccumBounds(0, 1))\nAccumBounds(1, E)\n\n>>> log(AccumBounds(1, E))\nAccumBounds(0, 1)\n\nSome symbol in an expression can be substituted for a AccumulationBounds\nobject. But it does not necessarily evaluate the AccumulationBounds for\nthat expression.\n\nThe same expression can be evaluated to different values depending upon\nthe form it is used for substitution since each instance of an\nAccumulationBounds is considered independent. For example:\n\n>>> (x**2 + 2*x + 1).subs(x, AccumBounds(-1, 1))\nAccumBounds(-1, 4)\n\n>>> ((x + 1)**2).subs(x, AccumBounds(-1, 1))\nAccumBounds(0, 4)\n\nReferences\n==========\n\n.. [1] https://en.wikipedia.org/wiki/Interval_arithmetic\n\n.. [2] https://fab.cba.mit.edu/classes/S62.12/docs/Hickey_interval.pdf\n\nNotes\n=====\n\nDo not use ``AccumulationBounds`` for floating point interval arithmetic\ncalculations, use ``mpmath.iv`` instead.",
          "methods": [
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.adjoint",
              "name": "adjoint"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.apart",
              "name": "apart"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.args_cnc",
              "name": "args_cnc"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.as_base_exp",
              "name": "as_base_exp"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.as_coeff_Add",
              "name": "as_coeff_Add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.as_coeff_Mul",
              "name": "as_coeff_Mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.as_coeff_add",
              "name": "as_coeff_add"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.as_coeff_exponent",
              "name": "as_coeff_exponent"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.as_coeff_mul",
              "name": "as_coeff_mul"
            },
            {
              "@type": "MathematicalFunction",
              "@id": "sympy:sympy.calculus.AccumBounds.as_coefficient",
              "name": "as_coefficient"
            }
          ]
        }
      ]
    }
  ]
}